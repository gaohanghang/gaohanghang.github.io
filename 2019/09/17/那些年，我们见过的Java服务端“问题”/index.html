<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="个人公众号《骇客与画家》" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>那些年，我们见过的Java服务端“问题” |  高行行的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-那些年，我们见过的Java服务端“问题”"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  那些年，我们见过的Java服务端“问题”
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/09/17/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E4%BB%AC%E8%A7%81%E8%BF%87%E7%9A%84Java%E6%9C%8D%E5%8A%A1%E7%AB%AF%E2%80%9C%E9%97%AE%E9%A2%98%E2%80%9D/" class="article-date">
  <time datetime="2019-09-17T13:06:42.000Z" itemprop="datePublished">2019-09-17</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> 字数统计:</span>
            <span class="post-count">7.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> 阅读时长≈</span>
            <span class="post-count">27 分钟</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址: <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/sxXVzB_t1qMAwqBCsGrVNg">https://mp.weixin.qq.com/s/sxXVzB_t1qMAwqBCsGrVNg</a></p>
<p>写的非常棒，通俗易懂，而且讲的是java服务端开发过程中大概率会碰到的问题，非常值得看</p>
<p><strong>小结：</strong></p>
<p>分布式好处</p>
<p>多线程使用</p>
<p>合理定义流程</p>
<p>系统之间的交互</p>
<p>数据查询分页</p>
</blockquote>
<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a><strong>导读</strong></h2><p>明代著名的心学集大成者王阳明先生在《传习录》中有云：“道无精粗，人之所见有精粗。如这一间房，人初进来，只见一个大规模如此。处久，便柱壁之类，一一看得明白。再久，如柱上有些文藻，细细都看出来。然只是一间房。”</p>
<p>是的，知识理论哪有什么精粗之分，只是人的认识程度不同而已。笔者在技术圈摸爬滚打数年，接触了各式各样的Java服务端架构，见得多了自然也就认识深了，就能分辨出各种方案的优劣了。这里总结了一些初创公司存在的Java服务端问题，并尝试性地给出了一些解决方案，供大家交流参考。</p>
<h2 id="1-系统不是分布式"><a href="#1-系统不是分布式" class="headerlink" title="**1.**系统不是分布式"></a>**1.**系统不是分布式</h2><h3 id="1-1-单机版系统抢单案例"><a href="#1-1-单机版系统抢单案例" class="headerlink" title="1.1.单机版系统抢单案例"></a><strong>1.1.单机版系统抢单案例</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抢取订单函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">grabOrder</span><span class="params">(Long orderId, Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取订单信息</span></span><br><span class="line">    <span class="type">OrderDO</span> <span class="variable">order</span> <span class="operator">=</span> orderDAO.get(orderId);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(order)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizRuntimeException</span>(String.format(<span class="string">&quot;订单(%s)不存在&quot;</span>, orderId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(order.getStatus, OrderStatus.WAITING_TO_GRAB.getValue())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizRuntimeException</span>(String.format(<span class="string">&quot;订单(%s)已被抢&quot;</span>, orderId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置订单被抢</span></span><br><span class="line">    orderDAO.setGrabed(orderId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码，在一台服务器上运行没有任何问题。进入函数grabOrder（抢取订单）时，利用synchronized关键字把整个函数锁定，要么进入函数前订单未被人抢取，从而抢单成功，要么进入函数前订单已被抢取导致抢单失败，绝对不会出现进入函数前订单未被抢取而进入函数后订单又被抢取的情况。</p>
<p>但是，如果上面的代码在两台服务器上同时运行，由于Java的synchronized关键字只在一个虚拟机内生效，所以就会导致两个人能够同时抢取一个订单，但会以最后一个写入数据库的数据为准。所以，大多数的单机版系统，是无法作为分布式系统运行的。</p>
<h3 id="1-2-分布式系统抢单案例"><a href="#1-2-分布式系统抢单案例" class="headerlink" title="1.2.分布式系统抢单案例"></a><strong>1.2.分布式系统抢单案例</strong></h3><p>添加分布式锁，进行代码优化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 抢取订单函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">grabOrder</span><span class="params">(Long orderId, Long userId)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">lockId</span> <span class="operator">=</span> orderDistributedLock.lock(orderId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        grabOrderWithoutLock(orderId, userId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        orderDistributedLock.unlock(orderId, lockId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不带锁的抢取订单函数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">grabOrderWithoutLock</span><span class="params">(Long orderId, Long userId)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取订单信息</span></span><br><span class="line">    <span class="type">OrderDO</span> <span class="variable">order</span> <span class="operator">=</span> orderDAO.get(orderId);</span><br><span class="line">    <span class="keyword">if</span> (Objects.isNull(order)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizRuntimeException</span>(String.format(<span class="string">&quot;订单(%s)不存在&quot;</span>, orderId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查订单状态</span></span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(order.getStatus, OrderStatus.WAITING_TO_GRAB.getValue())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BizRuntimeException</span>(String.format(<span class="string">&quot;订单(%s)已被抢&quot;</span>, orderId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置订单被抢</span></span><br><span class="line">    orderDAO.setGrabed(orderId, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化后的代码，在调用函数grabOrderWithoutLock（不带锁的抢取订单）前后，利用分布式锁orderDistributedLock（订单分布式锁）进行加锁和释放锁，跟单机版的synchronized关键字加锁效果基本一样。</p>
<h3 id="1-3-分布式系统的优缺点"><a href="#1-3-分布式系统的优缺点" class="headerlink" title="1.3.分布式系统的优缺点"></a><strong>1.3.分布式系统的优缺点</strong></h3><p><strong>分布式系统（Distributed System）</strong>是支持分布式处理的软件系统，是由通信网络互联的多处理机体系结构上执行任务的系统，包括分布式操作系统、分布式程序设计语言及其编译系统、分布式文件系统分布式数据库系统等。</p>
<p><strong>分布式系统的优点：</strong></p>
<ul>
<li>可靠性、高容错性：</li>
</ul>
<p>一台服务器的崩溃，不会影响其它服务器，其它服务器仍能提供服务。</p>
<ul>
<li>可扩展性：</li>
</ul>
<p>如果系统服务能力不足，可以水平扩展更多服务器。</p>
<ul>
<li>灵活性：</li>
</ul>
<p>可以很容易的安装、实施、扩容和升级系统。</p>
<ul>
<li>性能高：</li>
</ul>
<p>拥有多台服务器的计算能力，比单台服务器处理速度更快。</p>
<ul>
<li>性价比高：</li>
</ul>
<p>分布式系统对服务器硬件要求很低，可以选用廉价服务器搭建分布式集群，从而得到更好的性价比。</p>
<p><strong>分布式系统的缺点：</strong></p>
<ul>
<li>排查难度高：</li>
</ul>
<p>由于系统分布在多台服务器上，故障排查和问题诊断难度较高。</p>
<ul>
<li>软件支持少：</li>
</ul>
<p>分布式系统解决方案的软件支持较少。</p>
<ul>
<li>建设成本高：</li>
</ul>
<p>需要多台服务器搭建分布式系统。</p>
<p>曾经有不少的朋友咨询我：”找外包做移动应用，需要注意哪些事项？”</p>
<p><strong>首先，确定是否需要用分布式系统。</strong>软件预算有多少？预计用户量有多少？预计访问量有多少？是否只是业务前期试水版？单台服务器能否解决？是否接收短时间宕机？……如果综合考虑，单机版系统就可以解决的，那就不要采用分布式系统了。因为单机版系统和分布式系统的差别很大，相应的软件研发成本的差别也很大。</p>
<p><strong>其次，确定是否真正的分布式系统。</strong>分布式系统最大的特点，就是当系统服务能力不足时，能够通过水平扩展的方式，通过增加服务器来增加服务能力。然而，单机版系统是不支持水平扩展的，强行扩展就会引起一系列数据问题。由于单机版系统和分布式系统的研发成本差别较大，市面上的外包团队大多用单机版系统代替分布式系统交付。</p>
<p>那么，如何确定你的系统是真正意义上的分布式系统呢？从软件上来说，是否采用了分布式软件解决方案；从硬件上来说，是否采用了分布式硬件部署方案。</p>
<h3 id="1-4-分布式软件解决方案"><a href="#1-4-分布式软件解决方案" class="headerlink" title="1.4.分布式软件解决方案"></a><strong>1.4.分布式软件解决方案</strong></h3><p>作为一个合格的分布式系统，需要根据实际需求采用相应的分布式软件解决方案。</p>
<h4 id="1-4-1-分布式锁"><a href="#1-4-1-分布式锁" class="headerlink" title="1.4.1.分布式锁"></a><strong>1.4.1.分布式锁</strong></h4><p>分布式锁是单机锁的一种扩展，主要是为了锁住分布式系统中的物理块或逻辑块，用以此保证不同服务之间的逻辑和数据的一致性。</p>
<p>目前，主流的分布式锁实现方式有3种：</p>
<ol>
<li>基于数据库实现的分布式锁；</li>
<li>基于Redis实现的分布式锁；</li>
<li>基于Zookeeper实现的分布式锁。</li>
</ol>
<h4 id="1-4-2-分布式消息"><a href="#1-4-2-分布式消息" class="headerlink" title="1.4.2.分布式消息"></a><strong>1.4.2.分布式消息</strong></h4><p>分布式消息中间件是支持在分布式系统中发送和接受消息的软件基础设施。常见的分布式消息中间件有ActiveMQ、RabbitMQ、Kafka、MetaQ等。</p>
<p>MetaQ（全称Metamorphosis）是一个高性能、高可用、可扩展的分布式消息中间件，思路起源于LinkedIn的Kafka，但并不是Kafka的一个拷贝。MetaQ具有消息存储顺序写、吞吐量大和支持本地和XA事务等特性，适用于大吞吐量、顺序消息、广播和日志数据传输等场景。</p>
<h4 id="1-4-3-数据库分片分组"><a href="#1-4-3-数据库分片分组" class="headerlink" title="1.4.3.数据库分片分组"></a><strong>1.4.3.数据库分片分组</strong></h4><p>针对大数据量的数据库，一般会采用”分片分组”策略：</p>
<p><strong>分片(shard)<strong>：主要解决扩展性问题，属于水平拆分。引入分片，就引入了数据路由和分区键的概念。其中，</strong>分表</strong>解决的是数据量过大的问题，<strong>分库</strong>解决的是数据库性能瓶颈的问题。</p>
<p><strong>分组(group)<strong>：主要解决可用性问题，通过</strong>主从复制</strong>的方式实现，并提供<strong>读写分离</strong>策略用以提高数据库性能。</p>
<h4 id="1-4-4-分布式计算"><a href="#1-4-4-分布式计算" class="headerlink" title="1.4.4.分布式计算"></a><strong>1.4.4.分布式计算</strong></h4><p>分布式计算( Distributed computing )是一种”把需要进行大量计算的工程数据分割成小块，由多台计算机分别计算；在上传运算结果后，将结果统一合并得出数据结论”的科学。</p>
<p>当前的高性能服务器在处理海量数据时，其计算能力、内存容量等指标都远远无法达到要求。在大数据时代，工程师采用廉价的服务器组成分布式服务集群，以集群协作的方式完成海量数据的处理，从而解决单台服务器在计算与存储上的瓶颈。Hadoop、Storm以及Spark是常用的分布式计算中间件，Hadoop是对非实时数据做批量处理的中间件，Storm和Spark是对实时数据做流式处理的中间件。</p>
<p>除此之外，还有更多的分布式软件解决方案，这里就不再一一介绍了。</p>
<h3 id="1-5-分布式硬件部署方案"><a href="#1-5-分布式硬件部署方案" class="headerlink" title="1.5.分布式硬件部署方案"></a><strong>1.5.分布式硬件部署方案</strong></h3><p>介绍完服务端的分布式软件解决方案，就不得不介绍一下服务端的分布式硬件部署方案。这里，只画出了服务端常见的接口服务器、MySQL数据库、Redis缓存，而忽略了其它的云存储服务、消息队列服务、日志系统服务……</p>
<h4 id="1-5-1-一般单机版部署方案"><a href="#1-5-1-一般单机版部署方案" class="headerlink" title="1.5.1.一般单机版部署方案"></a><strong>1.5.1.一般单机版部署方案</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768pdc7bfj30lr0bejs2.jpg"></p>
<p><strong>架构说明：</strong></p>
<p>只有1台接口服务器、1个MySQL数据库、1个可选Redis缓存，可能都部署在同一台服务器上。</p>
<p><strong>适用范围：</strong></p>
<p>适用于演示环境、测试环境以及不怕宕机且日PV在5万以内的小型商业应用。</p>
<h4 id="1-5-2-中小型分布式硬件部署方案"><a href="#1-5-2-中小型分布式硬件部署方案" class="headerlink" title="1.5.2.中小型分布式硬件部署方案"></a><strong>1.5.2.中小型分布式硬件部署方案</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768qmqegvj30q60fswgo.jpg"></p>
<p><strong>架构说明：</strong></p>
<p>通过SLB&#x2F;Nginx组成一个负载均衡的接口服务器集群，MySQL数据库和Redis缓存采用了一主一备（或多备）的部署方式。</p>
<p><strong>适用范围：</strong></p>
<p>适用于日PV在500万以内的中小型商业应用。</p>
<h4 id="1-5-3-大型分布式硬件部署方案"><a href="#1-5-3-大型分布式硬件部署方案" class="headerlink" title="1.5.3.大型分布式硬件部署方案"></a><strong>1.5.3.大型分布式硬件部署方案</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768qtdzkqj30u00dejtl.jpg"></p>
<p><strong>架构说明：</strong></p>
<p>通过SLB&#x2F;Nginx组成一个负载均衡的接口服务器集群，利用分片分组策略组成一个MySQL数据库集群和Redis缓存集群。</p>
<p><strong>适用范围：</strong></p>
<p>适用于日PV在500万以上的大型商业应用。</p>
<h2 id="2-多线程使用不正确"><a href="#2-多线程使用不正确" class="headerlink" title="2.多线程使用不正确"></a><strong>2.多线程使用不正确</strong></h2><p>多线程最主要目的就是”最大限度地利用CPU资源”，可以把串行过程变成并行过程，从而提高了程序的执行效率。</p>
<h3 id="2-1-一个慢接口案例"><a href="#2-1-一个慢接口案例" class="headerlink" title="2.1.一个慢接口案例"></a><strong>2.1.一个慢接口案例</strong></h3><p>假设在用户登录时，如果是新用户，需要创建用户信息，并发放新用户优惠券。例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 登录函数(示意写法)</span></span><br><span class="line"><span class="keyword">public</span> UserVO <span class="title function_">login</span><span class="params">(String phoneNumber, String verifyCode)</span> &#123;</span><br><span class="line">    <span class="comment">// 检查验证码</span></span><br><span class="line">    <span class="keyword">if</span> (!checkVerifyCode(phoneNumber, verifyCode)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExampleException</span>(<span class="string">&quot;验证码错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查用户存在</span></span><br><span class="line">    <span class="type">UserDO</span> <span class="variable">user</span> <span class="operator">=</span> userDAO.getByPhoneNumber(phoneNumber);</span><br><span class="line">    <span class="keyword">if</span> (Objects.nonNull(user)) &#123;</span><br><span class="line">        <span class="keyword">return</span> transUser(user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新用户</span></span><br><span class="line">    <span class="keyword">return</span> createNewUser(user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO <span class="title function_">createNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新用户</span></span><br><span class="line">    <span class="type">UserDO</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDO</span>();</span><br><span class="line">    ...</span><br><span class="line">    userDAO.insert(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定优惠券</span></span><br><span class="line">    couponService.bindCoupon(user.getId(), CouponType.NEW_USER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新用户</span></span><br><span class="line">    <span class="keyword">return</span> transUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，绑定优惠券（bindCoupon）是给用户绑定新用户优惠券，然后再给用户发送推送通知。如果随着优惠券数量越来越多，该函数也会变得越来越慢，执行时间甚至超过1秒，并且没有什么优化空间。现在，登录（login）函数就成了名副其实的慢接口，需要进行接口优化。</p>
<h3 id="2-2-采用多线程优化"><a href="#2-2-采用多线程优化" class="headerlink" title="2.2.采用多线程优化"></a><strong>2.2.采用多线程优化</strong></h3><p>通过分析发现，绑定优惠券（bindCoupon）函数可以异步执行。首先想到的是采用多线程解决该问题，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO <span class="title function_">createNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新用户</span></span><br><span class="line">    <span class="type">UserDO</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDO</span>();</span><br><span class="line">    ...</span><br><span class="line">    userDAO.insert(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定优惠券</span></span><br><span class="line">    executorService.execute(()-&gt;couponService.bindCoupon(user.getId(), CouponType.NEW_USER));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新用户</span></span><br><span class="line">    <span class="keyword">return</span> transUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，在新线程中执行绑定优惠券（bindCoupon）函数，使用户登录（login）函数性能得到很大的提升。但是，如果在新线程执行绑定优惠券函数过程中，系统发生重启或崩溃导致线程执行失败，用户将永远获取不到新用户优惠券。除非提供用户手动领取优惠券页面，否则就需要程序员后台手工绑定优惠券。所以，用采用多线程优化慢接口，并不是一个完善的解决方案。</p>
<h3 id="2-3-采用消息队列优化"><a href="#2-3-采用消息队列优化" class="headerlink" title="2.3.采用消息队列优化"></a><strong>2.3.采用消息队列优化</strong></h3><p>如果要保证绑定优惠券函数执行失败后能够重启执行，可以采用数据库表、Redis队列、消息队列的等多种解决方案。由于篇幅优先，这里只介绍采用MetaQ消息队列解决方案，并省略了MetaQ相关配置仅给出了核心代码。</p>
<span id="more"></span>

<p>消息生产者代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新用户函数</span></span><br><span class="line"><span class="keyword">private</span> UserVO <span class="title function_">createNewUser</span><span class="params">(String phoneNumber)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新用户</span></span><br><span class="line">    <span class="type">UserDO</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDO</span>();</span><br><span class="line">    ...</span><br><span class="line">    userDAO.insert(user);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送优惠券消息</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> user.getId();</span><br><span class="line">    <span class="type">CouponMessageDataVO</span> <span class="variable">data</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CouponMessageDataVO</span>();</span><br><span class="line">    data.setUserId(userId);</span><br><span class="line">    data.setCouponType(CouponType.NEW_USER);</span><br><span class="line">    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>(TOPIC, TAG, userId, JSON.toJSONBytes(data));</span><br><span class="line">    <span class="type">SendResult</span> <span class="variable">result</span> <span class="operator">=</span> metaqTemplate.sendMessage(message);</span><br><span class="line">    <span class="keyword">if</span> (!Objects.equals(result, SendStatus.SEND_OK)) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;发送用户(&#123;&#125;)绑定优惠券消息失败:&#123;&#125;&quot;</span>, userId, JSON.toJSONString(result));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回新用户</span></span><br><span class="line">    <span class="keyword">return</span> transUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：可能出现发生消息不成功，但是这种概率相对较低。</p>
<p>消息消费者代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优惠券服务类</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CouponService</span> <span class="keyword">extends</span> <span class="title class_">DefaultMessageListener</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">// 消息处理函数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onReceiveMessages</span><span class="params">(MetaqMessage&lt;String&gt; message)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取消息体</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">body</span> <span class="operator">=</span> message.getBody();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(body)) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;获取消息(&#123;&#125;)体为空&quot;</span>, message.getId());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析消息数据</span></span><br><span class="line">        <span class="type">CouponMessageDataVO</span> <span class="variable">data</span> <span class="operator">=</span> JSON.parseObject(body, CouponMessageDataVO.class);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(data)) &#123;</span><br><span class="line">            log.warn(<span class="string">&quot;解析消息(&#123;&#125;)体为空&quot;</span>, message.getId());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定优惠券</span></span><br><span class="line">        bindCoupon(data.getUserId(), data.getCouponType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决方案优点：</strong></p>
<p>采集MetaQ消息队列优化慢接口解决方案的优点：</p>
<ol>
<li>如果系统发生重启或崩溃，导致消息处理函数执行失败，不会确认消息已消费；由于MetaQ支持多服务订阅同一队列，该消息可以转到别的服务进行消费，亦或等到本服务恢复正常后再进行消费。</li>
<li>消费者可多服务、多线程进行消费消息，即便消息处理时间较长，也不容易引起消息积压；即便引起消息积压，也可以通过扩充服务实例的方式解决。</li>
<li>如果需要重新消费该消息，只需要在MetaQ管理平台上点击”消息验证”即可。</li>
</ol>
<h2 id="3-流程定义不合理"><a href="#3-流程定义不合理" class="headerlink" title="3.流程定义不合理"></a><strong>3.流程定义不合理</strong></h2><h3 id="3-1-原有的采购流程"><a href="#3-1-原有的采购流程" class="headerlink" title="3.1.原有的采购流程"></a>3.1.原有的采购流程</h3><p>这是一个简易的采购流程，由库管系统发起采购，采购员开始采购，采购员完成采购，同时回流采集订单到库管系统。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768r3wcgrj30fu02qjrp.jpg"></p>
<p>其中，完成采购动作的核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 完成采购动作函数(此处省去获取采购单/验证状态/锁定采购单等逻辑) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishPurchase</span><span class="params">(PurchaseOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">// 完成相关处理</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回流采购单(调用HTTP接口)</span></span><br><span class="line">    backflowPurchaseOrder(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置完成状态</span></span><br><span class="line">    purchaseOrderDAO.setStatus(order.getId(), PurchaseOrderStatus.FINISHED.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数backflowPurchaseOrder（回流采购单）调用了HTTP接口，可能引起以下问题：</p>
<ol>
<li>该函数可能耗费时间较长，导致完成采购接口成为慢接口；</li>
<li>该函数可能失败抛出异常，导致客户调用完成采购接口失败。</li>
</ol>
<h3 id="3-2-优化的采购流程"><a href="#3-2-优化的采购流程" class="headerlink" title="3.2.优化的采购流程"></a><strong>3.2.优化的采购流程</strong></h3><p>通过需求分析，把”采购员完成采购并回流采集订单”动作拆分为”采购员完成采购”和”回流采集订单”两个独立的动作，把”采购完成”拆分为”采购完成”和”回流完成”两个独立的状态，更方便采购流程的管理和实现。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768rz9oqyj30me02qaaj.jpg">拆分采购流程的动作和状态后，核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 完成采购动作函数(此处省去获取采购单/验证状态/锁定采购单等逻辑) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishPurchase</span><span class="params">(PurchaseOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">// 完成相关处理</span></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置完成状态</span></span><br><span class="line">    purchaseOrderDAO.setStatus(order.getId(), PurchaseOrderStatus.FINISHED.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 执行回流动作函数(此处省去获取采购单/验证状态/锁定采购单等逻辑) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeBackflow</span><span class="params">(PurchaseOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">// 回流采购单(调用HTTP接口)</span></span><br><span class="line">    backflowPurchaseOrder(order);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回流状态</span></span><br><span class="line">    purchaseOrderDAO.setStatus(order.getId(), PurchaseOrderStatus.BACKFLOWED.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，函数executeBackflow（执行回流）由定时作业触发执行。如果回流采购单失败，采购单状态并不会修改为”已回流”；等下次定时作业执行时，将会继续执行回流动作；直到回流采购单成功为止。</p>
<h3 id="3-3-有限状态机介绍"><a href="#3-3-有限状态机介绍" class="headerlink" title="3.3.有限状态机介绍"></a>3.3.有限状态机介绍</h3><h4 id="3-3-1-概念"><a href="#3-3-1-概念" class="headerlink" title="3.3.1.概念"></a><strong>3.3.1.概念</strong></h4><p>有限状态机（Finite-state machine，FSM），又称有限状态自动机，简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的一个数学模型。</p>
<h4 id="3-3-2-要素"><a href="#3-3-2-要素" class="headerlink" title="3.3.2.要素"></a><strong>3.3.2.要素</strong></h4><p>状态机可归纳为4个要素：现态、条件、动作、次态。</p>
<p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768s9uld9j309a04pglq.jpg"></p>
<p><strong>现态：</strong>指当前流程所处的状态，包括起始、中间、终结状态。</p>
<p><strong>条件：</strong>也可称为事件；当一个条件被满足时，将会触发一个动作并执行一次状态的迁移。</p>
<p><strong>动作：</strong>当条件满足后要执行的动作。动作执行完毕后，可以迁移到新的状态，也可以仍旧保持原状态。</p>
<p><strong>次态：</strong>当条件满足后要迁往的状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</p>
<h4 id="3-3-3-状态"><a href="#3-3-3-状态" class="headerlink" title="3.3.3.状态"></a><strong>3.3.3.状态</strong></h4><p>状态表示流程中的持久状态，流程图上的每一个圈代表一个状态。</p>
<p><strong>初始状态：</strong> 流程开始时的某一状态；</p>
<p><strong>中间状态：</strong> 流程中间过程的某一状态；</p>
<p><strong>终结状态：</strong> 流程完成时的某一状态。</p>
<p><strong>使用建议：</strong></p>
<ol>
<li>状态必须是一个持久状态，而不能是一个临时状态；</li>
<li>终结状态不能是中间状态，不能继续进行流程流转；</li>
<li>状态划分合理，不要把多个状态强制合并为一个状态；</li>
<li>状态尽量精简，同一状态的不同情况可以用其它字段表示。</li>
</ol>
<h4 id="3-3-4-动作"><a href="#3-3-4-动作" class="headerlink" title="3.3.4.动作"></a><strong>3.3.4.动作</strong></h4><p>动作的三要素：角色、现态、次态，流程图上的每一条线代表一个动作。</p>
<p><strong>角色：</strong> 谁发起的这个操作，可以是用户、定时任务等；</p>
<p><strong>现态：</strong> 触发动作时当前的状态，是执行动作的前提条件；</p>
<p><strong>次态：</strong> 完成动作后达到的状态，是执行动作的最终目标。</p>
<p><strong>使用建议：</strong></p>
<ol>
<li>每个动作执行前，必须检查当前状态和触发动作状态的一致性；</li>
<li>状态机的状态更改，只能通过动作进行，其它操作都是不符合规范的；</li>
<li>需要添加分布式锁保证动作的原子性，添加数据库事务保证数据的一致性；</li>
<li>类似的动作（比如操作用户、请求参数、动作含义等）可以合并为一个动作，并根据动作执行结果转向不同的状态。</li>
</ol>
<h2 id="4-系统间交互不科学"><a href="#4-系统间交互不科学" class="headerlink" title="4.系统间交互不科学"></a><strong>4.系统间交互不科学</strong></h2><h3 id="4-1-直接通过数据库交互"><a href="#4-1-直接通过数据库交互" class="headerlink" title="4.1.直接通过数据库交互"></a><strong>4.1.直接通过数据库交互</strong></h3><p>在一些项目中，系统间交互不通过接口调用和消息队列，而是通过数据库直接访问。问其原因，回答道：”项目工期太紧张，直接访问数据库，简单又快捷”。</p>
<p>还是以上面的采购流程为例——采购订单由库管系统发起，由采购系统负责采购，采购完成后通知库管系统，库管系统进入入库操作。采购系统采购完成后，通知库管系统数据库的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 执行回流动作函数(此处省去获取采购单/验证状态/锁定采购单等逻辑) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeBackflow</span><span class="params">(PurchaseOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">// 完成原始采购单</span></span><br><span class="line">    rawPurchaseOrderDAO.setStatus(order.getRawId(), RawPurchaseOrderStatus.FINISHED.getValue());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回流状态</span></span><br><span class="line">    purchaseOrderDAO.setStatus(order.getId(), PurchaseOrderStatus.BACKFLOWED.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，通过rawPurchaseOrderDAO（原始采购单DAO）直接访问库管系统的数据库表，并设置原始采购单状态为已完成。</p>
<p>一般情况下，直接通过数据访问的方式是不会有问题的。但是，一旦发生竞态，就会导致数据不同步。有人会说，可以考虑使用同一分布式锁解决该问题。是的，这种解决方案没有问题，只是又在系统间共享了分布式锁。</p>
<p><strong>直接通过数据库交互的缺点：</strong></p>
<ol>
<li>直接暴露数据库表，容易产生数据安全问题；</li>
<li>多个系统操作同一数据库表，容易造成数据库表数据混乱；</li>
<li>操作同一个数据库表的代码，分布在不同的系统中，不便于管理和维护；</li>
<li>具有数据库表这样的强关联，无法实现系统间的隔离和解耦。</li>
</ol>
<h3 id="4-2-通过Dubbo接口交互"><a href="#4-2-通过Dubbo接口交互" class="headerlink" title="4.2.通过Dubbo接口交互"></a><strong>4.2.通过Dubbo接口交互</strong></h3><p>由于采购系统和库管系统都是内部系统，可以通过类似Dubbo的RPC接口进行交互。</p>
<p><strong>库管系统代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 采购单服务接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PurchaseOrderService</span> &#123;</span><br><span class="line">    <span class="comment">/** 完成采购单函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishPurchaseOrder</span><span class="params">(Long orderId)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 采购单服务实现 */</span></span><br><span class="line"><span class="meta">@Service(&quot;purchaseOrderService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PurchaseOrderServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">PurchaseOrderService</span> &#123;</span><br><span class="line">    <span class="comment">/** 完成采购单函数 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">finishPurchaseOrder</span><span class="params">(Long orderId)</span> &#123;</span><br><span class="line">        <span class="comment">// 相关处理</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成采购单</span></span><br><span class="line">        purchaseOrderService.finishPurchaseOrder(order.getRawId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，库管系统通过Dubbo把PurchaseOrderServiceImpl（采购单服务实现）以PurchaseOrderService（采购单服务接口）定义的接口服务暴露给采购系统。这里，省略了Dubbo开发服务接口相关配置。</p>
<p>采购系统代码：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 执行回流动作函数(此处省去获取采购单/验证状态/锁定采购单等逻辑) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeBackflow</span><span class="params">(PurchaseOrder order)</span> &#123;</span><br><span class="line">    <span class="comment">// 完成采购单</span></span><br><span class="line">    purchaseOrderService.finishPurchaseOrder(order.getRawId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回流状态</span></span><br><span class="line">    purchaseOrderDAO.setStatus(order.getId(), PurchaseOrderStatus.BACKFLOWED.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，purchaseOrderService（采购单服务）为库管系统PurchaseOrderService（采购单服务）在采购系统中的Dubbo服务客户端存根，通过该服务调用库管系统的服务接口函数finishPurchaseOrder（完成采购单函数）。</p>
<p>这样，采购系统和库管系统自己的强关联，通过Dubbo就简单地实现了系统隔离和解耦。当然，除了采用Dubbo接口外，还可以采用HTTPS、HSF、WebService等同步接口调用方式，也可以采用MetaQ等异步消息通知方式。</p>
<h3 id="4-3-常见系统间交互协议"><a href="#4-3-常见系统间交互协议" class="headerlink" title="4.3.常见系统间交互协议"></a><strong>4.3.常见系统间交互协议</strong></h3><h4 id="4-3-1-同步接口调用"><a href="#4-3-1-同步接口调用" class="headerlink" title="4.3.1.同步接口调用"></a><strong>4.3.1.同步接口调用</strong></h4><p>同步接口调用是以一种阻塞式的接口调用机制。常见的交互协议有：</p>
<ol>
<li>HTTP&#x2F;HTTPS接口；</li>
<li>WebService接口；</li>
<li>Dubbo&#x2F;HSF接口；</li>
<li>CORBA接口。</li>
</ol>
<h4 id="4-3-2-异步消息通知"><a href="#4-3-2-异步消息通知" class="headerlink" title="4.3.2.异步消息通知"></a><strong>4.3.2.异步消息通知</strong></h4><p>异步消息通知是一种通知式的信息交互机制。当系统发生某种事件时，会主动通知相应的系统。常见的交互协议有：</p>
<ol>
<li>MetaQ的消息通知；</li>
<li>CORBA消息通知。</li>
</ol>
<h3 id="4-4-常见系统间交互方式"><a href="#4-4-常见系统间交互方式" class="headerlink" title="4.4.常见系统间交互方式"></a><strong>4.4.常见系统间交互方式</strong></h3><h4 id="4-4-1-请求-应答"><a href="#4-4-1-请求-应答" class="headerlink" title="4.4.1.请求-应答"></a><strong>4.4.1.请求-应答</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768sh1fgqj30a808pmxe.jpg"></p>
<p>适用范围：</p>
<p>适合于简单的耗时较短的接口同步调用场景，比如Dubbo接口同步调用。</p>
<h4 id="4-4-2-通知-确认"><a href="#4-4-2-通知-确认" class="headerlink" title="4.4.2.通知-确认"></a><strong>4.4.2.通知-确认</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768t2iqgej30980790sw.jpg"></p>
<p>适用范围：</p>
<p>适合于简单的异步消息通知场景，比如MetaQ消息通知。</p>
<h4 id="4-4-3-请求-应答-查询-返回"><a href="#4-4-3-请求-应答-查询-返回" class="headerlink" title="4.4.3.请求-应答-查询-返回"></a><strong>4.4.3.请求-应答-查询-返回</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768t79awej30980dfq3g.jpg"></p>
<p>适用范围：</p>
<p>适合于复杂的耗时较长的接口同步调用场景，比如提交作业任务并定期查询任务结果。</p>
<h4 id="4-4-4-请求-应答-回调"><a href="#4-4-4-请求-应答-回调" class="headerlink" title="4.4.4.请求-应答-回调"></a><strong>4.4.4.请求-应答-回调</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768tcxb37j30980bu74q.jpg"></p>
<p>适用范围：</p>
<p>适合于复杂的耗时较长的接口同步调用和异步回调相结合的场景，比如支付宝的订单支付。</p>
<h4 id="4-4-5-请求-应答-通知-确认"><a href="#4-4-5-请求-应答-通知-确认" class="headerlink" title="4.4.5.请求-应答-通知-确认"></a><strong>4.4.5.请求-应答-通知-确认</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768tiij81j30980but95.jpg"></p>
<p>适用范围：</p>
<p>适合于复杂的耗时较长的接口同步调用和异步消息通知相结合的场景，比如提交作业任务并等待完成消息通知。</p>
<h4 id="4-4-6-通知-确认-通知-确认"><a href="#4-4-6-通知-确认-通知-确认" class="headerlink" title="4.4.6.通知-确认-通知-确认"></a><strong>4.4.6.通知-确认-通知-确认</strong></h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g768tue0jhj30980bs0t4.jpg"></p>
<p>适用范围：</p>
<p>适合于复杂的耗时较长的异步消息通知场景。</p>
<h2 id="5-数据查询不分页"><a href="#5-数据查询不分页" class="headerlink" title="5.数据查询不分页"></a><strong>5.数据查询不分页</strong></h2><p>在数据查询时，由于未能对未来数据量做出正确的预估，很多情况下都没有考虑数据的分页查询。</p>
<h3 id="5-1-普通查询案例"><a href="#5-1-普通查询案例" class="headerlink" title="5.1.普通查询案例"></a><strong>5.1.普通查询案例</strong></h3><p>以下是查询过期订单的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 订单DAO接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDAO</span> &#123;</span><br><span class="line">    <span class="comment">/** 查询过期订单函数 */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_order where status = 5 and gmt_create &lt; date_sub(current_timestamp, interval 30 day)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderDO&gt; <span class="title function_">queryTimeout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 订单服务接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">/** 查询过期订单函数 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderVO&gt; <span class="title function_">queryTimeout</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当过期订单数量很少时，以上代码不会有任何问题。但是，当过期订单数量达到几十万上千万时，以上代码就会出现以下问题：</p>
<ol>
<li>数据量太大，导致服务端的内存溢出；</li>
<li>数据量太大，导致查询接口超时、返回数据超时等；</li>
<li>数据量太大，导致客户端的内存溢出。</li>
</ol>
<p>所以，在数据查询时，特别是不能预估数据量的大小时，需要考虑数据的分页查询。</p>
<p>这里，主要介绍”设置最大数量”和”采用分页查询”两种方式。</p>
<h3 id="5-2-设置最大数量"><a href="#5-2-设置最大数量" class="headerlink" title="5.2.设置最大数量"></a><strong>5.2.设置最大数量</strong></h3><p>“设置最大数量”是一种最简单的分页查询，相当于只返回第一页数据。例子代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 订单DAO接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDAO</span> &#123;</span><br><span class="line">    <span class="comment">/** 查询过期订单函数 */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_order where status = 5 and gmt_create &lt; date_sub(current_timestamp, interval 30 day) limit 0, #&#123;maxCount&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderDO&gt; <span class="title function_">queryTimeout</span><span class="params">(<span class="meta">@Param(&quot;maxCount&quot;)</span> Integer maxCount)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 订单服务接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">/** 查询过期订单函数 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderVO&gt; <span class="title function_">queryTimeout</span><span class="params">(Integer maxCount)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用于没有分页需求、但又担心数据过多导致内存溢出、数据量过大的查询。</p>
<h3 id="5-3-采用分页查询"><a href="#5-3-采用分页查询" class="headerlink" title="5.3.采用分页查询"></a><strong>5.3.采用分页查询</strong></h3><p>“采用分页查询”是指定startIndex（开始序号）和pageSize（页面大小）进行数据查询，或者指定pageIndex（分页序号）和pageSize（页面大小）进行数据查询。例子代码如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 订单DAO接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDAO</span> &#123;</span><br><span class="line">    <span class="comment">/** 统计过期订单函数 */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select count(*) from t_order where status = 5 and gmt_create &lt; date_sub(current_timestamp, interval 30 day)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">countTimeout</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">/** 查询过期订单函数 */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_order where status = 5 and gmt_create &lt; date_sub(current_timestamp, interval 30 day) limit #&#123;startIndex&#125;, #&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderDO&gt; <span class="title function_">queryTimeout</span><span class="params">(<span class="meta">@Param(&quot;startIndex&quot;)</span> Long startIndex, <span class="meta">@Param(&quot;pageSize&quot;)</span> Integer pageSize)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 订单服务接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">/** 查询过期订单函数 */</span></span><br><span class="line">    <span class="keyword">public</span> PageData&lt;OrderVO&gt; <span class="title function_">queryTimeout</span><span class="params">(Long startIndex, Integer pageSize)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>适用于真正的分页查询，查询参数startIndex（开始序号）和pageSize（页面大小）可由调用方指定。</p>
<h3 id="5-4-分页查询隐藏问题"><a href="#5-4-分页查询隐藏问题" class="headerlink" title="5.4.分页查询隐藏问题"></a><strong>5.4.分页查询隐藏问题</strong></h3><p>假设，我们需要在一个定时作业（每5分钟执行一次）中，针对已经超时的订单（status&#x3D;5，创建时间超时30天）进行超时关闭（status&#x3D;10）。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 订单DAO接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDAO</span> &#123;</span><br><span class="line">    <span class="comment">/** 查询过期订单函数 */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_order where status = 5 and gmt_create &lt; date_sub(current_timestamp, interval 30 day) limit #&#123;startIndex&#125;, #&#123;pageSize&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderDO&gt; <span class="title function_">queryTimeout</span><span class="params">(<span class="meta">@Param(&quot;startIndex&quot;)</span> Long startIndex, <span class="meta">@Param(&quot;pageSize&quot;)</span> Integer pageSize)</span>;</span><br><span class="line">    <span class="comment">/** 设置订单超时关闭 */</span></span><br><span class="line">    <span class="meta">@Update(&quot;update t_order set status = 10 where id = #&#123;orderId&#125; and status = 5&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">setTimeoutClosed</span><span class="params">(<span class="meta">@Param(&quot;orderId&quot;)</span> Long orderId)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 关闭过期订单作业类 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseTimeoutOrderJob</span> <span class="keyword">extends</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="comment">/** 分页数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_COUNT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/** 分页大小 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/** 作业执行函数 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; PAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="comment">// 查询处理订单</span></span><br><span class="line">            List&lt;OrderDO&gt; orderList = orderDAO.queryTimeout(i * PAGE_COUNT, PAGE_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (OrderDO order : orderList) &#123;</span><br><span class="line">                <span class="comment">// 进行超时关闭</span></span><br><span class="line">                ......</span><br><span class="line">                orderDAO.setTimeoutClosed(order.getId());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查处理完毕</span></span><br><span class="line">            <span class="keyword">if</span>(orderList.size() &lt; PAGE_SIZE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>粗看这段代码是没有问题的，尝试循环100次，每次取1000条过期订单，进行订单超时关闭操作，直到没有订单或达到100次为止。但是，如果结合订单状态一起看，就会发现从第二次查询开始，每次会忽略掉前startIndex（开始序号）条应该处理的过期订单。这就是分页查询存在的隐藏问题：</p>
<p>当满足查询条件的数据，在操作中不再满足查询条件时，会导致后续分页查询中前startIndex（开始序号）条满足条件的数据被跳过。</p>
<p>可以采用”设置最大数量”的方式解决，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** 订单DAO接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDAO</span> &#123;</span><br><span class="line">    <span class="comment">/** 查询过期订单函数 */</span></span><br><span class="line">    <span class="meta">@Select(&quot;select * from t_order where status = 5 and gmt_create &lt; date_sub(current_timestamp, interval 30 day) limit 0, #&#123;maxCount&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;OrderDO&gt; <span class="title function_">queryTimeout</span><span class="params">(<span class="meta">@Param(&quot;maxCount&quot;)</span> Integer maxCount)</span>;</span><br><span class="line">    <span class="comment">/** 设置订单超时关闭 */</span></span><br><span class="line">    <span class="meta">@Update(&quot;update t_order set status = 10 where id = #&#123;orderId&#125; and status = 5&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Long <span class="title function_">setTimeoutClosed</span><span class="params">(<span class="meta">@Param(&quot;orderId&quot;)</span> Long orderId)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 关闭过期订单作业(定时作业) */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseTimeoutOrderJob</span> <span class="keyword">extends</span> <span class="title class_">Job</span> &#123;</span><br><span class="line">    <span class="comment">/** 分页数量 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_COUNT</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">    <span class="comment">/** 分页大小 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PAGE_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/** 作业执行函数 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; PAGE_COUNT; i++) &#123;</span><br><span class="line">            <span class="comment">// 查询处理订单</span></span><br><span class="line">            List&lt;OrderDO&gt; orderList = orderDAO.queryTimeout(PAGE_SIZE);</span><br><span class="line">            <span class="keyword">if</span> (OrderDO order : orderList) &#123;</span><br><span class="line">                <span class="comment">// 进行超时关闭</span></span><br><span class="line">                ......</span><br><span class="line">                orderDAO.setTimeoutClosed(order.getId());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查处理完毕</span></span><br><span class="line">            <span class="keyword">if</span>(orderList.size() &lt; PAGE_SIZE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
      <div id="reword-out">
        <div id="reward-btn">
          打赏
        </div>
      </div>
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>版权声明： </strong>
          
          本博客所有文章除特别声明外，著作权归作者所有。转载请注明出处！
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://gaohanghang.cn/2019/09/17/%E9%82%A3%E4%BA%9B%E5%B9%B4%EF%BC%8C%E6%88%91%E4%BB%AC%E8%A7%81%E8%BF%87%E7%9A%84Java%E6%9C%8D%E5%8A%A1%E7%AB%AF%E2%80%9C%E9%97%AE%E9%A2%98%E2%80%9D/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/" rel="tag">java</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2019/09/18/Github-docsify%E6%89%93%E9%80%A0%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Github+docsify打造个人文档
          
        </div>
      </a>
    
    
      <a href="/2019/09/17/Java-%E4%B8%AD%E7%9A%84-T%EF%BC%8CE%EF%BC%8CK%EF%BC%8CV-%E5%88%AB%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E6%A5%9A%EF%BC%81/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Java 中的 T，E，K，V, 别傻傻分不清楚！</div>
      </a>
    
  </nav>

  
   
    
    <script src="https://cdn.staticfile.org/twikoo/1.4.18/twikoo.all.min.js"></script>
    <div id="twikoo" class="twikoo"></div>
    <script>
        twikoo.init({
            envId: ""
        })
    </script>
 
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> 高行行
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="高行行的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://gaohanghang.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/twitter">Twitter</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://weibo.com/u/5125203090">微博</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>