<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="个人公众号《骇客与画家》" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 高行行的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">高行行的个人博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '科技需要人文的浇灌', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Spring-Boot：参数传递"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/07/Spring-Boot%EF%BC%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/"
    >Spring Boot：传递参数</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/07/Spring-Boot%EF%BC%9A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/" class="article-date">
  <time datetime="2019-12-07T06:02:30.000Z" itemprop="datePublished">2019-12-07</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://dzone.com/articles/spring-boot-passing-parameters">https://dzone.com/articles/spring-boot-passing-parameters</a></p>
<p>译者：高行行</p>
<p>Spring Boot 通过 Java 注解使传递参数变得容易。</p>
</blockquote>
<p><img src="https://dzone.com/storage/temp/12743582-pic-someone-kicking-a-soccer-ball.jpeg" alt="Person kicking soccer ball"></p>
<p>请求 URL 时传递参数是 Spring Boot 的最基本功能之一。本文介绍了在请求中传递参数的方法。有两种方法可以传递参数。传递参数的常用方法是在 URL 调用中显式指定参数。格式如下：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.youtube.com/watch?v=tuNhqqxgxXQ&amp;t=153s</span><br></pre></td></tr></table></figure>

<p>在上面的 URL 中，有两个参数 v 和 t。要传递参数，请输入”?”。然后，添加参数名称，后跟”&#x3D;”和参数值。它看起来像这样”?v&#x3D;value”。要传递另一个参数，请使用”&amp;”，后跟第二个参数名。</p>
<p>传递参数的第二种方法是 <em>path variable</em>。例如：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.twitter.com/hashimati</span><br></pre></td></tr></table></figure>

<p>此 URL 中的单词”hashimati”是一个变量。</p>
<p>Spring Boot 通过 Java 注解使传递参数变得容易。让我们看看它在 Spring Boot 中是如何工作的。</p>
<h3 id="创建一个项目"><a href="#创建一个项目" class="headerlink" title="创建一个项目"></a>创建一个项目</h3><p>使用<a target="_blank" rel="noopener" href="https://start.spring.io/" title="Spring Initializer">Spring Initializer</a>生成 Gradle 或 Maven 项目。你唯一需要的依赖是 <strong>Web。</strong></p>
<h3 id="路径变量"><a href="#路径变量" class="headerlink" title="路径变量"></a><strong>路径变量</strong></h3><p>在路径变量中，我们在 Web 服务的路径内传递参数。下面的代码段演示了采用路径变量编写 Web 服务的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello0/&#123;name&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello0</span><span class="params">(<span class="meta">@PathVariable(&quot;name&quot;)</span> String name)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该 <code>name</code> 变量嵌入在服务路径中的大括号之间。 </li>
<li><code>name</code> 参数用<code>@PathVariable</code>注释。我们在 <code>@PathVariable</code> 中传递了<code>name</code>来表明方法签名中的<code>name</code>参数存储了<code>&#123;name&#125;</code>值。</li>
</ul>
<h4 id="Request-Parameter"><a href="#Request-Parameter" class="headerlink" title="Request Parameter"></a><strong>Request Parameter</strong></h4><p>在 Spring Boot 中，有两种方法可以在 URL 请求中传递参数：</p>
<ol>
<li><strong>使用 <code>@RequestParam</code>：</strong></li>
</ol>
<p><code>@RequestParam</code> 可用于注解方法签名中的参数。如以下代码片段所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello1</span><span class="params">(<span class="meta">@RequestParam(name=&quot;name&quot;, required = false, defaultValue = &quot;Ahmed&quot;)</span> String name)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@RequestParam</code> 具有以下参数：</p>
<ul>
<li><code>name</code>：请求参数的名称</li>
<li><code>defaultValue</code>：如果未在请求中传递参数，则为默认值。</li>
<li><code>required</code>：如果为 true，则该参数为必填。否则，不是。</li>
</ul>
<ol start="2">
<li><strong>将参数封装在对象中</strong></li>
</ol>
<p>使用对象是一种封装参数的好方法。让我们看一下下面的代码片段。首先，我们将创建一个名称为 <code>Params</code> 的类 ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Params</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String a, b;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">(String a)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">(String b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Params</code> 类中应实现 getter 和 setter 方法 。然后，我们将 <code>Params</code> 在 Web 服务的方法签名中使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/hello2&quot;)</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">hello2</span><span class="params">(Parms parameters)</span>&#123;</span><br><span class="line">    <span class="comment">//implement the setter and getter of the Params class.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Hello &quot;</span> + parameters.a + <span class="string">&quot; &quot;</span> + parameters.b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，该 Web 服务获取到两个参数，分别是<code>a</code> 和<code>b</code>。</p>
<h3 id="进一步阅读"><a href="#进一步阅读" class="headerlink" title="进一步阅读"></a>进一步阅读</h3><p><a target="_blank" rel="noopener" href="https://dzone.com/articles/using-the-spring-requestmapping-annotation" title="使用Spring @RequestMapping注释">使用 Spring @RequestMapping 注释</a></p>
<p><a target="_blank" rel="noopener" href="https://dzone.com/articles/working-with-filters-in-spring" title="在Spring中使用过滤器">在 Spring 中使用过滤器</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-思考-14-小结的作用"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/06/%E6%80%9D%E8%80%83-14-%E5%B0%8F%E7%BB%93%E7%9A%84%E4%BD%9C%E7%94%A8/"
    >思考 14 小结的作用</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/06/%E6%80%9D%E8%80%83-14-%E5%B0%8F%E7%BB%93%E7%9A%84%E4%BD%9C%E7%94%A8/" class="article-date">
  <time datetime="2019-12-05T16:37:18.000Z" itemprop="datePublished">2019-12-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <ul>
<li>构建知识的脉络</li>
<li>留下一些东西，再次切入时方便</li>
<li>成就感</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%80%9D%E8%80%83/" rel="tag">思考</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何在CentOS-7上安装Jenkins"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/05/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS-7%E4%B8%8A%E5%AE%89%E8%A3%85Jenkins/"
    >如何在CentOS 7上安装Jenkins</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/05/%E5%A6%82%E4%BD%95%E5%9C%A8CentOS-7%E4%B8%8A%E5%AE%89%E8%A3%85Jenkins/" class="article-date">
  <time datetime="2019-12-05T12:24:35.000Z" itemprop="datePublished">2019-12-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/576791/1575547881839-05eeeffb-2a77-4c1e-a064-b104340a19bf.jpeg#align=left&display=inline&height=318&originHeight=318&originWidth=600&size=0&status=done&style=none&width=600"></p>
<blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://linuxize.com/post/how-to-install-jenkins-on-centos-7/">https://linuxize.com/post/how-to-install-jenkins-on-centos-7/</a></p>
<p>翻译：高行行</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://jenkins.io/" title="Jenkins">Jenkins</a>是一个基于 Java 的开源自动化服务器，它提供了一种简单的方法来建立持续集成和持续交付（CI &#x2F; CD）管道。</p>
<p>持续集成（CI）是 DevOps 的一种实践，团队成员定期将其代码更改提交到版本控制存储库，然后运行自动构建和测试。持续交付（CD）是一系列实践，其中代码更改会自动生成，测试并部署到生产中。</p>
<p>本教程将引导你完成使用官方 Jenkins 存储库在 CentOS 7 系统上安装 Jenkins 的步骤。</p>
<h2 id="1-先决条件"><a href="#1-先决条件" class="headerlink" title="1. 先决条件"></a>1. 先决条件</h2><p>在继续本教程之前，请确保你以<a target="_blank" rel="noopener" href="https://linuxize.com/post/create-a-sudo-user-on-centos/" title="具有sudo特权">具有 sudo 特权</a>的用户身份登录。</p>
<h2 id="2-安装-Jenkins"><a href="#2-安装-Jenkins" class="headerlink" title="2. 安装 Jenkins"></a>2. 安装 Jenkins</h2><p>要在你的 CentOS 系统上安装 Jenkins，请执行以下步骤：</p>
<ol>
<li><p>Jenkins 是 Java 应用程序，因此第一步是安装 Java。运行以下命令以安装 OpenJDK 8 软件包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install java-1.8.0-openjdk-devel</span><br></pre></td></tr></table></figure>

<p>当前版本的 Jenkins 尚不支持 Java 10（和 Java 11）。如果你的计算机上安装了多个 Java 版本，请<a target="_blank" rel="noopener" href="https://linuxize.com/post/install-java-on-centos-7/#set-the-default-version" title="确保Java 8是默认Java版本">确保 Java 8 是默认 Java 版本</a>。</p>
</li>
<li><p>下一步是启用 Jenkins 存储库。为此，请使用以下<a target="_blank" rel="noopener" href="https://linuxize.com/post/curl-command-examples/" title="`curl`"><code>curl</code></a>命令导入 GPG 密钥：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --silent --location http://pkg.jenkins-ci.org/redhat-stable/jenkins.repo | sudo <span class="built_in">tee</span> /etc/yum.repos.d/jenkins.repo</span><br></pre></td></tr></table></figure>

<p>并使用以下命令将存储库添加到你的系统中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key</span><br></pre></td></tr></table></figure>
</li>
<li><p>启用存储库后，通过输入以下命令安装最新的 Jenkins 稳定版本：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install jenkins</span><br></pre></td></tr></table></figure>

<p>安装过程完成后，使用以下命令启动 Jenkins 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start jenkins</span><br></pre></td></tr></table></figure>

<p>要检查它是否成功启动，请运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status jenkins</span><br></pre></td></tr></table></figure>

<p>你应该看到类似以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Output</span><br><span class="line">● jenkins.service - LSB: Jenkins Automation Server</span><br><span class="line">Loaded: loaded (/etc/rc.d/init.d/jenkins; bad; vendor preset: disabled)</span><br><span class="line">Active: active (running) since Thu 2018-09-20 14:58:21 UTC; 15s ago</span><br><span class="line">    Docs: man:systemd-sysv-generator(8)</span><br><span class="line">Process: 2367 ExecStart=/etc/rc.d/init.d/jenkins start (code=exited, status=0/SUCCESS)</span><br><span class="line">CGroup: /system.slice/jenkins.service</span><br></pre></td></tr></table></figure>

<p>最后，启用 Jenkins 服务以在系统引导时启动。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> jenkins</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Output</span><br><span class="line">jenkins.service is not a native service, redirecting to /sbin/chkconfig.</span><br><span class="line">Executing /sbin/chkconfig jenkins on</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-调整防火墙"><a href="#3-调整防火墙" class="headerlink" title="3. 调整防火墙"></a>3. 调整防火墙</h2><p>如果要在<a target="_blank" rel="noopener" href="https://linuxize.com/post/how-to-setup-a-firewall-with-firewalld-on-centos-7/" title="受防火墙保护">受防火墙保护</a>的远程 CentOS 服务器上安装 Jenkins，则需要开放<code>8080</code> 端口。</p>
<p>使用以下命令打开必要的端口：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --permanent --zone=public --add-port=8080/tcp</span><br><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2 id="4-设置-Jenkins"><a href="#4-设置-Jenkins" class="headerlink" title="4. 设置 Jenkins"></a>4. 设置 Jenkins</h2><p>要设置新的 Jenkins 安装，请打开浏览器，然后输入你的域或 IP 地址，然后输入端口 <code>8080</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://your_ip_or_domain:8080</span><br></pre></td></tr></table></figure>

<p>将会出现类似以下的屏幕，提示你输入在安装过程中创建的管理员密码：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/576791/1575547881866-1493e9b5-0f9a-496f-b8ff-2a1c33261bb9.jpeg#align=left&display=inline&height=467&originHeight=467&originWidth=600&size=0&status=done&style=none&width=600"></p>
<p>使用以下命令在终端上打印密码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cat</span> /var/lib/jenkins/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>

<p>你应该看到一个 32 个字符长的字母数字密码，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2115173b548f4e99a203ee99a8732a32</span><br></pre></td></tr></table></figure>

<p>从终端复制密码，将其粘贴到“管理员密码”字段中，然后单击<code>Continue</code>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/576791/1575547881890-b36a3d19-95a9-4fcb-8297-0539a79aec4e.jpeg#align=left&display=inline&height=467&originHeight=467&originWidth=600&size=0&status=done&style=none&width=600"></p>
<p>在下一个屏幕上，系统将询问你是否要安装建议的插件或选择特定的插件。单击该<code>Install suggested plugins</code>框，安装过程将立即开始。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/576791/1575547881886-6b12101b-769c-49c6-92ee-36f54a8655ff.jpeg#align=left&display=inline&height=467&originHeight=467&originWidth=600&size=0&status=done&style=none&width=600"></p>
<p>安装完成后，将提示你设置第一个管理用户。填写所有必需的信息，然后单击确定<code>Save and Continue</code>。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/576791/1575547883429-7eaba1f7-7531-495d-8180-6f5454112cde.jpeg#align=left&display=inline&height=467&originHeight=467&originWidth=600&size=0&status=done&style=none&width=600"></p>
<p>在下一页上，将要求你设置 Jenkins 实例的 URL。URL 字段将填充自动生成的 URL。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/576791/1575547882383-179157b2-c647-44df-b533-d5de7f34ccf2.jpeg#align=left&display=inline&height=467&originHeight=467&originWidth=600&size=0&status=done&style=none&width=600"></p>
<p>要完成设置，请单击<code>Save and Finish</code>按钮确认 URL 。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/576791/1575547882237-fc767c98-8e3a-4365-9ac2-c2d71318a72d.jpeg#align=left&display=inline&height=467&originHeight=467&originWidth=600&size=0&status=done&style=none&width=600"></p>
<p>最后，单击<code>Start using Jenkins</code>按钮，你将被重定向到你在上个步骤创建的管理员用户身份登录的 Jenkins 仪表板。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/jpeg/576791/1575547884645-91fc6d5e-6f2c-41b8-920b-d78f0b76db14.jpeg#align=left&display=inline&height=352&originHeight=352&originWidth=600&size=0&status=done&style=none&width=600"></p>
<p>如果你到了这一步，则说明你已经在 CentOS 系统上成功安装了 Jenkins。</p>
<h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h2><p>在本教程中，你学习了如何在基于 CentOS &#x2F; RHEL 的系统上安装并完成 Jenkins 的初始配置。现在，你可以访问<a target="_blank" rel="noopener" href="https://jenkins.io/doc/" title="Jenkins">Jenkins</a>官方<a target="_blank" rel="noopener" href="https://jenkins.io/doc/" title="文档">文档</a>页面，并开始探索 Jenkins 的工作流程和插件模块。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-java-并发"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/04/java-%E5%B9%B6%E5%8F%91/"
    >java 并发</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/04/java-%E5%B9%B6%E5%8F%91/" class="article-date">
  <time datetime="2019-12-04T12:29:43.000Z" itemprop="datePublished">2019-12-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原作者：CyC2018</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Java">https://github.com/CyC2018/CS-Notes/blob/master/notes/Java</a> 并发.md</p>
<p>小结：</p>
<p>一、线程状态转换：6种状态</p>
<ol>
<li>新建（new）：Thread t &#x3D; new Thread(r) 时</li>
<li>可运行（Runnable）：t.start()，一旦调用 start 方法 。 线程处于 runnable 状态。 一个可运行的线程可能正在运行也可能没有运行 。</li>
<li>阻塞（Blocked）：等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</li>
<li>无限期等待（Waiting）：等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</li>
<li>限期等待（Timed Waiting）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</li>
<li>死亡（Terminated）：线程因如下两个原因之一而被终止，因为 run 方法正常退出而自然死亡，因为一个没有捕获的异常终止了 run 方法而意外死亡 。</li>
</ol>
<p>二、使用线程</p>
<ul>
<li>实现 Runnable 接口：实现 Runnable 接口，重写 run() 方法，通过 Thread 调用 start() 方法来启动线程。</li>
<li>实现 Callable 接口：与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</li>
<li>继承 Thread 类：继承 Thread 类，重写 run() 方法，调用 start() 方法。</li>
<li>实现接口 VS 继承 Thread：实现接口会更好一些</li>
</ul>
<p>三、基础线程机制</p>
<ol>
<li>Executor：Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
</li>
<li>Daemon：守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</li>
<li>sleep()：Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</li>
<li>yield()：对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</li>
</ol>
<p>四、中断</p>
<ul>
<li>InterruptedException：通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</li>
<li>interrupted()：使用 interrupted() 方法来判断线程是否处于中断状态。</li>
<li>Executor 的中断操作：调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</li>
</ul>
<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<p>五、互斥同步：Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<ul>
<li><p>synchronized：</p>
<ul>
<li>同步一个代码块：它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</li>
</ul>
</li>
<li><p>同步一个方法：它和同步代码块一样，作用于同一个对象。</p>
<ul>
<li>同步一个类：作用于整个类，也就是说两个线程调用同一个类的不同对象上的这种同步语句，也会进行同步。</li>
<li>同步一个静态方法：作用于整个类。</li>
</ul>
</li>
<li><p>ReentrantLock：ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。</p>
</li>
<li><p>比较：</p>
<ul>
<li>锁的实现：synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。</li>
</ul>
</li>
<li><p>性能：新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。</p>
</li>
<li><p>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。</p>
</li>
<li><p>公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。</p>
</li>
<li><p>锁绑定多个条件：一个 ReentrantLock 可以同时绑定多个 Condition 对象。</p>
<ul>
<li>使用选择：除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。</li>
</ul>
</li>
</ul>
<p>六、线程之间的协作</p>
<ul>
<li><p>join()：在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p>
</li>
<li><p>wait() notify() notifyAll()：调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。wait() 会释放锁。</p>
</li>
<li><p>await() signal() signalAll()：java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p>
</li>
</ul>
<p>相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。</p>
<p>七、J.U.C - AQS</p>
<ul>
<li>CountDownLatch：用来控制一个或者多个线程等待多个线程。维护了一个计数器 cnt，每次调用 countDown() 方法会让计数器的值减 1，减到 0 的时候，那些因为调用 await() 方法而在等待的线程就会被唤醒。</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
</ul>
<p>八、J.U.C - 其它组件</p>
<ul>
<li>FutureTask：FutureTask 实现了 RunnableFuture 接口，该接口继承自 Runnable 和 Future 接口，这使得 FutureTask 既可以当做一个任务执行，也可以有返回值。</li>
<li>BlockingQueue：阻塞队列，使用 BlockingQueue 可以实现生产者消费者问题</li>
<li>ForkJoin：主要用于并行计算中，和 MapReduce 原理类似，都是把大的计算任务拆分成多个小任务并行计算。</li>
</ul>
<p>九、线程不安全示例</p>
<p>十、Java 内存模型</p>
<ul>
<li>主内存与工作内存</li>
<li>内存间交互操作<ul>
<li>read：把一个变量的值从主内存传输到工作内存中</li>
<li>load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中<ul>
<li>use：把工作内存中一个变量的值传递给执行引擎</li>
</ul>
</li>
<li>assign：把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store：把工作内存的一个变量的值传送到主内存中</li>
<li>write：在 store 之后执行，把 store 得到的值放入主内存的变量中</li>
<li>lock：作用于主内存的变量</li>
<li>unlock</li>
</ul>
</li>
<li>内存模型三大特性<ul>
<li>原子性：Java 内存模型保证了 read、load、use、assign、store、write、lock 和 unlock 操作具有原子性</li>
<li>可见性：可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。主要有三种实现可见性的方式：<ul>
<li>volatile</li>
<li>synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。</li>
<li>final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。</li>
</ul>
</li>
<li>有序性：有序性是指在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</li>
</ul>
</li>
<li>先行发生原则：上面提到了可以用 volatile 和 synchronized 来保证有序性。除此之外，JVM 还规定了先行发生原则，让一个操作无需控制就能先于另一个操作完成。<ul>
<li>单一线程原则</li>
<li>管程锁定原则</li>
<li>volatile 变量规则</li>
<li>线程启动规则</li>
<li>线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。</li>
<li>线程中断规则</li>
<li>对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</li>
<li>传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</li>
</ul>
</li>
</ul>
<p>十一、线程安全：多个线程不管以何种方式访问某个类，并且在主调代码中不需要进行同步，都能表现正确的行为。线程安全有以下几种实现方式：</p>
<ul>
<li>不可变：不可变（Immutable）的对象一定是线程安全的，不需要再采取任何的线程安全保障措施。不可变的类型有以下这些：<ul>
<li>final 关键字修饰的基本数据类型</li>
<li>String</li>
<li>枚举类型</li>
<li>Number 部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li>
</ul>
</li>
<li>互斥同步：synchronized 和 ReentrantLock。悲观锁</li>
<li>非阻塞同步：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。<ul>
<li>CAS</li>
<li>AtomicInteger：J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。</li>
<li>ABA：如果一个变量初次读取的时候是 A 值，它的值被改成了 B，后来又被改回为 A，那 CAS 操作就会误认为它从来没有被改变过。大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</li>
</ul>
</li>
<li>无同步方案<ul>
<li>栈封闭：多个线程访问同一个方法的局部变量时，不会出现线程安全问题，因为局部变量存储在虚拟机栈中，属于线程私有的。</li>
<li>线程本地存储（Thread Local Storage）</li>
<li>可重入代码（Reentrant Code）</li>
</ul>
</li>
</ul>
<p>十二、锁优化</p>
<ul>
<li>自旋锁：获取锁时自旋一段时间，看能拿到锁不。只适用于共享数据的锁定状态很短的场景。</li>
<li>锁消除：锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。</li>
<li>锁粗化：如果虚拟机探测到一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。</li>
<li>轻量级锁</li>
<li>偏向锁</li>
</ul>
<p>十三、多线程开发良好的实践</p>
</blockquote>
<h1 id="一、线程状态转换"><a href="#一、线程状态转换" class="headerlink" title="一、线程状态转换"></a>一、线程状态转换</h1><div align="center"> <img src="https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/adfb427d-3b21-40d7-a142-757f4ed73079.png" width="600px"> </div><br>
![](https://raw.githubusercontent.com/gaohanghang/images/master/img/20191204204337.png)

<h2 id="1-1-新建（New）"><a href="#1-1-新建（New）" class="headerlink" title="1.1 新建（New）"></a>1.1 新建（New）</h2><p>创建后尚未启动。</p>
<h2 id="1-2-可运行（Runnable）"><a href="#1-2-可运行（Runnable）" class="headerlink" title="1.2 可运行（Runnable）"></a>1.2 可运行（Runnable）</h2><p>可能正在运行，也可能正在等待 CPU 时间片。</p>
<p>包含了操作系统线程状态中的 Running 和 Ready。</p>
<h2 id="1-3-阻塞（Blocked）"><a href="#1-3-阻塞（Blocked）" class="headerlink" title="1.3 阻塞（Blocked）"></a>1.3 阻塞（Blocked）</h2><p>等待获取一个排它锁，如果其线程释放了锁就会结束此状态。</p>
<h2 id="1-4-无限期等待（Waiting）"><a href="#1-4-无限期等待（Waiting）" class="headerlink" title="1.4 无限期等待（Waiting）"></a>1.4 无限期等待（Waiting）</h2><p>等待其它线程显式地唤醒，否则不会被分配 CPU 时间片。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>没有设置 Timeout 参数的 Object.wait() 方法</td>
<td>Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td>没有设置 Timeout 参数的 Thread.join() 方法</td>
<td>被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.park() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="1-5-限期等待（Timed-Waiting）"><a href="#1-5-限期等待（Timed-Waiting）" class="headerlink" title="1.5 限期等待（Timed Waiting）"></a>1.5 限期等待（Timed Waiting）</h2><p>无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p>
<p>调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。</p>
<p>调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。</p>
<p>睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。</p>
<p>阻塞和等待的区别在于，阻塞是被动的，它是在等待获取一个排它锁。而等待是主动的，通过调用 Thread.sleep() 和 Object.wait() 等方法进入。</p>
<table>
<thead>
<tr>
<th>进入方法</th>
<th>退出方法</th>
</tr>
</thead>
<tbody><tr>
<td>Thread.sleep() 方法</td>
<td>时间结束</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Object.wait() 方法</td>
<td>时间结束 &#x2F; Object.notify() &#x2F; Object.notifyAll()</td>
</tr>
<tr>
<td>设置了 Timeout 参数的 Thread.join() 方法</td>
<td>时间结束 &#x2F; 被调用的线程执行完毕</td>
</tr>
<tr>
<td>LockSupport.parkNanos() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
<tr>
<td>LockSupport.parkUntil() 方法</td>
<td>LockSupport.unpark(Thread)</td>
</tr>
</tbody></table>
<h2 id="1-5-死亡（Terminated）"><a href="#1-5-死亡（Terminated）" class="headerlink" title="1.5 死亡（Terminated）"></a>1.5 死亡（Terminated）</h2><p>可以是线程结束任务之后自己结束，或者产生了异常而结束。</p>
<h1 id="二、使用线程"><a href="#二、使用线程" class="headerlink" title="二、使用线程"></a>二、使用线程</h1><p>有三种使用线程的方法：</p>
<ul>
<li>实现 Runnable 接口；</li>
<li>实现 Callable 接口；</li>
<li>继承 Thread 类。</li>
</ul>
<p>实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过 Thread 来调用。可以说任务是通过线程驱动从而执行的。</p>
<h2 id="实现-Runnable-接口"><a href="#实现-Runnable-接口" class="headerlink" title="实现 Runnable 接口"></a>实现 Runnable 接口</h2><p>需要实现 run() 方法。</p>
<p>通过 Thread 调用 start() 方法来启动线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyRunnable</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-实现-Callable-接口"><a href="#2-2-实现-Callable-接口" class="headerlink" title="2.2 实现 Callable 接口"></a>2.2 实现 Callable 接口</h2><p>与 Runnable 相比，Callable 可以有返回值，返回值通过 FutureTask 进行封装。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    <span class="type">MyCallable</span> <span class="variable">mc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyCallable</span>();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(mc);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-继承-Thread-类"><a href="#2-3-继承-Thread-类" class="headerlink" title="2.3 继承 Thread 类"></a>2.3 继承 Thread 类</h2><p>同样也是需要实现 run() 方法，因为 Thread 类也实现了 Runable 接口。</p>
<p>当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">mt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-实现接口-VS-继承-Thread"><a href="#2-4-实现接口-VS-继承-Thread" class="headerlink" title="2.4 实现接口 VS 继承 Thread"></a>2.4 实现接口 VS 继承 Thread</h2><p>实现接口会更好一些，因为：</p>
<ul>
<li>Java 不支持多重继承，因此继承了 Thread 类就无法继承其它类，但是可以实现多个接口；</li>
<li>类可能只要求可执行就行，继承整个 Thread 类开销过大。</li>
</ul>
<h1 id="三、基础线程机制"><a href="#三、基础线程机制" class="headerlink" title="三、基础线程机制"></a>三、基础线程机制</h1><h2 id="3-1-Executor"><a href="#3-1-Executor" class="headerlink" title="3.1 Executor"></a>3.1 Executor</h2><p>Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。</p>
<p>主要有三种 Executor：</p>
<ul>
<li>CachedThreadPool：一个任务创建一个线程；</li>
<li>FixedThreadPool：所有任务只能使用固定大小的线程；</li>
<li>SingleThreadExecutor：相当于大小为 1 的 FixedThreadPool。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Daemon"><a href="#3-2-Daemon" class="headerlink" title="3.2 Daemon"></a>3.2 Daemon</h2><p>守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。</p>
<p>当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。</p>
<p>main() 属于非守护线程。</p>
<p>在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>());</span><br><span class="line">    thread.setDaemon(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-sleep"><a href="#3-3-sleep" class="headerlink" title="3.3 sleep()"></a>3.3 sleep()</h2><p>Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。</p>
<p>sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-4-yield"><a href="#3-4-yield" class="headerlink" title="3.4 yield()"></a>3.4 yield()</h2><p>对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread.<span class="keyword">yield</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、中断"><a href="#四、中断" class="headerlink" title="四、中断"></a>四、中断</h1><p>一个线程执行完毕之后会自动结束，如果在运行过程中发生异常也会提前结束。</p>
<h2 id="4-1-InterruptedException"><a href="#4-1-InterruptedException" class="headerlink" title="4.1 InterruptedException"></a>4.1 InterruptedException</h2><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I&#x2F;O 阻塞和 synchronized 锁阻塞。</p>
<p>对于以下代码，在 main() 中启动一个线程之后再中断它，由于线程中调用了 Thread.sleep() 方法，因此会抛出一个 InterruptedException，从而提前结束线程，不执行之后的语句。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread1</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread1</span>();</span><br><span class="line">    thread1.start();</span><br><span class="line">    thread1.interrupt();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at InterruptExample.lambda$main$0(InterruptExample.java:5)</span><br><span class="line">    at InterruptExample$$Lambda$1/713338599.run(Unknown Source)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<h2 id="4-2-interrupted"><a href="#4-2-interrupted" class="headerlink" title="4.2 interrupted()"></a>4.2 interrupted()</h2><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p>
<p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterruptExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread2</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread2</span>();</span><br><span class="line">    thread2.start();</span><br><span class="line">    thread2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread end</span><br></pre></td></tr></table></figure>

<h2 id="4-3-Executor-的中断操作"><a href="#4-3-Executor-的中断操作" class="headerlink" title="4.3 Executor 的中断操作"></a>4.3 Executor 的中断操作</h2><p>调用 Executor 的 shutdown() 方法会等待线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。</p>
<p>以下使用 Lambda 创建线程，相当于创建了一个匿名内部线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">    executorService.execute(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread run&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    executorService.shutdownNow();</span><br><span class="line">    System.out.println(<span class="string">&quot;Main run&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Main run</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">    at java.lang.Thread.sleep(Native Method)</span><br><span class="line">    at ExecutorInterruptExample.lambda$main$0(ExecutorInterruptExample.java:9)</span><br><span class="line">    at ExecutorInterruptExample$$Lambda$1/1160460865.run(Unknown Source)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)</span><br><span class="line">    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>

<p>如果只想中断 Executor 中的一个线程，可以通过使用 submit() 方法来提交一个线程，它会返回一个 Future&lt;?&gt; 对象，通过调用该对象的 cancel(true) 方法就可以中断线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;?&gt; future = executorService.submit(() -&gt; &#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">future.cancel(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<h1 id="五、互斥同步"><a href="#五、互斥同步" class="headerlink" title="五、互斥同步"></a>五、互斥同步</h1><p>Java 提供了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized，而另一个是 JDK 实现的 ReentrantLock。</p>
<h2 id="5-1-synchronized"><a href="#5-1-synchronized" class="headerlink" title="5.1 synchronized"></a>5.1 synchronized</h2><p><strong>1. 同步一个代码块</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。</p>
<p>对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。</p> 
      <a class="article-more-link" href="/2019/12/04/java-%E5%B9%B6%E5%8F%91/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%BD%AC%E8%BD%BD/" rel="tag">转载</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-微服务中如何使用RestTemplate优雅调用API"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8RestTemplate%E4%BC%98%E9%9B%85%E8%B0%83%E7%94%A8API/"
    >微服务中如何使用RestTemplate优雅调用API（拦截器、异常处理、消息转换）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8RestTemplate%E4%BC%98%E9%9B%85%E8%B0%83%E7%94%A8API/" class="article-date">
  <time datetime="2019-12-02T06:11:17.000Z" itemprop="datePublished">2019-12-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/DoW_wlVu3_aWx-bTnSuOWg">https://mp.weixin.qq.com/s/DoW_wlVu3_aWx-bTnSuOWg</a></p>
<p>小结：</p>
<ol>
<li><p>自定义 interceptor 拦截器：可以用于记录 resttemplate 请求和响应的信息，以及统一 head 的设置。</p>
</li>
<li><p>自定义异常处理：添加自定义错误处理的最简单策略是将调用包装在 try&#x2F;catch 代码块中。然后，我们根据需要处理捕获的异常。但是，随着远程 API 或调用数量的增加，这种简单的策略无法很好地扩展。通过自定义异常处理可以为所有远程调用实现可重用的错误处理程序，效率会更高。– <a target="_blank" rel="noopener" href="https://www.baeldung.com/spring-rest-template-error-handling">https://www.baeldung.com/spring-rest-template-error-handling</a></p>
</li>
<li><p>自定义 message 转化器</p>
</li>
</ol>
</blockquote>
<p>在微服务中，rest 服务互相调用是很普遍的，我们该如何优雅地调用? 其实在 Spring 框架使用 RestTemplate 类可以优雅地进行 rest 服务互相调用，它简化了与 http 服务的通信方式，统一了 RESTful 的标准，封装了 http 连接，操作使用简便，还可以自定义 RestTemplate 所需的模式。其中：</p>
<ul>
<li><strong>RestTemplate 默认使用<code>HttpMessageConverter</code>实例将 HTTP 消息转换成 POJO 或者从 POJO 转换成 HTTP 消息。默认情况下会注册主 mime 类型的转换器，但也可以通过 setMessageConverters 注册自定义转换器。</strong></li>
<li><strong>RestTemplate 使用了默认的 <code>DefaultResponseErrorHandler</code>，对 40X Bad Request 或 50X internal 异常 error 等错误信息捕捉。</strong></li>
<li><strong>RestTemplate 还可以使用拦截器 interceptor，进行对请求链接跟踪，以及统一 head 的设置。</strong></li>
</ul>
<p>其中，RestTemplate 还定义了很多的 REST 资源交互的方法，其中的大多数都对应于 HTTP 的方法，如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>解析</th>
</tr>
</thead>
<tbody><tr>
<td>delete()</td>
<td>在特定的 URL 上对资源执行 HTTP DELETE 操作</td>
</tr>
<tr>
<td>exchange()</td>
<td>在 URL 上执行特定的 HTTP 方法，返回包含对象的 ResponseEntity</td>
</tr>
<tr>
<td>execute()</td>
<td>在 URL 上执行特定的 HTTP 方法，返回一个从响应体映射得到的对象</td>
</tr>
<tr>
<td>getForEntity()</td>
<td>发送一个 HTTP GET 请求，返回的 ResponseEntity 包含了响应体所映射成的对象</td>
</tr>
<tr>
<td>getForObject()</td>
<td>发送一个 HTTP GET 请求，返回的请求体将映射为一个对象</td>
</tr>
<tr>
<td>postForEntity()</td>
<td>POST 数据到一个 URL，返回包含一个对象的 ResponseEntity</td>
</tr>
<tr>
<td>postForObject()</td>
<td>POST 数据到一个 URL，返回根据响应体匹配形成的对象</td>
</tr>
<tr>
<td>headForHeaders()</td>
<td>发送 HTTP HEAD 请求，返回包含特定资源 URL 的 HTTP 头</td>
</tr>
<tr>
<td>optionsForAllow()</td>
<td>发送 HTTP OPTIONS 请求，返回对特定 URL 的 Allow 头信息</td>
</tr>
<tr>
<td>postForLocation()</td>
<td>POST 数据到一个 URL，返回新创建资源的 URL</td>
</tr>
<tr>
<td>put()</td>
<td>PUT 资源到特定的 URL</td>
</tr>
</tbody></table>
<h2 id="1-springboot-集成-RestTemplate"><a href="#1-springboot-集成-RestTemplate" class="headerlink" title="1. springboot 集成 RestTemplate"></a>1. springboot 集成 RestTemplate</h2><p>在项目中可以通过增加自定义的异常处理、<code>MessageConverter</code>以及拦截器<code>interceptor</code>对 RestTemplate 进行优雅地使用，详情请查看接下来的内容。</p>
<h3 id="1-1-导入依赖：（RestTemplate-集成在-Web-Start-中）"><a href="#1-1-导入依赖：（RestTemplate-集成在-Web-Start-中）" class="headerlink" title="1.1 导入依赖：（RestTemplate 集成在 Web Start 中）"></a>1.1 导入依赖：（RestTemplate 集成在 Web Start 中）</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-RestTemplat-配置："><a href="#1-2-RestTemplat-配置：" class="headerlink" title="1.2 RestTemplat 配置："></a>1.2 RestTemplat 配置：</h3><ul>
<li><strong>使用<code>ClientHttpRequestFactory</code>属性配置 RestTemplat 参数，比如 ConnectTimeout，ReadTimeout;</strong></li>
<li><strong>增加自定义的<code>interceptor</code>拦截器和异常处理;</strong></li>
<li><strong>追加<code>message</code>转换器;</strong></li>
<li><strong>配置自定义的异常处理.</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestTemplateConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;resttemplate.connection.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> restTemplateConnectionTimeout;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;resttemplate.read.timeout&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> restTemplateReadTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//@LoadBalanced</span></span><br><span class="line">    <span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">( ClientHttpRequestFactory simleClientHttpRequestFactory)</span> &#123;</span><br><span class="line">        <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">        <span class="comment">//配置自定义的message转换器</span></span><br><span class="line">        List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters();</span><br><span class="line">        messageConverters.add(<span class="keyword">new</span> <span class="title class_">CustomMappingJackson2HttpMessageConverter</span>());</span><br><span class="line">        restTemplate.setMessageConverters(messageConverters);</span><br><span class="line">        <span class="comment">//配置自定义的interceptor拦截器</span></span><br><span class="line">        List&lt;ClientHttpRequestInterceptor&gt; interceptors=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;ClientHttpRequestInterceptor&gt;();</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">HeadClientHttpRequestInterceptor</span>());</span><br><span class="line">        interceptors.add(<span class="keyword">new</span> <span class="title class_">TrackLogClientHttpRequestInterceptor</span>());</span><br><span class="line">        restTemplate.setInterceptors(interceptors);</span><br><span class="line">        <span class="comment">//配置自定义的异常处理</span></span><br><span class="line">        restTemplate.setErrorHandler(<span class="keyword">new</span> <span class="title class_">CustomResponseErrorHandler</span>());</span><br><span class="line">        restTemplate.setRequestFactory(simleClientHttpRequestFactory);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> restTemplate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> ClientHttpRequestFactory <span class="title function_">simleClientHttpRequestFactory</span><span class="params">()</span>&#123;</span><br><span class="line">        SimpleClientHttpRequestFactory reqFactory= <span class="keyword">new</span> <span class="title class_">SimpleClientHttpRequestFactory</span>();</span><br><span class="line">        reqFactory.setConnectTimeout(restTemplateConnectionTimeout);</span><br><span class="line">        reqFactory.setReadTimeout(restTemplateReadTimeout);</span><br><span class="line">        <span class="keyword">return</span> reqFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-组件-自定义异常处理、interceptor-拦截器、message-转化器"><a href="#1-3-组件-自定义异常处理、interceptor-拦截器、message-转化器" class="headerlink" title="1.3 组件(自定义异常处理、interceptor 拦截器、message 转化器)"></a>1.3 组件(自定义异常处理、interceptor 拦截器、message 转化器)</h3><p><strong>自定义<code>interceptor</code>拦截器，实现<code>ClientHttpRequestInterceptor</code>接口</strong></p>
<ul>
<li><strong>自定义<code>TrackLogClientHttpRequestInterceptor</code>，记录<code>resttemplate</code>的<code>request</code>和<code>response</code>信息，可进行追踪分析；</strong></li>
<li><strong>自定义<code>HeadClientHttpRequestInterceptor</code>，设置请求头的参数。API 发送各种请求，很多请求都需要用到相似或者相同的 Http Header。如果在每次请求之前都把<code>Header</code>填入<code>HttpEntity/RequestEntity</code>，这样的代码会显得十分冗余，可以在拦截器统一设置。</strong></li>
</ul>
<h4 id="1-3-1-自定义-interceptor-拦截器"><a href="#1-3-1-自定义-interceptor-拦截器" class="headerlink" title="1.3.1 自定义 interceptor 拦截器"></a>1.3.1 自定义 interceptor 拦截器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: ccww</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/10/25 22:48，记录resttemplate访问信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:   记录resttemplate访问信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrackLogClientHttpRequestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body, ClientHttpRequestExecution execution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        trackRequest(request,body);</span><br><span class="line">        <span class="type">ClientHttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> execution.execute(request, body);</span><br><span class="line">        trackResponse(httpResponse);</span><br><span class="line">        <span class="keyword">return</span> httpResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">trackResponse</span><span class="params">(ClientHttpResponse httpResponse)</span><span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;============================response begin==========================================&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;Status code  : &#123;&#125;&quot;</span>, httpResponse.getStatusCode());</span><br><span class="line">        log.info(<span class="string">&quot;Status text  : &#123;&#125;&quot;</span>, httpResponse.getStatusText());</span><br><span class="line">        log.info(<span class="string">&quot;Headers      : &#123;&#125;&quot;</span>, httpResponse.getHeaders());</span><br><span class="line">        log.info(<span class="string">&quot;=======================response end=================================================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">trackRequest</span><span class="params">(HttpRequest request, <span class="type">byte</span>[] body)</span><span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">        log.info(<span class="string">&quot;======= request begin ========&quot;</span>);</span><br><span class="line">        log.info(<span class="string">&quot;uri : &#123;&#125;&quot;</span>, request.getURI());</span><br><span class="line">        log.info(<span class="string">&quot;method : &#123;&#125;&quot;</span>, request.getMethod());</span><br><span class="line">        log.info(<span class="string">&quot;headers : &#123;&#125;&quot;</span>, request.getHeaders());</span><br><span class="line">        log.info(<span class="string">&quot;request body : &#123;&#125;&quot;</span>, <span class="keyword">new</span> <span class="title class_">String</span>(body, <span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">        log.info(<span class="string">&quot;======= request end ========&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>HeadClientHttpRequestInterceptor：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeadClientHttpRequestInterceptor</span> <span class="keyword">implements</span> <span class="title class_">ClientHttpRequestInterceptor</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ClientHttpResponse <span class="title function_">intercept</span><span class="params">(HttpRequest httpRequest, <span class="type">byte</span>[] bytes, ClientHttpRequestExecution clientHttpRequestExecution)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">       log.info(<span class="string">&quot;#####head handle########&quot;</span>);</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> httpRequest.getHeaders();</span><br><span class="line">        headers.add(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        headers.add(<span class="string">&quot;Accept-Encoding&quot;</span>, <span class="string">&quot;gzip&quot;</span>);</span><br><span class="line">        headers.add(<span class="string">&quot;Content-Encoding&quot;</span>, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        headers.add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json; charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="type">ClientHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> clientHttpRequestExecution.execute(httpRequest, bytes);</span><br><span class="line">        <span class="type">HttpHeaders</span> <span class="variable">headersResponse</span> <span class="operator">=</span> response.getHeaders();</span><br><span class="line">        headersResponse.add(<span class="string">&quot;Accept&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-2-自定义异常处理"><a href="#1-3-2-自定义异常处理" class="headerlink" title="1.3.2 自定义异常处理"></a>1.3.2 自定义异常处理</h4><p><strong>自定义异常处理，可继承<code>DefaultResponseErrorHandler</code>或者实现<code>ResponseErrorHandler</code>接口：</strong></p>
<ul>
<li><strong>实现自定义<code>ErrorHandler</code>的思路是根据响应消息体进行相应的异常处理策略，对于其他异常情况由父类<code>DefaultResponseErrorHandler</code>来进行处理。</strong></li>
<li><strong>自定义<code>CustomResponseErrorHandler</code>进行 30x 异常处理</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Ccww</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/10/28 17:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:  30X的异常处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomResponseErrorHandler</span> <span class="keyword">extends</span> <span class="title class_">DefaultResponseErrorHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasError</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> response.getStatusCode();</span><br><span class="line">        <span class="keyword">if</span>(statusCode.is3xxRedirection())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.hasError(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleError</span><span class="params">(ClientHttpResponse response)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">HttpStatus</span> <span class="variable">statusCode</span> <span class="operator">=</span> response.getStatusCode();</span><br><span class="line">        <span class="keyword">if</span>(statusCode.is3xxRedirection())&#123;</span><br><span class="line">            log.info(<span class="string">&quot;########30X错误，需要重定向！##########&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">super</span>.handleError(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="1-3-3-自定义-message-转化器"><a href="#1-3-3-自定义-message-转化器" class="headerlink" title="1.3.3 自定义 message 转化器"></a>1.3.3 自定义 message 转化器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span>: Ccww</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/10/29 21:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 将Content-Type:&quot;text/html&quot;转换为Map类型格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomMappingJackson2HttpMessageConverter</span> <span class="keyword">extends</span> <span class="title class_">MappingJackson2HttpMessageConverter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CustomMappingJackson2HttpMessageConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;MediaType&gt; mediaTypes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MediaType&gt;();</span><br><span class="line">        mediaTypes.add(MediaType.TEXT_PLAIN);</span><br><span class="line">        mediaTypes.add(MediaType.TEXT_HTML);  <span class="comment">//加入text/html类型的支持</span></span><br><span class="line">        setSupportedMediaTypes(mediaTypes);<span class="comment">// tag6</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-RestTemplate-源码解析"><a href="#2-RestTemplate-源码解析" class="headerlink" title="2. RestTemplate 源码解析"></a>2. RestTemplate 源码解析</h2><h3 id="2-1-默认调用链路"><a href="#2-1-默认调用链路" class="headerlink" title="2.1 默认调用链路"></a>2.1 默认调用链路</h3><p><strong><code>restTemplate</code>进行 API 调用时，默认调用链：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">###########<span class="number">1.</span>使用createRequest创建请求########</span><br><span class="line">resttemplate-&gt;execute()-&gt;doExecute()</span><br><span class="line">HttpAccessor-&gt;createRequest()</span><br><span class="line"><span class="comment">//获取拦截器Interceptor，InterceptingClientHttpRequestFactory，SimpleClientHttpRequestFactory</span></span><br><span class="line">InterceptingHttpAccessor-&gt;getRequestFactory()</span><br><span class="line"><span class="comment">//获取默认的SimpleBufferingClientHttpRequest</span></span><br><span class="line">SimpleClientHttpRequestFactory-&gt;createRequest()</span><br><span class="line"></span><br><span class="line">#######<span class="number">2.</span>获取响应response进行处理###########</span><br><span class="line">AbstractClientHttpRequest-&gt;execute()-&gt;executeInternal()</span><br><span class="line">AbstractBufferingClientHttpRequest-&gt;executeInternal()</span><br><span class="line"></span><br><span class="line">###########<span class="number">3.</span>异常处理#####################</span><br><span class="line">resttemplate-&gt;handleResponse()</span><br><span class="line"></span><br><span class="line">##########<span class="number">4.</span>响应消息体封装为java对象#######</span><br><span class="line">HttpMessageConverterExtractor-&gt;extractData()</span><br></pre></td></tr></table></figure>

<h3 id="2-2-restTemplate-gt-doExecute"><a href="#2-2-restTemplate-gt-doExecute" class="headerlink" title="2.2 restTemplate-&gt;doExecute()"></a>2.2 restTemplate-&gt;doExecute()</h3><p>在默认调用链中，**<code>restTemplate</code>** 进行 API 调用都会调用 <strong><code>doExecute</code></strong> 方法，此方法主要可以进行如下步骤：</p>
<p>1）<strong>使用<code>createRequest</code>创建请求，获取响应</strong></p>
<p>2）<strong>判断响应是否异常，处理异常</strong></p>
<p>3）<strong>将响应消息体封装为 java 对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doExecute</span><span class="params">(URI url, <span class="meta">@Nullable</span> HttpMethod method, <span class="meta">@Nullable</span> RequestCallback requestCallback,</span></span><br><span class="line"><span class="params">		<span class="meta">@Nullable</span> ResponseExtractor&lt;T&gt; responseExtractor)</span> <span class="keyword">throws</span> RestClientException &#123;</span><br><span class="line"></span><br><span class="line">	Assert.notNull(url, <span class="string">&quot;URI is required&quot;</span>);</span><br><span class="line">	Assert.notNull(method, <span class="string">&quot;HttpMethod is required&quot;</span>);</span><br><span class="line">	<span class="type">ClientHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">//使用createRequest创建请求</span></span><br><span class="line">		<span class="type">ClientHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> createRequest(url, method);</span><br><span class="line">		<span class="keyword">if</span> (requestCallback != <span class="literal">null</span>) &#123;</span><br><span class="line">			requestCallback.doWithRequest(request);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//获取响应response进行处理</span></span><br><span class="line">		response = request.execute();</span><br><span class="line">		<span class="comment">//异常处理</span></span><br><span class="line">		handleResponse(url, method, response);</span><br><span class="line">		<span class="comment">//响应消息体封装为java对象</span></span><br><span class="line">		<span class="keyword">return</span> (responseExtractor != <span class="literal">null</span> ? responseExtractor.extractData(response) : <span class="literal">null</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> url.toString();</span><br><span class="line">		<span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> url.getRawQuery();</span><br><span class="line">		resource = (query != <span class="literal">null</span> ? resource.substring(<span class="number">0</span>, resource.indexOf(<span class="string">&#x27;?&#x27;</span>)) : resource);</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ResourceAccessException</span>(<span class="string">&quot;I/O error on &quot;</span> + method.name() +</span><br><span class="line">				<span class="string">&quot; request for \&quot;&quot;</span> + resource + <span class="string">&quot;\&quot;: &quot;</span> + ex.getMessage(), ex);</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (response != <span class="literal">null</span>) &#123;</span><br><span class="line">			response.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-InterceptingHttpAccessor-gt-getRequestFactory"><a href="#2-3-InterceptingHttpAccessor-gt-getRequestFactory" class="headerlink" title="2.3 InterceptingHttpAccessor-&gt;getRequestFactory()"></a>2.3 InterceptingHttpAccessor-&gt;getRequestFactory()</h3><p>在默认调用链中，<code>InterceptingHttpAccessor的getRequestFactory()</code>方法中，如果没有设置<code>interceptor</code>拦截器，就返回默认的<code>SimpleClientHttpRequestFactory</code>，反之，返回<code>InterceptingClientHttpRequestFactory</code>的<code>requestFactory</code>，可以通过<code>resttemplate.setInterceptors</code>设置自定义拦截器<code>interceptor</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Return the request factory that this accessor uses for obtaining client request handles.</span></span><br><span class="line"><span class="keyword">public</span> ClientHttpRequestFactory <span class="title function_">getRequestFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//获取拦截器interceptor(自定义的)</span></span><br><span class="line">		List&lt;ClientHttpRequestInterceptor&gt; interceptors = getInterceptors();</span><br><span class="line">		<span class="keyword">if</span> (!CollectionUtils.isEmpty(interceptors)) &#123;</span><br><span class="line">			<span class="type">ClientHttpRequestFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="built_in">this</span>.interceptingRequestFactory;</span><br><span class="line">			<span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">				factory = <span class="keyword">new</span> <span class="title class_">InterceptingClientHttpRequestFactory</span>(<span class="built_in">super</span>.getRequestFactory(), interceptors);</span><br><span class="line">				<span class="built_in">this</span>.interceptingRequestFactory = factory;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> factory;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">super</span>.getRequestFactory();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后再调用<code>SimpleClientHttpRequestFactory的createRequest</code>创建连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ClientHttpRequest <span class="title function_">createRequest</span><span class="params">(URI uri, HttpMethod httpMethod)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">HttpURLConnection</span> <span class="variable">connection</span> <span class="operator">=</span> openConnection(uri.toURL(), <span class="built_in">this</span>.proxy);</span><br><span class="line">	prepareConnection(connection, httpMethod.name());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.bufferRequestBody) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleBufferingClientHttpRequest</span>(connection, <span class="built_in">this</span>.outputStreaming);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SimpleStreamingClientHttpRequest</span>(connection, <span class="built_in">this</span>.chunkSize, <span class="built_in">this</span>.outputStreaming);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-resttemplate-gt-handleResponse"><a href="#2-4-resttemplate-gt-handleResponse" class="headerlink" title="2.4 resttemplate-&gt;handleResponse()"></a>2.4 resttemplate-&gt;handleResponse()</h3><p>在默认调用链中，<code>resttemplate的handleResponse</code>，响应处理，包括异常处理，而且异常处理可以通过调用<code>setErrorHandler</code>方法设置自定义的<code>ErrorHandler</code>，实现对请求响应异常的判别和处理。自定义的<code>ErrorHandler</code>需实现<code>ResponseErrorHandler</code>接口，同时<code>Spring boot</code>也提供了默认实现<code>DefaultResponseErrorHandler</code>，因此也可以通过继承该类来实现自己的<code>ErrorHandler</code>。</p>
<p><code>DefaultResponseErrorHandler</code>默认对 40X <code>Bad Request</code>或 50X <code>internal</code>异常<code>error</code>等错误信息捕捉。如果想捕捉服务本身抛出的异常信息，需要通过自行实现<code>RestTemplate</code>的<code>ErrorHandler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ResponseErrorHandler</span> <span class="variable">errorHandler</span> <span class="operator">=</span> getErrorHandler();</span><br><span class="line">               <span class="comment">//判断响应是否有异常</span></span><br><span class="line">	<span class="type">boolean</span> <span class="variable">hasError</span> <span class="operator">=</span> errorHandler.hasError(response);</span><br><span class="line">	<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">code</span> <span class="operator">=</span> response.getRawStatusCode();</span><br><span class="line">			<span class="type">HttpStatus</span> <span class="variable">status</span> <span class="operator">=</span> HttpStatus.resolve(code);</span><br><span class="line">			logger.debug(<span class="string">&quot;Response &quot;</span> + (status != <span class="literal">null</span> ? status : code));</span><br><span class="line">		&#125;<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">			<span class="comment">// ignore</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//有异常进行异常处理</span></span><br><span class="line">	<span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">		errorHandler.handleError(url, method, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-HttpMessageConverterExtractor-gt-extractData"><a href="#2-5-HttpMessageConverterExtractor-gt-extractData" class="headerlink" title="2.5 HttpMessageConverterExtractor-&gt;extractData()"></a>2.5 HttpMessageConverterExtractor-&gt;extractData()</h3><p>在默认调用链中， <code>HttpMessageConverterExtractor</code>的<code>extractData</code>中进行响应消息体封装为<code>java</code>对象，就需要使用<code>message</code>转换器，可以通过追加的方式增加自定义的<code>messageConverter</code>：先获取现有的<code>messageConverter</code>，再将自定义的<code>messageConverter</code>添加进去。</p>
<p>根据<code>restTemplate</code>的<code>setMessageConverters</code>的源码可得，使用追加的方式可防止原有的<code>messageConverter</code>丢失，源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMessageConverters</span><span class="params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters)</span> &#123;</span><br><span class="line">        <span class="comment">//检验</span></span><br><span class="line">		validateConverters(messageConverters);</span><br><span class="line">		<span class="comment">// Take getMessageConverters() List as-is when passed in here</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.messageConverters != messageConverters) &#123;</span><br><span class="line">		    <span class="comment">//先清除原有的messageConverter</span></span><br><span class="line">			<span class="built_in">this</span>.messageConverters.clear();</span><br><span class="line">			<span class="comment">//后加载重新定义的messageConverter</span></span><br><span class="line">			<span class="built_in">this</span>.messageConverters.addAll(messageConverters);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><code>HttpMessageConverterExtractor的extractData</code>源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MessageBodyClientHttpResponseWrapper</span> <span class="variable">responseWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageBodyClientHttpResponseWrapper</span>(response);</span><br><span class="line">	<span class="keyword">if</span> (!responseWrapper.hasMessageBody() || responseWrapper.hasEmptyMessageBody()) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//获取到response的ContentType类型</span></span><br><span class="line">	<span class="type">MediaType</span> <span class="variable">contentType</span> <span class="operator">=</span> getContentType(responseWrapper);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="comment">//依次循环messageConverter进行判断是否符合转换条件，进行转换java对象</span></span><br><span class="line">		<span class="keyword">for</span> (HttpMessageConverter&lt;?&gt; messageConverter : <span class="built_in">this</span>.messageConverters) &#123;</span><br><span class="line">		<span class="comment">//会根据设置的返回类型responseType和contentType参数进行匹配，选择合适的MessageConverter</span></span><br><span class="line">			<span class="keyword">if</span> (messageConverter <span class="keyword">instanceof</span> GenericHttpMessageConverter) &#123;</span><br><span class="line">				GenericHttpMessageConverter&lt;?&gt; genericMessageConverter =</span><br><span class="line">						(GenericHttpMessageConverter&lt;?&gt;) messageConverter;</span><br><span class="line">				<span class="keyword">if</span> (genericMessageConverter.canRead(<span class="built_in">this</span>.responseType, <span class="literal">null</span>, contentType)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						<span class="type">ResolvableType</span> <span class="variable">resolvableType</span> <span class="operator">=</span> ResolvableType.forType(<span class="built_in">this</span>.responseType);</span><br><span class="line">						logger.debug(<span class="string">&quot;Reading to [&quot;</span> + resolvableType + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> (T) genericMessageConverter.read(<span class="built_in">this</span>.responseType, <span class="literal">null</span>, responseWrapper);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">this</span>.responseClass != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (messageConverter.canRead(<span class="built_in">this</span>.responseClass, contentType)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						<span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> <span class="built_in">this</span>.responseClass.getName();</span><br><span class="line">						logger.debug(<span class="string">&quot;Reading to [&quot;</span> + className + <span class="string">&quot;] as \&quot;&quot;</span> + contentType + <span class="string">&quot;\&quot;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span> (T) messageConverter.read((Class) <span class="built_in">this</span>.responseClass, responseWrapper);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-contentType-与-messageConverter-之间的关系"><a href="#2-6-contentType-与-messageConverter-之间的关系" class="headerlink" title="2.6 contentType 与 messageConverter 之间的关系"></a>2.6 contentType 与 messageConverter 之间的关系</h3><p>在<code>HttpMessageConverterExtractor</code>的<code>extractData</code>方法中看出，会根据<code>contentType</code>与<code>responseClass</code>选择<code>messageConverter</code>是否可读、消息转换。关系如下：</p>
<table>
<thead>
<tr>
<th>类名</th>
<th>支持的 JavaType</th>
<th>支持的 MediaType</th>
</tr>
</thead>
<tbody><tr>
<td>ByteArrayHttpMessageConverter</td>
<td>byte[]</td>
<td>application&#x2F;octet-stream, <em>&#x2F;</em></td>
</tr>
<tr>
<td>StringHttpMessageConverter</td>
<td>String</td>
<td>text&#x2F;plain, <em>&#x2F;</em></td>
</tr>
<tr>
<td>ResourceHttpMessageConverter</td>
<td>Resource</td>
<td><em>&#x2F;</em></td>
</tr>
<tr>
<td>SourceHttpMessageConverter</td>
<td>Source</td>
<td>application&#x2F;xml, text&#x2F;xml, application&#x2F;*+xml</td>
</tr>
<tr>
<td>AllEncompassingFormHttpMessageConverter</td>
<td>Map&lt;K, List&lt;?&gt;&gt;</td>
<td>application&#x2F;x-www-form-urlencoded, multipart&#x2F;form-data</td>
</tr>
<tr>
<td>MappingJackson2HttpMessageConverter</td>
<td>Object</td>
<td>application&#x2F;json, application&#x2F;*+json</td>
</tr>
<tr>
<td>Jaxb2RootElementHttpMessageConverter</td>
<td>Object</td>
<td>application&#x2F;xml, text&#x2F;xml, application&#x2F;*+xml</td>
</tr>
<tr>
<td>JavaSerializationConverter</td>
<td>Serializable</td>
<td>x-java-serialization;charset&#x3D;UTF-8</td>
</tr>
<tr>
<td>FastJsonHttpMessageConverter</td>
<td>Object</td>
<td><em>&#x2F;</em></td>
</tr>
</tbody></table>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-boot/" rel="tag">spring boot</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-ARTS-10"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/01/ARTS-10/"
    >ARTS-10</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/01/ARTS-10/" class="article-date">
  <time datetime="2019-12-01T10:51:44.000Z" itemprop="datePublished">2019-12-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>ARTS是由左耳朵耗子陈皓在极客时间专栏《左耳听风》中发起的一个每周学习打卡计划。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Algorithm：至少做一个 LeetCode 的算法题。主要为了编程训练和学习。</span><br><span class="line"></span><br><span class="line">Review：阅读并点评至少一篇英文技术文章。主要为了学习英文，如果你英文不行，很难成为技术高手。</span><br><span class="line"></span><br><span class="line">Tip：学习至少一个技术技巧。主要是为了总结和归纳你日常工作中所遇到的知识点。</span><br><span class="line"></span><br><span class="line">Share：分享一篇有观点和思考的技术文章。主要为了输出你的影响力，能够输出你的价值观。</span><br></pre></td></tr></table></figure>

<h2 id="Algorithm-算法"><a href="#Algorithm-算法" class="headerlink" title="Algorithm(算法)"></a>Algorithm(算法)</h2><h3 id="无序数组中位数"><a href="#无序数组中位数" class="headerlink" title="无序数组中位数"></a>无序数组中位数</h3><blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shizhh/p/5746151.html">https://www.cnblogs.com/shizhh/p/5746151.html</a></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Review-点评"><a href="#Review-点评" class="headerlink" title="Review(点评)"></a>Review(点评)</h2><p><a target="_blank" rel="noopener" href="https://medium.com/swlh/why-do-we-need-the-json-web-token-jwt-in-the-modern-web-8490a7284482">为什么现代网络中需要JSON Web令牌（JWT）？</a></p>
<p>总结：</p>
<ul>
<li>HTTP协议是无状态的，这意味着一个新请求对上一个请求一无所知</li>
<li>服务器端会话是HTTP无状态性的一种解决方案，但是从长远来看，这些对我们的扩展能力构成了威胁。</li>
<li>JWT是独立的，这意味着它包含允许或拒绝对API的任何给定请求所需的所有信息</li>
<li>JWT在设计上是无状态的，因此我们不必与HTTP的无状态设计作斗争</li>
<li>JWT是经过编码的，而不是加密的</li>
</ul>
<h2 id="Tip-技巧"><a href="#Tip-技巧" class="headerlink" title="Tip(技巧)"></a>Tip(技巧)</h2><h2 id="Share-分享"><a href="#Share-分享" class="headerlink" title="Share(分享)"></a>Share(分享)</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_22871083/article/details/104172350">慕课网 ThreadLocal 教学视频学习笔记</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-思考-12-人人都是自媒体"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/01/%E6%80%9D%E8%80%83-12-%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E8%87%AA%E5%AA%92%E4%BD%93/"
    >思考 12 人人都是自媒体</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/01/%E6%80%9D%E8%80%83-12-%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E8%87%AA%E5%AA%92%E4%BD%93/" class="article-date">
  <time datetime="2019-12-01T09:56:39.000Z" itemprop="datePublished">2019-12-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>参考文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Yu843dfwFMHgX0A9Z1uISg">革新的知识获取方式 — 背后的秘密！</a></p>
</blockquote>
<blockquote>
<p>这是一个人人都可以成为自媒体的时代，也是人人都应该成为自媒体的时代。</p>
<p>博客算自媒体1.0</p>
<p>微博算自媒体2.0</p>
<p>Vlog算自媒体3.0</p>
<p>我觉得通过输出来学习应该会成为下一个主流的方式，通过不断输出来校验检测自己，不断完善和提高自己。</p>
<p>我觉得如果一个人能够有意识的成为生产方时，他的思考方式就已经发生了巨大的变化。</p>
<p>去成为知识的生产者而不要成为被动接收者。</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-IntelliJ-IDEA-2019-3-发布，更好的性能和易用性"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/30/IntelliJ-IDEA-2019-3-%E5%8F%91%E5%B8%83%EF%BC%8C%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E6%98%93%E7%94%A8%E6%80%A7/"
    >IntelliJ IDEA 2019.3 发布，更好的性能和易用性</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/30/IntelliJ-IDEA-2019-3-%E5%8F%91%E5%B8%83%EF%BC%8C%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%80%A7%E8%83%BD%E5%92%8C%E6%98%93%E7%94%A8%E6%80%A7/" class="article-date">
  <time datetime="2019-11-29T16:00:15.000Z" itemprop="datePublished">2019-11-30</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://www.jetbrains.com/idea/whatsnew">https://www.jetbrains.com/idea/whatsnew</a></p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://www.oschina.net/news/111709/intellij-idea-2019-3-released">https://www.oschina.net/news/111709/intellij-idea-2019-3-released</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hollis_chuang/article/details/101186271">https://blog.csdn.net/hollis_chuang/article/details/101186271</a></p>
<p>IntelliJ IDEA 在 2019 年 11 月 28 日推出了今年最终主要版本-IntelliJ IDEA 2019.3！</p>
<p>这里有个小知识，就是 2019.1、2019.2、2019.3 这些点后面的数字表示的不是月份，而是这一年的第几个版本。</p>
<p>以下为翻译内容，翻译的可能不太准确，之后将会对翻译错误的地方进行修改，由于公众号文章发出后就不能进行大的修改，因此修改后的文章将会更新到以下链接地址，之后也会再发布一篇错误修改后的公众号文章，欢迎关注我。</p>
<p>文章更新链接：<a target="_blank" rel="noopener" href="https://www.yuque.com/gaohanghang/og37t5/hry6a6">https://www.yuque.com/gaohanghang/og37t5/hry6a6</a></p>
</blockquote>
<hr>
<blockquote>
<p>2019.3 11 月 28</p>
<p>IntelliJ IDEA 2019.3 提供了重大的性能和可用性改进，包括更快的启动，主题和快捷键插件的安装更容易，增进 VCS workflows，并增加了对微服务框架、MongoDB 等的支持。</p>
</blockquote>
<h2 id="1-更好的性能"><a href="#1-更好的性能" class="headerlink" title="1. 更好的性能"></a>1. 更好的性能</h2><h3 id="1-1-更快的启动"><a href="#1-1-更快的启动" class="headerlink" title="1.1 更快的启动"></a>1.1 更快的启动</h3><p>此版本主要性能改进之一是启动时间比以往任何时候都短。我们采用了重大的体系结构更改，来并行化 IDE 在启动时执行的某些任务，以便它们不会顺序执行。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/ij_idea_starup_performance-1.png" alt="IntelliJ IDEA启动速度"></p>
<h3 id="1-2-减少内存消耗"><a href="#1-2-减少内存消耗" class="headerlink" title="1.2 减少内存消耗"></a>1.2 减少内存消耗</h3><p>在 IntelliJ IDEA 2019.3 中，我们优化了性能以减少导入大型 Gradle 项目时的峰值内存消耗。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/PerformanceGradle.png" alt="Gradle导入时各阶段内存使用情况"></p>
<h3 id="1-3-响应式用户界面"><a href="#1-3-响应式用户界面" class="headerlink" title="1.3 响应式用户界面"></a>1.3 响应式用户界面</h3><p>我们已经解决了提交给我们的 1600 多个 UI 冻结报告。除此之外，我们还修复了在 Maven 项目中编辑 POM.xml 文件的问题，现在可以立即显示补全建议，而不会出现任何延迟。其他修复有可以更快地处理大型项目中的 VCS 状态更新，更好地处理 ignored 文件，更快地渲染项目树，在使用大量编辑或 debugger 标签页时具有更好的性能，并提高了速度。</p>
<h3 id="1-4-更好的-Java-性能"><a href="#1-4-更好的-Java-性能" class="headerlink" title="1.4 更好的 Java 性能"></a>1.4 更好的 Java 性能</h3><p>此版本对 Java 类型推断进行了许多改进，不仅修复了各种编辑器冻结问题，而且还为长的方法调用链加快了 Java 类型推断。当应用于 multiple lines 时，’Join Lines‘ 操作可以更快地工作。你还将体验到 Java 代码的加速高亮，尤其是涉及到带有通用 var-args 的方法时（其中放置了数十个参数）。</p>
<h3 id="1-5-更好的-Kotlin-性能"><a href="#1-5-更好的-Kotlin-性能" class="headerlink" title="1.5 更好的 Kotlin 性能"></a>1.5 更好的 Kotlin 性能</h3><p>IntelliJ IDEA 2019.3 捆绑了 Kotlin 1.3.60，提供了令人印象深刻的加速效果，例如在编辑器中更快地高亮。</p>
<h2 id="2-改善的可用性"><a href="#2-改善的可用性" class="headerlink" title="2. 改善的可用性"></a>2. 改善的可用性</h2><h3 id="2-1-在不重新启动-IDE-的情况下安装主题和快捷键插件"><a href="#2-1-在不重新启动-IDE-的情况下安装主题和快捷键插件" class="headerlink" title="2.1 在不重新启动 IDE 的情况下安装主题和快捷键插件"></a>2.1 在不重新启动 IDE 的情况下安装主题和快捷键插件</h3><p>在 IntelliJ IDEA 2019.3 中，我们实现了对动态插件安装的支持，这意味着现在你可以安装和卸载主题和快捷键插件，而无需重新启动 IDE。我们计划在将来的版本中将此方法扩展到大多数插件，以使插件管理尽可能容易。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/PluginWithoutRestart.gif"></p>
<h3 id="2-2-更明显的滚动条"><a href="#2-2-更明显的滚动条" class="headerlink" title="2.2 更明显的滚动条"></a>2.2 更明显的滚动条</h3><p>如果你在查看滚动条时遇到困难，现在可以让它脱颖而出。只需启用 “Settings&#x2F;Preferences | Appearance &amp; Behavior | Appearance” 下的 ‘Use contrast scrollbars’ 设置即可。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/UIScrollBars1.png"></p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/UIScrollBars2.png"></p>
<h3 id="2-3-平滑滚动"><a href="#2-3-平滑滚动" class="headerlink" title="2.3 平滑滚动"></a>2.3 平滑滚动</h3><p>我们所做的一个很小但非常有价值的改进是滚动，使用鼠标滚轮滚动后现在可以变得更加平滑。</p>
<p>演示视频地址：<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=MoVS6HOdeew&feature=emb_logo">https://www.youtube.com/watch?v=MoVS6HOdeew&amp;feature=emb_logo</a></p>
<h3 id="2-4-自动配置导入的-Maven-或-sbt-项目"><a href="#2-4-自动配置导入的-Maven-或-sbt-项目" class="headerlink" title="2.4 自动配置导入的 Maven 或 sbt 项目"></a>2.4 自动配置导入的 Maven 或 sbt 项目</h3><p>现在，当你导入，创建或打开 sbt 或 Maven 项目时，IntelliJ IDEA 会自动为你设置它，因此你不再需要手动配置设置。</p>
<h3 id="2-5-重做上下文动作的行为"><a href="#2-5-重做上下文动作的行为" class="headerlink" title="2.5 重做上下文动作的行为"></a>2.5 重做上下文动作的行为</h3><p>在“意图动作”对话框中，即使选择了某个动作并关闭了对话框，IDE 现在仍默认显示所有可用的意图动作。</p>
<h2 id="3-功能更新"><a href="#3-功能更新" class="headerlink" title="3. 功能更新"></a>3. 功能更新</h2><h3 id="3-1-对-Java-13-功能的扩展支持"><a href="#3-1-对-Java-13-功能的扩展支持" class="headerlink" title="3.1 对 Java 13 功能的扩展支持"></a>3.1 对 Java 13 功能的扩展支持</h3><p>我们扩展了对 Java 13 文本块的支持：插入第三个引号时，它们会自动格式化。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/Java13_textBlocks.gif" alt="Java13 文本块"></p>
<h3 id="3-2-可以注入更多模板语言"><a href="#3-2-可以注入更多模板语言" class="headerlink" title="3.2 可以注入更多模板语言"></a>3.2 可以注入更多模板语言</h3><p>借助 IntelliJ IDEA 2019.3，你可以向代码中注入更多模板语言，特别是 Pug（ex-Jade），Handlebars，EJS 和 Slim。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/InjectionTempl.gif"></p>
<h3 id="3-3-新的-“字段调用树”-操作"><a href="#3-3-新的-“字段调用树”-操作" class="headerlink" title="3.3 新的 “字段调用树” 操作"></a>3.3 新的 “字段调用树” 操作</h3><p>现在，通过使用 Ctrl + Alt + H 调用新的“字段调用树”操作，可以轻松地查看所选字段的调用树。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/FieldCallHierarchy.png"></p>
<h3 id="3-4-统一弹出错误和文档"><a href="#3-4-统一弹出错误和文档" class="headerlink" title="3.4 统一弹出错误和文档"></a>3.4 统一弹出错误和文档</h3><p>现在，检查中将鼠标悬停在突出显示的符号上时，除了显示代码参考信息之外，你还可以使弹出窗口显示错误。要启用此功能，请在 Settings&#x2F;Preferences | Editor | General 中选择 ‘Show quick documentation on mouse move’。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/DocErrToolTip.png"></p>
<h3 id="3-5-改进-Git-checkout-工作流程"><a href="#3-5-改进-Git-checkout-工作流程" class="headerlink" title="3.5 改进 Git checkout 工作流程"></a>3.5 改进 Git checkout 工作流程</h3><p>为了消除混淆，在远程分支上调用新重命名的 ‘Checkout’ 操作现在将创建一个新的本地分支，将其签出，并将跟踪设置为远程分支。我们还为本地和远程分支添加了 ‘New Branch from Selected’ 操作，该操作创建了一个新的本地分支并将其签出，但未将跟踪设置为任何远程分支。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/VCSCheckout.png"></p>
<h3 id="3-6-推分支的更简单方法"><a href="#3-6-推分支的更简单方法" class="headerlink" title="3.6 推分支的更简单方法"></a>3.6 推分支的更简单方法</h3><p>你会很高兴的发现另一个节省时间的方法是，你不再需要签出分支来推送它–你只需在 Git 分支弹出窗口中选择一个分支并将其从那里推送即可。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/VCSPushNonActiveBranch.png"></p>
<h3 id="3-7-统一的“克隆”体验"><a href="#3-7-统一的“克隆”体验" class="headerlink" title="3.7 统一的“克隆”体验"></a>3.7 统一的“克隆”体验</h3><p>我们重新设计了 ‘Clone’ 对话框来统一用户界面，用于从不同的 VCS 托管服务获取项目。如果你已经登录到 VCS，IDE 将显示可供选择的可用仓库列表，因此你不再需要输入仓库 URL。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/VCSCloneDialog.png"></p>
<h3 id="2-8-深入了解合并冲突"><a href="#2-8-深入了解合并冲突" class="headerlink" title="2.8 深入了解合并冲突"></a>2.8 深入了解合并冲突</h3><p>现在，如果在 merge，rebase 或 cherry-pick 操作期间发生冲突，在合并对话框中你可以获取有关更改源的更多信息。只需单击 ‘Show Details’ 链接即可获取导致代码冲突的提交列表。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewMerge_ShowDetails.gif" alt="解决冲突时通过 Show Details 查看更多信息"></p>
<h2 id="4-新框架和新技术"><a href="#4-新框架和新技术" class="headerlink" title="4. 新框架和新技术"></a>4. 新框架和新技术</h2><h3 id="4-1-微服务框架支持"><a href="#4-1-微服务框架支持" class="headerlink" title="4.1 微服务框架支持"></a>4.1 微服务框架支持</h3><p>为了使你的 IntelliJ IDEA 项目在技术上保持相关性，版本 2019.3 添加了对 Micronaut，Quarkus 和 Helidon 的初步支持。如果你的 Java 项目采用了基于微服务的架构，则可以享受完整的编码协助、导航、检查、查找和其他好处。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewMicronaut.gif"></p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewQuarkus.gif"></p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewHelidon.gif"></p>
<h3 id="4-2-OpenAPI-和-Swagger-支持"><a href="#4-2-OpenAPI-和-Swagger-支持" class="headerlink" title="4.2 OpenAPI 和 Swagger 支持"></a>4.2 OpenAPI 和 Swagger 支持</h3><p>我们引入了对 Swagger v2 和 OpenAPI v2 的支持，该支持提供了 schema validation，以及代码补全、导航、查找，以及包含 API 描述的 YAML &#x2F; JSON 文件中的重命名重构。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewSwagger_validation_example.png"></p>
<h3 id="4-3-新-Endpoints-窗口"><a href="#4-3-新-Endpoints-窗口" class="headerlink" title="4.3 新 Endpoints 窗口"></a>4.3 新 Endpoints 窗口</h3><p>全新的 ‘Endpoints’ 工具窗口提供了项目中用于 HTTP 和 Web Socket 协议的客户端和服务端 API 的聚合视图。此外，你可以将窗口扩展到 IntelliJ IDEA 中当前打开的所有项目。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewEndpoints.png"></p>
<h3 id="4-4-Spring-Web-Flux-支持"><a href="#4-4-Spring-Web-Flux-支持" class="headerlink" title="4.4 Spring Web Flux 支持"></a>4.4 Spring Web Flux 支持</h3><p>在 Spring tool 窗口的 MVC 视图中查看 Web Flux URL 路径的完整列表，在它们之间导航，并受益于编码辅助、搜索以及 URL 和 URLs 的重命名重构。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewSpringWebFlux.gif" alt="NewSpringWebFlux"></p>
<h3 id="4-5-Java-HTTP-客户端支持"><a href="#4-5-Java-HTTP-客户端支持" class="headerlink" title="4.5 Java HTTP 客户端支持"></a>4.5 Java HTTP 客户端支持</h3><p>IntelliJ IDEA 2019.3 在以下 Java HTTP 客户端 API 中提供 URL 支持： java.net.{URI&#x2F;URL}, Retrofit v2, OkHttp v3, and Injectable URL reference。你现在在 Java 客户端中可以使用 Java 中常用的所有内容 - 编码辅助，导航，查找。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewJavaHTTPClients.png"></p>
<h3 id="4-6-Project-Reactor-支持"><a href="#4-6-Project-Reactor-支持" class="headerlink" title="4.6 Project Reactor 支持"></a>4.6 Project Reactor 支持</h3><p>利用对 Java 和 Kotlin Reactor 项目检查的优势，它们会报告在不应阻塞线程的代码片段中检测到的线程阻塞方法调用。IDE 还将警告你有关 Flux 和 Mono 方法的 lambda 运算符可能返回 null 的信息。最重要的是，有一个专用的 Reactor 调试模式，可提供有关响应栈帧和中间变量值的有用视图。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewReactorNonBlocking-1.png"></p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewReactorPostFixCompletion-1.png"></p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewReactorDebug.png"></p>
<h3 id="4-7-MongoDB-支持"><a href="#4-7-MongoDB-支持" class="headerlink" title="4.7 MongoDB 支持"></a>4.7 MongoDB 支持</h3><p>IntelliJ IDEA 2019.3 附带了期待已久的 MongoDB 支持。添加 MongoDB 数据源后，请在数据库浏览器中查看集合和字段，运行查询并查看查询结果。我们将在将来的版本中扩展对 MongoDB 的支持。</p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewMongoDB1.png"></p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewMongoDB2.png"></p>
<p><img src="https://www.jetbrains.com/idea/whatsnew/2019-3/img/NewMongoDB3.png"></p>
<h2 id="5-修复了什么"><a href="#5-修复了什么" class="headerlink" title="5. 修复了什么"></a>5. 修复了什么</h2><ul>
<li>IDE 现在可以检测到使用 Homebrew 安装的 Gradle 目录。</li>
<li>用户界面得到了改进，因此现在可以更轻松地手动设置 Gradle 主目录。</li>
<li>IntelliJ IDEA 现在支持在 Linux 上通过 KWallet 存储密码。</li>
<li>当用户使用 JavaFX 项目时，IDE 可以在 ‘Scene Builder’ 选项卡中显示带有嵌入式 Scene Builder 的 FXML 文件。</li>
<li>当无法访问 SVN 服务器时，SVN 的“需要身份验证”对话框不再弹出。</li>
<li>我们已经修复了与使用 rebase 执行’git update’操作有关的问题。</li>
<li>现在，在索引 Git 日志时，IDE 将显示一个进度条。</li>
<li>现在，你可以选择是否要在文件历史记录窗口和 VCS 批注中查看更改的创建时间或提交时间。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-java并发教程翻译"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/24/java%E5%B9%B6%E5%8F%91%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91/"
    >java并发教程翻译</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/24/java%E5%B9%B6%E5%8F%91%E6%95%99%E7%A8%8B%E7%BF%BB%E8%AF%91/" class="article-date">
  <time datetime="2019-11-24T02:49:02.000Z" itemprop="datePublished">2019-11-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/index.html">http://tutorials.jenkov.com/java-concurrency/index.html</a></p>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="http://ifeve.com/java-concurrency-thread/">并发译文</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/JackLang/article/details/52294629">https://blog.csdn.net/JackLang/article/details/52294629</a></p>
<p><a target="_blank" rel="noopener" href="https://www.codeboot.net/tutorials/java-concurrency/index/">https://www.codeboot.net/tutorials/java-concurrency/index/</a></p>
<p>该英文教程更新了，因此站在前人的肩膀上，斗胆进行舔砖加瓦。英文不是特别好，全靠 Google 翻译和前辈的博客 🤣</p>
<p>译者：高行行</p>
<p>该 java 并发教程汇总和修订地址：<a target="_blank" rel="noopener" href="https://www.yuque.com/gaohanghang/og37t5/kqzsra">https://www.yuque.com/gaohanghang/og37t5/kqzsra</a></p>
</blockquote>
<p>Java <em>并发</em> 是一个涵盖 Java 平台多线程，并发和并行的术语。其中包括 Java 并发工具、问题和解决方案。该 Java 并发教程涵盖了多线程的核心概念、并发构造·、并发问题、坏处以及与 Java 中多线程相关的好处。</p>
<h1 id="1-Java-并发和多线程教程"><a href="#1-Java-并发和多线程教程" class="headerlink" title="1. Java 并发和多线程教程"></a>1. Java 并发和多线程教程</h1><blockquote>
<p>小结：</p>
<ol>
<li><p>什么是多线程：一个程序同时执行多个任务</p>
</li>
<li><p>为什么要使用多线程：</p>
<ul>
<li>更好地利用单个 CPU。</li>
<li>更好地利用多个 CPU 或 CPU 内核。</li>
<li>通过响应性获得更好的用户体验。</li>
<li>通过公平地共享计算机资源获得更好的用户体验。</li>
</ul>
</li>
<li><p>多线程与多任务：多任务是指在同一刻运行多个程序的能力，多线程程序在较低的层次上扩展了多任务的概念：一个程序同时执行多个任务。通常， 每一个任务称为一个线程 （ thread ) , 它是线程控制的简称。–《java核心技术卷一》</p>
</li>
<li><p>多线程难点：控制线程访问共享资源</p>
</li>
</ol>
</blockquote>
<h2 id="1-1-什么是多线程？"><a href="#1-1-什么是多线程？" class="headerlink" title="1.1 什么是多线程？"></a>1.1 什么是多线程？</h2><p>多线程意味着你在同一应用程序中具有多个<em>执行线程</em>。一个线程就像执行应用程序的独立 CPU。因此，多线程应用程序就像具有多个 CPU 同时执行代码不同部分的应用程序。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191213004044.png" alt="在其中执行两个线程的应用程序"></p>
<p>线程不等于 CPU。通常，单个 CPU 将在多个线程之间共享其执行时间，并在给定的时间量内在每个线程的执行之间进行切换。也可以让应用程序的线程由不同的 CPU 执行。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191213004101.png" alt="具有线程由不同线程执行的多个应用程序"></p>
<h2 id="1-2-为什么要使用多线程？"><a href="#1-2-为什么要使用多线程？" class="headerlink" title="1.2 为什么要使用多线程？"></a>1.2 为什么要使用多线程？</h2><p>为什么要在应用程序中使用多线程有几个原因。使用多线程的一些最常见原因是：</p>
<ul>
<li>更好地利用单个 CPU。</li>
<li>更好地利用多个 CPU 或 CPU 内核。</li>
<li>通过响应性获得更好的用户体验。</li>
<li>通过公平地共享计算机资源获得更好的用户体验。</li>
</ul>
<p>我将在以下各节中详细解释每个原因。</p>
<h3 id="1-2-1-更好地利用单个-CPU"><a href="#1-2-1-更好地利用单个-CPU" class="headerlink" title="1.2.1 更好地利用单个 CPU"></a>1.2.1 更好地利用单个 CPU</h3><p>最常见的原因之一是能够更好地利用计算机中的资源。例如，如果一个线程正在等待通过网络请求的响应，则另一线程可以同时使用 CPU 来执行其他操作。此外，如果计算机具有多个 CPU，或者 CPU 具有多个执行核心，则多线程还可以帮助你的应用程序利用这些额外的 CPU 核心。</p>
<h3 id="1-2-2-更好地利用多个-CPU-或-CPU-内核"><a href="#1-2-2-更好地利用多个-CPU-或-CPU-内核" class="headerlink" title="1.2.2 更好地利用多个 CPU 或 CPU 内核"></a>1.2.2 更好地利用多个 CPU 或 CPU 内核</h3><p>如果计算机包含多个 CPU 或 CPU 包含多个执行核心，则你需要为应用程序使用多个线程才能使用所有 CPU 或 CPU 核心。单个线程最多只能使用一个 CPU，如上所述，有时甚至不能完全利用单个 CPU。</p>
<p>###1.2.3 通过响应性获得更好的用户体验</p>
<p>使用多线程的另一个原因是为了提供更好的用户体验。例如，如果你单击 GUI 中的按钮，并导致通过网络发送请求，那么哪个线程执行此请求就很重要。如果使用的线程也正在更新 GUI，则在 GUI 线程等待请求响应时，用户可能会遇到 GUI“挂起”的情况。取而代之的是，这样的请求可以由后台线程执行，因此 GUI 线程可以自由地同时响应其他用户请求。</p>
<h3 id="1-2-4-通过公平地共享计算机资源获得更好的用户体验"><a href="#1-2-4-通过公平地共享计算机资源获得更好的用户体验" class="headerlink" title="1.2.4 通过公平地共享计算机资源获得更好的用户体验"></a>1.2.4 通过公平地共享计算机资源获得更好的用户体验</h3><p>第四个原因是在用户之间更公平地共享计算机资源。例如，假设一台服务器接收来自客户端的请求，并且只有一个线程来执行这些请求。如果客户端发送的请求要花费很长时间才能处理，则所有其他客户端的请求都必须等待，直到一个请求完成。通过让每个客户端的请求由其自己的线程执行，则没有一个任务可以完全垄断 CPU。</p>
<h2 id="1-3-多线程与多任务"><a href="#1-3-多线程与多任务" class="headerlink" title="1.3 多线程与多任务"></a>1.3 多线程与多任务</h2><p>过去，一台计算机只有一个 CPU，并且一次只能执行一个程序。大多数小型计算机的功能实际上不足以同时执行多个程序，因此没有尝试过。公平地讲，许多大型机系统能够一次执行多个程序的时间比个人计算机长得多。</p>
<h3 id="1-3-1-多任务"><a href="#1-3-1-多任务" class="headerlink" title="1.3.1 多任务"></a>1.3.1 多任务</h3><p>后来出现了多任务处理，这意味着计算机可以同时执行多个程序（AKA 任务或进程）。但是，这并不是真正的“同时”。单个 CPU 在程序之间共享。操作系统将在运行的程序之间进行切换，并在切换之前执行每个程序一会儿。</p>
<p>随着多任务处理，软件开发人员面临着新的挑战。程序不再假定拥有所有可用的 CPU 时间，也不拥有所有的内存或任何其他计算机资源。一个“好公民”程序应释放不再使用的所有资源，以便其他程序可以使用它们。</p>
<h3 id="1-3-2-多线程"><a href="#1-3-2-多线程" class="headerlink" title="1.3.2 多线程"></a>1.3.2 多线程</h3><p>后来出现了多线程，这意味着你可以在同一程序中拥有多个执行线程。可以将执行线程视为执行程序的 CPU。当你有多个线程执行同一程序时，就像在同一程序中执行多个 CPU。</p>
<h2 id="1-4-多线程很难"><a href="#1-4-多线程很难" class="headerlink" title="1.4 多线程很难"></a>1.4 多线程很难</h2><p>多线程是提高某些类型程序性能的好方法。但是，多线程处理比多任务处理更具挑战性。这些线程在同一程序中执行，因此同时在读取和写入相同的内存。这可能会导致在单线程程序中看不到的错误。在单个 CPU 机器上可能看不到其中一些错误，因为两个线程从未真正“同时”执行。但是，现代计算机配备了多核 CPU，甚至还配备了多个 CPU。这意味着可以由单独的内核或 CPU 同时执行单独的线程。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191213004203.png" alt="多CPU计算机上的多线程"></p>
<p>如果一个线程在另一个线程写入内存时读取了一个内存，那么第一个线程最终将读取什么值？旧值？第二个线程写的值？还是两者之间混合的值？或者，如果两个线程正在同时写入同一内存位置，那么完成后将剩下什么值？由第一个线程写的值？第二个线程写的值？还是两个值的混合写入？</p>
<p>没有适当的预防措施，任何这些结果都是可能的。该行为甚至是不可预测的。结果可能会不时改变。因此，作为开发人员，重要的是要知道如何采取正确的预防措施-意味着要学习如何控制线程访问共享资源（如内存，文件，数据库等）。这是本 Java 并发教程所要解决的主题之一。</p>
<h2 id="1-5-Java-中的多线程和并发"><a href="#1-5-Java-中的多线程和并发" class="headerlink" title="1.5 Java 中的多线程和并发"></a>1.5 Java 中的多线程和并发</h2><p>Java 是最早让开发人员可以使用多线程的语言之一。Java 从一开始就具有多线程功能。因此，Java 开发人员经常会遇到上述问题。这就是我在 Java 并发上编写此线索的原因。谨此提醒自己，以及提醒可能从中受益的其他 Java 开发人员。</p>
<p>本教程主要关注 Java 中的多线程，但是多线程中发生的某些问题类似于多任务和分布式系统中发生的问题。因此，对多任务和分布式系统的引用也可能出现在此线索中。所以叫法上称为“并发”，而不是“多线程”。</p>
<h2 id="1-6-并发模型"><a href="#1-6-并发模型" class="headerlink" title="1.6 并发模型"></a>1.6 并发模型</h2><p>第一个 Java <em>并发模型</em>假定在同一应用程序中执行的多个线程也将共享对象。这种类型的并发模型通常称为“共享状态并发模型”。许多并发语言构造和实用程序都旨在支持此并发模型。</p>
<p>但是，自从编写第一本 Java 并发书籍以来，甚至自 Java 5 并发实用工具发布以来，并发体系结构和设计领域已经发生了很多事情。</p>
<p>共享状态并发模型导致许多并发问题，这些问题很难优雅地解决。因此，被称为“无共享”或“分离状态”的替代并发模型已经普及。在单独的状态并发模型中，线程不共享任何对象或数据。这避免了共享状态并发模型的许多并发访问问题。</p>
<p>出现了新的异步“独立状态”平台和工具包，例如 Netty，Vert.x 和 Play &#x2F; Akka 和 Qbit。新的非阻塞并发算法已经发布，并且新的非阻塞工具（例如 LMax Disrupter）已添加到我们的工具箱中。Java 7 中的 Fork and Join 框架和 Java 8 中的 collection stream API 引入了新的函数式编程并行性。</p>
<p>随着所有这些新的发展，现在是时候更新本 Java 并发教程了。因此，本教程再次<strong>进行中</strong>。只要有时间编写新教程，教程就会被发布。</p>
<h2 id="1-7-Java-并发学习指南"><a href="#1-7-Java-并发学习指南" class="headerlink" title="1.7 Java 并发学习指南"></a>1.7 Java 并发学习指南</h2><p>如果你不熟悉 Java 并发，建议你遵循以下学习计划。你也可以在此页面左侧的菜单中找到所有主题的链接。</p>
<p>通用并发和多线程理论：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/benefits.html" title="多线程的好处">多线程的好处</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/costs.html">多线程代价</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html" title="并发模型">并发模型</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/same-threading.html">相同线程</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/concurrency-vs-parallelism.html" title="并发与并行">并发与并行</a></li>
</ul>
<p>Java 并发基础知识：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/creating-and-starting-threads.html" title="创建和启动Java线程">创建和启动 Java 线程</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html" title="竞态条件与临界区">竞态条件与临界区</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/thread-safety.html" title="线程安全和共享资源">线程安全和共享资源</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/thread-safety-and-immutability.html" title="线程安全和不变性">线程安全和不变性</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/java-memory-model.html" title="Java内存模型">Java 内存模型</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/synchronized.html" title="Java同步块">Java 同步块</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/volatile.html" title="Java volatile关键字">Java volatile关键字</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/threadlocal.html" title="Java ThreadLocal">Java ThreadLocal</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/thread-signaling.html" title="Java线程信令">Java 线程信令</a></li>
</ul>
<p>Java 并发的典型问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/deadlock.html" title="死锁">死锁</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/deadlock-prevention.html" title="防止死锁">防止死锁</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html" title="饥饿与公平">饥饿与公平</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/nested-monitor-lockout.html">嵌套管程锁死</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/slipped-conditions.html" title="Slipped Conditions">Slipped Conditions</a></li>
</ul>
<p>Java 并发构造可帮助解决上述问题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/locks.html" title="Java锁">Java 中的锁</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/read-write-locks.html" title="Java中的读/写锁">Java 中的读&#x2F;写锁</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/reentrance-lockout.html" title="重入锁死">重入锁死</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/semaphores.html">信号量</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/blocking-queues.html" title="阻塞队列">阻塞队列</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/thread-pools.html" title="线程池">线程池</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/compare-and-swap.html">CAS</a></li>
</ul>
<p>进一步的主题：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/anatomy-of-a-synchronizer.html" title="同步器的解剖">剖析同步器</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html" title="非阻塞算法">非阻塞算法</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/amdahls-law.html" title="阿姆达尔定律">阿姆达尔定律</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/references.html" title="参考文献">参考文献</a></li>
</ul>
<h1 id="2-多线程的好处"><a href="#2-多线程的好处" class="headerlink" title="2. 多线程的好处"></a>2. 多线程的好处</h1><ul>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/benefits.html#better-cpu-utilization">更好的CPU使用率</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/benefits.html#simpler-program-design">程序设计更简单</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/benefits.html#more-responsive-programs">更多响应程序</a></li>
<li><a target="_blank" rel="noopener" href="http://tutorials.jenkov.com/java-concurrency/benefits.html#more-fair-distribution-of-cpu-resources">更公平地分配CPU资源</a></li>
</ul>
<p>多线程的最大好处是：</p>
<ul>
<li>更高的CPU利用率。</li>
<li>在某些情况下，程序设计更简单。</li>
<li>响应速度更快的程序。</li>
<li>在不同任务之间更公平地分配CPU资源。</li>
</ul>
<h2 id="2-1-更好的CPU使用率"><a href="#2-1-更好的CPU使用率" class="headerlink" title="2.1 更好的CPU使用率"></a>2.1 更好的CPU使用率</h2><p>想象一个应用程序从本地文件系统读取和处理文件。假设从磁盘读取af文件需要5秒钟，而处理则需要2秒钟。然后处理两个文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  5秒钟读取文件A</span><br><span class="line">  2秒处理文件A</span><br><span class="line">  5秒钟读取文件B</span><br><span class="line">  2秒处理文件B</span><br><span class="line">-----------------------</span><br><span class="line"> 总共14秒</span><br></pre></td></tr></table></figure>

<p>从磁盘读取文件时，大部分的CPU时间都花在等待磁盘读取数据上。在这段时间内，CPU几乎处于空闲状态。它可能正在做其他事情。通过更改操作顺序，可以更好地利用CPU。查看以下顺序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  5秒钟读取文件A</span><br><span class="line">  5秒读取文件B + 2秒处理文件A</span><br><span class="line">  2秒处理文件B</span><br><span class="line">-----------------------</span><br><span class="line"> 总共12秒</span><br></pre></td></tr></table></figure>

<p>CPU等待读取第一个文件。然后，它开始读取第二个文件。当计算机的IO组件读取第二个文件时，CPU处理第一个文件。请记住，在等待从磁盘读取文件时，CPU大部分处于空闲状态。</p>
<p>通常，CPU在等待IO时可以做其他事情。不必是磁盘IO。它也可以是网络IO，也可以是来自计算机用户的输入。网络和磁盘IO通常比CPU和内存IO慢很多。</p>
<h2 id="2-2-程序设计更简单"><a href="#2-2-程序设计更简单" class="headerlink" title="2.2 程序设计更简单"></a>2.2 程序设计更简单</h2><p>如果要在单线程应用程序中手动编写上述读取和处理的顺序，则必须跟踪每个文件的读取和处理状态。相反，您可以启动两个线程，每个线程仅读取和处理一个文件。这些等待线程将在等待磁盘读取其文件时被阻止。在等待时，其他线程可以使用CPU处理已读取的文件部分。结果是磁盘始终保持忙碌状态，将各种文件读入内存。这样可以更好地利用磁盘和CPU。编程也更容易，因为每个线程只需要跟踪一个文件即可。</p>
<h2 id="2-3-更多响应程序"><a href="#2-3-更多响应程序" class="headerlink" title="2.3 更多响应程序"></a>2.3 更多响应程序</h2><p>将单线程应用程序转换为多线程应用程序的另一个共同目标是实现响应速度更快的应用程序。想象一个服务器应用程序在某个端口上侦听传入的请求。收到请求后，它将处理该请求，然后返回监听。服务器循环如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(服务器处于活动状态)&#123;</span><br><span class="line">  	监听请求</span><br><span class="line">   流程请求</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果请求需要很长时间才能处理，则在这段时间内没有新客户端可以向服务器发送请求。只有在服务器正在侦听时，才能接收请求。</p>
<p>另一种设计是侦听线程将请求传递给工作线程，然后立即返回侦听。工作线程将处理该请求，并将回复发送给客户端。该设计概述如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(服务器处于活动状态) &#123; </span><br><span class="line">   监听对</span><br><span class="line">   工作线程的请求请求</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这样，服务器线程将尽快恢复监听。因此，更多的客户端可以将请求发送到服务器。服务器变得更加敏感。</p>
<p>桌面应用程序也是如此。如果单击启动长任务的按钮，并且执行任务的线程是更新窗口，按钮等的线程，则任务执行时应用程序将显示为无响应。而是可以将任务移交给工作线程。当工作线程忙于任务时，窗口线程可以自由响应其他用户请求。当工作线程完成时，它向窗口线程发出信号。然后，窗口线程可以使用任务结果更新应用程序窗口。具有工作线程设计的程序将对用户响应更快。</p>
<h2 id="2-4-更公平地分配CPU资源"><a href="#2-4-更公平地分配CPU资源" class="headerlink" title="2.4 更公平地分配CPU资源"></a>2.4 更公平地分配CPU资源</h2><p>假设有一个服务器正在接收来自客户端的请求。然后想象一下，其中一个客户端发送了一个处理时间很长的请求，例如10秒。如果服务器使用单个线程处理了所有任务，则处理缓慢的请求之后的所有请求将被迫等待，直到处理完整个请求为止。</p>
<p>通过在多个线程之间划分CPU时间并在线程之间进行切换，CPU可以在多个请求之间更公平地共享其执行时间。这样，即使其中一个请求较慢，也可以与较慢的请求同时执行处理速度更快的其他请求。当然，这意味着执行慢速请求的速度甚至会更慢，因为它不会仅将CPU分配给处理它。但是，其他请求将不得不等待更短的时间来处理，因为它们不必等待缓慢的任务完成才可以处理它们。如果只有慢请求要处理，则仍可以将CPU单独分配给慢任务。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-思考-11-不断update"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/24/%E6%80%9D%E8%80%83-11-%E4%B8%8D%E6%96%ADupdate/"
    >思考 11 不断update</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/24/%E6%80%9D%E8%80%83-11-%E4%B8%8D%E6%96%ADupdate/" class="article-date">
  <time datetime="2019-11-23T17:25:09.000Z" itemprop="datePublished">2019-11-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>在北京，会发现有很多店关闭了，也会发现有很多新开的店。而新开的店面很漂亮，那为什么那些旧的店不去重新装修和改进呢？</p>
<p>我用的电脑之前是MacBook Air，后来换成的MacBook Pro，发现开发效率更高了。</p>
<p>最近苹果发布了新的16英寸MacBook Pro，我会产生抵触心理，认为现在的就够用了，蝶式键盘也不错呀，很好了，我不需要更好的设备，开始不断的给自己找到理由来否定新的Mac电脑。</p>
<p>我认为每个人都会有这种心理，会给自己已经拥有的事物找理由，认为不需要改变，但这样会变得不客观和理性，会变得迟钝和墨守成规。我应该承认新款的Mac确实更加优秀，去想办法赚钱买它，而不是否定它。</p>
<p>去拥抱变化，而不能否定变化。</p>
<p>微软不也是从一开始的封闭变得越来越拥抱开源了吗，不拥抱改变的下场大概就是被抛弃把。</p>
<p>不改变就会凉，要不断更新自己。</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/6/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/8/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> 高行行
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="高行行的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://gaohanghang.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/twitter">Twitter</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://weibo.com/u/5125203090">微博</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>