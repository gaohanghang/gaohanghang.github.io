<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="个人公众号《骇客与画家》" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 高行行的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">高行行的个人博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '科技需要人文的浇灌', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-慕课网-ThreadLocal-教学视频学习笔记"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/02/01/%E6%85%95%E8%AF%BE%E7%BD%91-ThreadLocal-%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"
    >慕课网 ThreadLocal 教学视频学习笔记</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/02/01/%E6%85%95%E8%AF%BE%E7%BD%91-ThreadLocal-%E6%95%99%E5%AD%A6%E8%A7%86%E9%A2%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time datetime="2020-01-31T16:33:30.000Z" itemprop="datePublished">2020-02-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>课程地址：<a target="_blank" rel="noopener" href="https://www.imooc.com/learn/1217">https://www.imooc.com/learn/1217</a></p>
<p>作者：<a target="_blank" rel="noopener" href="https://www.imooc.com/u/6703917/courses?sort=publish">求老仙奶我不到 P10</a>（这昵称 🤔，我奶一口，你到不了 P10 🐶）</p>
<p>作者简介：我是一名有 10 年经验的互联网老兵，创过业、也曾任数家大型互联网公司架构师、团队 Leader，30 岁（2018）任职阿里巴巴高级技术专家（P8）。曾负责架构 PHP 高负载、前端（React&#x2F;RN）方向、Java 领域化中间件方向、大数据(BI 和数据可视化)等多方向业界知名项目。大学刷完算法导论，参加过 ACM 和国际机器人竞赛，多年在项目中实践技术驱动、前端后端领域化、数据可视化，多个领域实战经验丰富。</p>
<p>代码地址（跟着课程手敲的）：<a target="_blank" rel="noopener" href="https://github.com/gaohanghang/spring-threadlocal-demo">https://github.com/gaohanghang/spring-threadlocal-demo</a></p>
</blockquote>
<blockquote>
<p>简介：多线程增加了我们的不确定性，破坏了可预测性——当然，这对于【艺高人胆大】的未来的你，都是小事，因为你会不断进步成长，只要你把握好现在的光阴。科学的美，在于它的模型可以不断的迭代和进步，Java 是一种简化和进步，ThreadLocal 也一种简化和进步，如同 Java 给编程带来了很多安全感，而 ThreadLocal 给多线程时代带了更多的安全感（可预测性、确定性，一致性……）。课程是一种爬坡训练，难度会一直上去直到你完全理解，可以自己动手实现。</p>
</blockquote>
<h2 id="第-1-章-纵观课程纲要"><a href="#第-1-章-纵观课程纲要" class="headerlink" title="第 1 章 纵观课程纲要"></a>第 1 章 纵观课程纲要</h2><blockquote>
<p>了解一致性等基础概念，解决一致性的基本方法，把 ThreadLocal 放到一个宏观背景去思考。</p>
</blockquote>
<h3 id="1-1-论程序的安全感-09-09"><a href="#1-1-论程序的安全感-09-09" class="headerlink" title="1-1 论程序的安全感 (09:09)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21049">1-1 论程序的安全感 (09:09)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580489265125-61162927-4d88-40e2-9df2-8ff7170ee2d9.png"></p>
<p>改变思维方式</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580275962784-b45e6758-929b-4781-ae93-fa62fcc2bdc0.png#align=left&display=inline&height=627&name=image.png&originHeight=1254&originWidth=2232&size=271910&status=done&style=none&width=1116"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580275979974-aeb59c89-4af7-49f3-bec0-339fa7357845.png#align=left&display=inline&height=627&name=image.png&originHeight=1254&originWidth=2236&size=417984&status=done&style=none&width=1118"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580276010435-18c12c8d-09cc-4fe8-9432-d04f0bd0aa4f.png#align=left&display=inline&height=626&name=image.png&originHeight=1252&originWidth=2234&size=356979&status=done&style=none&width=1117"></p>
<p>Single Source Of Truth: 单一数据源</p>
<p>不断的解决数据不一致的问题</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580276117575-bf72a3c3-3b3c-4531-881f-2f21d8fed80a.png#align=left&display=inline&height=617&name=image.png&originHeight=1234&originWidth=2224&size=447585&status=done&style=none&width=1112"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580276289023-4bda0d52-a530-4848-9161-5a66fd9c11e0.png#align=left&display=inline&height=621&name=image.png&originHeight=1242&originWidth=2224&size=446544&status=done&style=none&width=1112"></p>
<h3 id="1-2-课程介绍-07-12"><a href="#1-2-课程介绍-07-12" class="headerlink" title="1-2 课程介绍 (07:12)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21050">1-2 课程介绍 (07:12)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580278369748-7882e0d6-eca7-4558-8d6c-93bb7cc2aad0.png#align=left&display=inline&height=692&name=image.png&originHeight=1384&originWidth=2496&size=185733&status=done&style=none&width=1248"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580276550045-7d46ea6d-c7f4-4916-aa1e-1e073c03fab7.png#align=left&display=inline&height=622&name=image.png&originHeight=1244&originWidth=2232&size=881348&status=done&style=none&width=1116"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580276609094-0e526664-816d-4383-83e8-366a06ed5f5e.png#align=left&display=inline&height=623&name=image.png&originHeight=1246&originWidth=2214&size=402740&status=done&style=none&width=1107"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580276710900-a1ba2337-c082-4fd1-9a34-fe6d6fe7c98e.png#align=left&display=inline&height=622&name=image.png&originHeight=1244&originWidth=2216&size=432044&status=done&style=none&width=1108"></p>
<h2 id="第-2-章-是什么？怎么用？何时用？如何不出问题？"><a href="#第-2-章-是什么？怎么用？何时用？如何不出问题？" class="headerlink" title="第 2 章 是什么？怎么用？何时用？如何不出问题？"></a>第 2 章 是什么？怎么用？何时用？如何不出问题？</h2><blockquote>
<p>手把手带着 Coding，解决基本概念、API 以及讲 4 个关键应用场景。以及工作中并发场景，如何不出问题。</p>
</blockquote>
<h3 id="2-1-ThreadLocal-是什么-07-41"><a href="#2-1-ThreadLocal-是什么-07-41" class="headerlink" title="2-1 ThreadLocal 是什么 (07:41)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21051">2-1 ThreadLocal 是什么 (07:41)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580288706984-af27ec24-eb3c-4f42-bfa4-fa13c6a6ec0f.png#align=left&display=inline&height=627&name=image.png&originHeight=1254&originWidth=2232&size=427456&status=done&style=none&width=1116"><br>一个进程有多个线程</p>
<p>定义：提供线程局部变量；一个线程局部变量在多个线程中，分别有独立的值（副本）</p>
<p>特点：简单（开箱即用）、快速（无额外开销）、安全（线程安全）</p>
<p>场景：多线程场景（资源持有、线程一致性、并发计算、线程安全等场景）</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580288806795-24533713-bf54-4292-a3c5-c5d2c49a67ed.png#align=left&display=inline&height=619&name=image.png&originHeight=1238&originWidth=2216&size=255050&status=done&style=none&width=1108"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580288867098-1fb65509-be85-4b50-b451-9bb9d346b2bc.png#align=left&display=inline&height=619&name=image.png&originHeight=1238&originWidth=2126&size=458725&status=done&style=none&width=1063"></p>
<p>进程 -&gt; 线程表 -&gt; 线程局部变量</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580288980102-967ec446-b7d3-4666-b9d1-9649fa9fd0bb.png#align=left&display=inline&height=622&name=image.png&originHeight=1244&originWidth=2130&size=345881&status=done&style=none&width=1065"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580289036685-f40570c6-4594-4704-84a2-efd8dbff201e.png#align=left&display=inline&height=613&name=image.png&originHeight=1226&originWidth=2144&size=317384&status=done&style=none&width=1072"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580289099956-50937959-c293-4e59-835b-8a7724123a23.png#align=left&display=inline&height=616&name=image.png&originHeight=1232&originWidth=2212&size=189130&status=done&style=none&width=1106"></p>
<h3 id="2-2-ThreadLocal-基本-API-07-52"><a href="#2-2-ThreadLocal-基本-API-07-52" class="headerlink" title="2-2 ThreadLocal 基本 API (07:52)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21052">2-2 ThreadLocal 基本 API (07:52)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580289189869-ccc0bd89-aca7-4327-8445-f87599491497.png#align=left&display=inline&height=623&name=image.png&originHeight=1246&originWidth=2218&size=241348&status=done&style=none&width=1109"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Basic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ThreadLocal&lt;T&gt;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Long&gt; x = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Long&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Long <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Initial Value run..&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(x.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">        x.set(<span class="number">107L</span>);</span><br><span class="line">        <span class="comment">// 移除当前线程上的ThreadLocal的值</span></span><br><span class="line">        x.remove();</span><br><span class="line">         <span class="comment">/*</span></span><br><span class="line"><span class="comment">            get操作会延迟加载，如果不get,不会触发initialValue</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(x.get());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-ThreadLocal-的-4-种核心场景-07-51"><a href="#2-3-ThreadLocal-的-4-种核心场景-07-51" class="headerlink" title="2-3 ThreadLocal 的 4 种核心场景 (07:51)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21053">2-3 ThreadLocal 的 4 种核心场景 (07:51)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580290263718-4fb89baa-ad2f-429b-b9ac-eb94b60c9dc6.png#align=left&display=inline&height=627&name=image.png&originHeight=1254&originWidth=2224&size=501168&status=done&style=none&width=1112"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580290374565-e131ace0-780a-4e21-bd55-6fd1b8904103.png#align=left&display=inline&height=622&name=image.png&originHeight=1244&originWidth=2204&size=639857&status=done&style=none&width=1102"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580290441950-be7e1bdc-0dbc-4526-bd3f-3237912c493c.png#align=left&display=inline&height=622&name=image.png&originHeight=1244&originWidth=2206&size=727609&status=done&style=none&width=1103"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580290496982-ed04a47b-83d7-46a6-9929-50178a711b18.png#align=left&display=inline&height=619&name=image.png&originHeight=1238&originWidth=2220&size=819485&status=done&style=none&width=1110"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580290545374-3416923f-85e1-4714-8548-44c517809032.png#align=left&display=inline&height=615&name=image.png&originHeight=1230&originWidth=2202&size=502164&status=done&style=none&width=1101"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580290576400-243357b0-d684-4a52-8b14-c2e419a2678e.png#align=left&display=inline&height=618&name=image.png&originHeight=1236&originWidth=2202&size=197988&status=done&style=none&width=1101"><br>总结：</p>
<ul>
<li>持有资源——持有线程资源供线程的各个部分使用，全局获取，减少<strong>编程难度</strong></li>
<li>线程一致——帮助需要保持线程一致的资源（如数据库事务）维护一致性，降低<strong>编程难度</strong></li>
<li>线程安全——帮助只考虑了单线程的程序库，无缝向多线程场景迁移</li>
<li>分布式计算——帮助分布式计算场景的各个线程累计局部计算结果。</li>
</ul>
<h3 id="2-4-Thread-Local-并发场景分析-01-16-50"><a href="#2-4-Thread-Local-并发场景分析-01-16-50" class="headerlink" title="2-4 Thread Local 并发场景分析 01 (16:50)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21062">2-4 Thread Local 并发场景分析 01 (16:50)</a></h3><blockquote>
<p>代码地址：<a target="_blank" rel="noopener" href="https://github.com/gaohanghang/spring-threadlocal-demo">https://github.com/gaohanghang/spring-threadlocal-demo</a></p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580291505762-1356c133-268b-4682-810e-d08be5e7e06e.png#align=left&display=inline&height=612&name=image.png&originHeight=1224&originWidth=2220&size=337821&status=done&style=none&width=1110"></p>
<p>MAC 系统上安装 Apache ab 测试工具教程地址: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/cjsblog/p/10506647.html">https://www.cnblogs.com/cjsblog/p/10506647.html</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install apr</span><br><span class="line">brew install pcre</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">stat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        c++;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ab -n 10000 -c 1 localhost:8080/add</span><br><span class="line"></span><br><span class="line">curl localhost:8080/stat</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580314416673-2323b785-9537-45de-a473-44f1ac2f5092.png#align=left&display=inline&height=574&name=image.png&originHeight=1148&originWidth=2042&size=587690&status=done&style=none&width=1021"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580314502980-1a7d6b25-0e9c-402f-8b12-8816f9ec6167.png#align=left&display=inline&height=565&name=image.png&originHeight=1130&originWidth=2034&size=504701&status=done&style=none&width=1017"></p>
<p><strong>使用 Synchronized</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">void</span>  <span class="title function_">__add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">stat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="comment">//Thread.sleep(100);</span></span><br><span class="line">        <span class="comment">//c++;</span></span><br><span class="line">        __add();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用synchronize后测试</span><br><span class="line"></span><br><span class="line">ab -n <span class="number">100</span> -c <span class="number">100</span> localhost:<span class="number">8080</span>/add</span><br><span class="line"></span><br><span class="line">curl localhost:<span class="number">8080</span>/stat</span><br></pre></td></tr></table></figure>

<p><strong>使用 ThreadLocal</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; c = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Integer <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">__add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        c.set(c.get() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">stat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        __add();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">使用ThreadLocal</span><br><span class="line"></span><br><span class="line">ab -n 10000 -c 100 localhost:8080/add</span><br><span class="line"></span><br><span class="line">curl localhost:8080/stat</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580315440114-b0080698-a2fd-4443-8558-2487fb855568.png#align=left&display=inline&height=569&name=image.png&originHeight=1138&originWidth=2032&size=281450&status=done&style=none&width=1016"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>基于线程池模型 synchronize（排队操作很<strong>危险</strong>）</li>
<li>用 ThreadLocal 收集数据很快且安全</li>
<li>思考：如何在多个 ThreadLocal 中收集数据？</li>
</ul>
<h3 id="2-5-ThreadLocal-场景分析——减少同步-10-10"><a href="#2-5-ThreadLocal-场景分析——减少同步-10-10" class="headerlink" title="2-5 ThreadLocal 场景分析——减少同步 (10:10)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21054">2-5 ThreadLocal 场景分析——减少同步 (10:10)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580316239145-3cf3dcf9-ffc9-4593-85a4-7bf84d7cce54.png#align=left&display=inline&height=572&name=image.png&originHeight=1144&originWidth=2044&size=397731&status=done&style=none&width=1022"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> HashSet&lt;Val&lt;Integer&gt;&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addSet</span><span class="params">(Val&lt;Integer&gt; v)</span> &#123;</span><br><span class="line">        set.add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Val&lt;Integer&gt;&gt; c = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;Val&lt;Integer&gt;&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Val&lt;Integer&gt; <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            Val&lt;Integer&gt; v = <span class="keyword">new</span> <span class="title class_">Val</span>&lt;&gt;();</span><br><span class="line">            v.set(<span class="number">0</span>);</span><br><span class="line">            addSet(v);</span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">__add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        Val&lt;Integer&gt; v = c.get();</span><br><span class="line">        v.set(v.get() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/stat&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">stat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> set.stream().map(x -&gt; x.get()).reduce((a,x) -&gt; a+x).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/add&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">add</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        __add();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">使用ThreadLocal</span><br><span class="line"></span><br><span class="line">ab -n 10000 -c 100 localhost:8080/add</span><br><span class="line"></span><br><span class="line">ab -n 10000 -c 200 localhost:8080/add</span><br><span class="line"></span><br><span class="line">curl localhost:8080/stat</span><br></pre></td></tr></table></figure>

<h4 id="问题：set-add-v-为什么会有线程安全问题"><a href="#问题：set-add-v-为什么会有线程安全问题" class="headerlink" title="问题：set.add(v); 为什么会有线程安全问题"></a>问题：set.add(v); 为什么会有线程安全问题</h4><p>set 是所有线程共享的，是个临界区</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580319954534-1c4b8181-7003-4f21-ab7e-22d9148c42c4.png#align=left&display=inline&height=561&name=image.png&originHeight=1122&originWidth=2038&size=217511&status=done&style=none&width=1019"></p>
<h2 id="第-3-章-【极客视角】大神们怎么用-ThreadLocal-的"><a href="#第-3-章-【极客视角】大神们怎么用-ThreadLocal-的" class="headerlink" title="第 3 章 【极客视角】大神们怎么用 ThreadLocal 的"></a>第 3 章 【极客视角】大神们怎么用 ThreadLocal 的</h2><blockquote>
<p>挑选了 3 个 Java 领域影响深远的应用，Spring&#x2F;Mybatis&#x2F;Quartz 中使用到 ThreadLocal 的源码，理解大神们在思考什么，为什么会用到 ThreadLocal。</p>
</blockquote>
<h3 id="3-1-源码分析-1-Quartz-SimpleSemaphore-06-42"><a href="#3-1-源码分析-1-Quartz-SimpleSemaphore-06-42" class="headerlink" title=" 3-1 源码分析 1-Quartz SimpleSemaphore (06:42)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21055"> 3-1 源码分析 1-Quartz SimpleSemaphore (06:42)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580320024738-8c1014f4-f24a-4274-b43a-74f006e47871.png#align=left&display=inline&height=572&name=image.png&originHeight=1144&originWidth=2048&size=464595&status=done&style=none&width=1024"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580480597184-8bb00b4d-e4f0-4796-8661-c7776d4f4f69.png#align=left&display=inline&height=570&name=image.png&originHeight=1140&originWidth=2050&size=268257&status=done&style=none&width=1025"></p>
<h3 id="3-2-源码分析-2-Mybatis-框架保持连接池线程一致-04-46"><a href="#3-2-源码分析-2-Mybatis-框架保持连接池线程一致-04-46" class="headerlink" title=" 3-2 源码分析 2 Mybatis 框架保持连接池线程一致 (04:46)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21056"> 3-2 源码分析 2 Mybatis 框架保持连接池线程一致 (04:46)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580480656665-5c6b3bd2-7bbf-4f2f-9d79-1ebe7c9ddc5d.png#align=left&display=inline&height=569&name=image.png&originHeight=1138&originWidth=2046&size=238863&status=done&style=none&width=1023"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580480753798-b8dec9f9-38ac-47ee-918c-a8ff7a616f15.png#align=left&display=inline&height=562&name=image.png&originHeight=1124&originWidth=2014&size=592110&status=done&style=none&width=1007"></p>
<p>A（Atomic)）原子性，操作不可分割。<br>C（Consistency）一致性，任何时刻数据都能保持一致。<br>I（Isolation）隔离性，多事务并发执行的时序不影响结果。<br>D（Durability）持久性，对数据结构的存储是永久的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580480809105-a612ddc6-692b-404d-9b57-7f06932b6714.png#align=left&display=inline&height=576&name=image.png&originHeight=1152&originWidth=2052&size=587009&status=done&style=none&width=1026"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580480908510-db46cae0-7703-4ed9-a8f6-73bcc643f3f1.png#align=left&display=inline&height=561&name=image.png&originHeight=1122&originWidth=2038&size=339832&status=done&style=none&width=1019"></p>
<h3 id="3-3-源码分析-03-Spring-框架对分布式事务的支持-04-03"><a href="#3-3-源码分析-03-Spring-框架对分布式事务的支持-04-03" class="headerlink" title=" 3-3 源码分析 03 Spring 框架对分布式事务的支持 (04:03)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21057"> 3-3 源码分析 03 Spring 框架对分布式事务的支持 (04:03)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580480937973-1f716eb7-0cac-4e20-9859-84a14022418a.png#align=left&display=inline&height=576&name=image.png&originHeight=1152&originWidth=2060&size=309429&status=done&style=none&width=1030"></p>
<p>A（Atomic)）原子性，操作不可分割。<br>C（Consistency）一致性，任何时刻数据都能保持一致。<br>I（Isolation）隔离性，多事务并发执行的时序不影响结果。<br>D（Durability）持久性，对数据结构的存储是永久的。</p>
<p>A：要么发生，要么不发生<br>C：要做对，做错了不算<br>I：同时发生两个事务，两个事务的结果能够叠加的一致，同时扣款<br>D：数据要被持久化下来</p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580480961117-7fc34b99-03cc-415d-9e70-bbcfae2fa3ba.png#align=left&display=inline&height=571&name=image.png&originHeight=1142&originWidth=2028&size=625709&status=done&style=none&width=1014"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580481510627-18f0f872-f9ac-47e1-8ea3-b741be7cb046.png#align=left&display=inline&height=570&name=image.png&originHeight=1140&originWidth=2052&size=762508&status=done&style=none&width=1026"></p>
<p>context 环境</p>
<h2 id="第-4-章-【设计者视角】源码级实现-amp-源码分析"><a href="#第-4-章-【设计者视角】源码级实现-amp-源码分析" class="headerlink" title="第 4 章 【设计者视角】源码级实现&amp;源码分析"></a>第 4 章 【设计者视角】源码级实现&amp;源码分析</h2><h3 id="4-1-实现自己的-ThreadLocal-12-16"><a href="#4-1-实现自己的-ThreadLocal-12-16" class="headerlink" title="4-1 实现自己的 ThreadLocal (12:16)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21058">4-1 实现自己的 ThreadLocal (12:16)</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享空间</span></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;Thread, HashMap&lt;MyThreadLocal&lt;?&gt;, Object&gt;&gt; threadLocalMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">static</span> HashMap&lt;MyThreadLocal&lt;?&gt;, Object&gt; getMap() &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 判断threadLocalMap是否包含当前线程，不包含就put进去</span></span><br><span class="line">        <span class="keyword">if</span> (!threadLocalMap.containsKey(thread)) &#123;</span><br><span class="line">            threadLocalMap.put(thread, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;MyThreadLocal&lt;?&gt;,Object&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前thread的map</span></span><br><span class="line">        <span class="keyword">return</span> threadLocalMap.get(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;MyThreadLocal&lt;?&gt;, Object&gt; map = getMap();</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(<span class="built_in">this</span>)) &#123;</span><br><span class="line">            map.put(<span class="built_in">this</span>, initialValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T v)</span> &#123;</span><br><span class="line">        HashMap&lt;MyThreadLocal&lt;?&gt;, Object&gt; map = getMap();</span><br><span class="line">        map.put(<span class="built_in">this</span>, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> MyThreadLocal&lt;Long&gt; v = <span class="keyword">new</span> <span class="title class_">MyThreadLocal</span>&lt;Long&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Long <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Thread.currentThread().getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                System.out.println(v.get());</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580483675589-0a208adc-46ae-4fff-9ebd-fc64c02dc357.png#align=left&display=inline&height=568&name=image.png&originHeight=1136&originWidth=2038&size=229596&status=done&style=none&width=1019"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580483873261-c5a9c11e-4bce-4036-ba6b-83c1be8d2354.png#align=left&display=inline&height=562&name=image.png&originHeight=1124&originWidth=2010&size=720211&status=done&style=none&width=1005"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThreadLocal</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">atomic</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自增</span></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">threadLocalHash</span> <span class="operator">=</span> atomic.addAndGet(<span class="number">0x61c88647</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享空间</span></span><br><span class="line">    <span class="keyword">static</span> HashMap&lt;Thread, HashMap&lt;Integer, Object&gt;&gt; threadLocalMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">static</span> HashMap&lt;Integer, Object&gt; <span class="title function_">getMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="comment">// 判断threadLocalMap是否包含当前线程，不包含就put进去</span></span><br><span class="line">        <span class="keyword">if</span> (!threadLocalMap.containsKey(thread)) &#123;</span><br><span class="line">            threadLocalMap.put(thread, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Object&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取当前thread的map</span></span><br><span class="line">        <span class="keyword">return</span> threadLocalMap.get(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Object&gt; map = getMap();</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(<span class="built_in">this</span>.threadLocalHash)) &#123;</span><br><span class="line">            map.put(<span class="built_in">this</span>.threadLocalHash, initialValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(<span class="built_in">this</span>.threadLocalHash);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T v)</span> &#123;</span><br><span class="line">        HashMap&lt;Integer, Object&gt; map = getMap();</span><br><span class="line">        map.put(<span class="built_in">this</span>.threadLocalHash, v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484136537-c1e80f1c-939c-46af-822b-125c74f57e87.png#align=left&display=inline&height=562&name=image.png&originHeight=1124&originWidth=2030&size=169190&status=done&style=none&width=1015"></p>
<h3 id="4-2-选学-HashTable-03-56"><a href="#4-2-选学-HashTable-03-56" class="headerlink" title="4-2 选学 HashTable (03:56)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21059">4-2 选学 HashTable (03:56)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484171303-3d7e5aad-5624-4c77-a432-d53884ae6737.png#align=left&display=inline&height=565&name=image.png&originHeight=1130&originWidth=2052&size=232707&status=done&style=none&width=1026"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484200988-5e508785-cccc-487a-ad6d-698632751a1d.png#align=left&display=inline&height=566&name=image.png&originHeight=1132&originWidth=2048&size=239436&status=done&style=none&width=1024"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484218568-c47dc413-cbe5-43e2-a3f6-dfd9eec12227.png#align=left&display=inline&height=569&name=image.png&originHeight=1138&originWidth=2036&size=291317&status=done&style=none&width=1018"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484285123-0481a94d-58fb-49a9-a2c4-5b8335bed850.png#align=left&display=inline&height=563&name=image.png&originHeight=1126&originWidth=2032&size=446459&status=done&style=none&width=1016"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484301949-0ed0c2c5-a3ee-401a-8542-732db42768d4.png#align=left&display=inline&height=569&name=image.png&originHeight=1138&originWidth=2030&size=459263&status=done&style=none&width=1015"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484324800-3a373548-7256-4ca1-97fa-46820e84226e.png#align=left&display=inline&height=566&name=image.png&originHeight=1132&originWidth=2018&size=591886&status=done&style=none&width=1009"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484354861-5a2a1f16-43f7-4717-8bec-d27620b84862.png#align=left&display=inline&height=563&name=image.png&originHeight=1126&originWidth=2028&size=292298&status=done&style=none&width=1014"></p>
<h3 id="4-3-ThreadLocal-源码分析-13-40"><a href="#4-3-ThreadLocal-源码分析-13-40" class="headerlink" title="4-3 ThreadLocal 源码分析 (13:40)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21060">4-3 ThreadLocal 源码分析 (13:40)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484527702-28ef0410-e0a0-46f5-adc2-5a90bfd24970.png#align=left&display=inline&height=557&name=image.png&originHeight=1114&originWidth=2020&size=107860&status=done&style=none&width=1010"><br><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484551012-d5ea7531-350f-417c-891c-6c4ba5263ce1.png#align=left&display=inline&height=573&name=image.png&originHeight=1146&originWidth=2046&size=213460&status=done&style=none&width=1023"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580484900463-724b011e-2896-4b41-9e64-d08e64cc3d2c.png#align=left&display=inline&height=573&name=image.png&originHeight=1146&originWidth=2014&size=240650&status=done&style=none&width=1007"></p>
<h2 id="第-5-章-全课总结"><a href="#第-5-章-全课总结" class="headerlink" title="第 5 章 全课总结"></a>第 5 章 全课总结</h2><blockquote>
<p>ThreadLocal 只是一个简单的数据结构，却引出了这么多问题，可见真理常常隐藏在容易忽视微小的地方，优秀的程序员不仅仅要大局观强，还更加需要磨砺细节——和老师一起思考未来应该怎样学习？</p>
</blockquote>
<h3 id="5-1-总结-04-19"><a href="#5-1-总结-04-19" class="headerlink" title="5-1 总结 (04:19)"></a><a target="_blank" rel="noopener" href="https://www.imooc.com/video/21061">5-1 总结 (04:19)</a></h3><p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580485337565-f31c40ff-b84a-4f33-8ff8-b628202e48cb.png#align=left&display=inline&height=567&name=image.png&originHeight=1134&originWidth=2026&size=420477&status=done&style=none&width=1013"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580485355830-3090a27d-a641-4676-8fad-220822d83e49.png#align=left&display=inline&height=576&name=image.png&originHeight=1152&originWidth=2040&size=413193&status=done&style=none&width=1020"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580485395229-eb215f77-bc45-478d-899f-3460dad5e68f.png#align=left&display=inline&height=568&name=image.png&originHeight=1136&originWidth=2048&size=312242&status=done&style=none&width=1024"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2020/png/576791/1580485432351-6d32dcca-bba4-4724-9ef2-c128268f4c86.png#align=left&display=inline&height=566&name=image.png&originHeight=1132&originWidth=2054&size=241653&status=done&style=none&width=1027"></p>
<h4 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h4><ul>
<li>无论将来到什么样的高度，永远认为自己是个菜鸡：总有比我们厉害的大牛，永远都去学习</li>
<li>保持兴趣，体会乐趣：投入在工作上的时间是很多的，在工作上一定要保持兴趣</li>
<li>技术创造是有价值的（切记）：自己尝试去创造，尝试学新东西去用</li>
</ul>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote>
<p>首先感谢大佬的课程分享，通过课程学到了很多东西</p>
<p>另外是我有个公众号，叫《骇客与画家》，欢迎大家来关注 😆</p>
<p>骇客与画家，名称来自书籍《黑客与画家》，画家学习绘画的方法是动手去画，骇客学习编程的方法也是动手去实践</p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/576791/1577433516700-202fdc3d-5019-4324-ae77-b7be287cc9a7.png#align=left&display=inline&height=500&name=image.png&originHeight=500&originWidth=900&size=177089&status=done&style=none&width=900"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何使用两个线程交替打印1-100？"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/19/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100%EF%BC%9F/"
    >如何使用两个线程交替打印1--100？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/01/19/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B01-100%EF%BC%9F/" class="article-date">
  <time datetime="2020-01-18T16:09:31.000Z" itemprop="datePublished">2020-01-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Java_stud/article/details/82347135">https://blog.csdn.net/Java_stud/article/details/82347135</a></p>
<p>作者：<a target="_blank" rel="noopener" href="https://me.csdn.net/Java_stud">四两数字先生</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20200120200518.png"></p>
<p>wait()：令当前线程放弃 CPU 的资源，使别的线程可以访问共享的资源，而当前的线程排队等待再次对资源的访问</p>
<p>notify()：唤醒正在排队的等待的同步资源的线程，</p>
<p>notifyAll()：唤醒正在排队等待的所有的线程</p>
<p>在 java.lang.Object：</p>
<p>用这三个方法的注意点：  同步方法或者同步代码块里</p>
<p>使用两个线程打印1—-100.线程1和线程2交替打印</p>
<p>分析： </p>
<ol>
<li>我先使用两个线程打印1—100，（先不用交替打印）</li>
<li>然后在使用上面的三个方法，在代码里添加</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrintNum</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//唤醒wait()的一个或者所有线程</span></span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span> (num &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + num);</span><br><span class="line">                    num++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">PrintNum</span> <span class="variable">printNum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintNum</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printNum);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(printNum);</span><br><span class="line"></span><br><span class="line">        t1.setName(<span class="string">&quot;甲&quot;</span>);</span><br><span class="line">        t2.setName(<span class="string">&quot;乙&quot;</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>运行效果：</strong></p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20200120200159.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-用好Java中的枚举，真的没有那么简单！"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/18/%E7%94%A8%E5%A5%BDJava%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%81/"
    >用好Java中的枚举，真的没有那么简单！</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/01/18/%E7%94%A8%E5%A5%BDJava%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE%EF%BC%8C%E7%9C%9F%E7%9A%84%E6%B2%A1%E6%9C%89%E9%82%A3%E4%B9%88%E7%AE%80%E5%8D%95%EF%BC%81/" class="article-date">
  <time datetime="2020-01-17T17:35:31.000Z" itemprop="datePublished">2020-01-18</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>最近重看 Java 枚举，看到这篇觉得还不错的文章，于是简单翻译和完善了一些内容，分享给大家，希望你们也能有所收获。另外，不要忘了文末还有补充哦！</p>
<p>ps: 这里发一篇枚举的文章，也是因为后面要发一篇非常实用的关于 SpringBoot 全局异常处理的比较好的实践里面就用到了枚举。</p>
<p>这篇文章由 JavaGuide 翻译，</p>
<p>公众号: JavaGuide,原文地址：<a target="_blank" rel="noopener" href="https://www.baeldung.com/a-guide-to-java-enums">https://www.baeldung.com/a-guide-to-java-enums</a> 。</p>
<p>转载请注明上面这段文字。</p>
</blockquote>
<h2 id="1-概览"><a href="#1-概览" class="headerlink" title="1.概览"></a><strong>1.概览</strong></h2><p>在本文中，我们将看到什么是 Java 枚举，它们解决了哪些问题以及如何在实践中使用  Java 枚举实现一些设计模式。</p>
<p>enum关键字在 java5 中引入，表示一种特殊类型的类，其总是继承java.lang.Enum类，更多内容可以自行查看其官方文档。</p>
<p>枚举在很多时候会和常量拿来对比，可能因为本身我们大量实际使用枚举的地方就是为了替代常量。那么这种方式由什么优势呢？</p>
<p><strong>以这种方式定义的常量使代码更具可读性，允许进行编译时检查，预先记录可接受值的列表，并避免由于传入无效值而引起的意外行为。</strong></p>
<p>下面示例定义一个简单的枚举类型 pizza 订单的状态，共有三种 ORDERED, READY, DELIVERED状态:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> shuang.kou.enumdemo.enumtest;</span><br><span class="line"></span><br><span class="line">publicenum PizzaStatus &#123;</span><br><span class="line">    ORDERED,</span><br><span class="line">    READY,</span><br><span class="line">    DELIVERED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>简单来说，我们通过上面的代码避免了定义常量，我们将所有和 pizza 订单的状态的常量都统一放到了一个枚举类型里面。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(PizzaStatus.ORDERED.name());//ORDERED</span><br><span class="line">System.out.println(PizzaStatus.ORDERED);//ORDERED</span><br><span class="line">System.out.println(PizzaStatus.ORDERED.name().getClass());//class java.lang.String</span><br><span class="line">System.out.println(PizzaStatus.ORDERED.getClass());//class shuang.kou.enumdemo.enumtest.PizzaStatus</span><br></pre></td></tr></table></figure>

<h2 id="2-自定义枚举方法"><a href="#2-自定义枚举方法" class="headerlink" title="2.自定义枚举方法"></a><strong>2.自定义枚举方法</strong></h2><p>现在我们对枚举是什么以及如何使用它们有了基本的了解，让我们通过在枚举上定义一些额外的API方法，将上一个示例提升到一个新的水平：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">publicclass Pizza &#123;</span><br><span class="line">    <span class="keyword">private</span> PizzaStatus status;</span><br><span class="line">    publicenum PizzaStatus &#123;</span><br><span class="line">        ORDERED,</span><br><span class="line">        READY,</span><br><span class="line">        DELIVERED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDeliverable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (getStatus() == PizzaStatus.READY) &#123;</span><br><span class="line">            returntrue;</span><br><span class="line">        &#125;</span><br><span class="line">        returnfalse;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// Methods that set and get the status variable.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-使用-x3D-x3D-比较枚举类型"><a href="#3-使用-x3D-x3D-比较枚举类型" class="headerlink" title="3.使用 &#x3D;&#x3D; 比较枚举类型"></a><strong>3.使用 &#x3D;&#x3D; 比较枚举类型</strong></h2><p>由于枚举类型确保JVM中仅存在一个常量实例，因此我们可以安全地使用“ &#x3D;&#x3D;”运算符比较两个变量，如上例所示；此外，“ &#x3D;&#x3D;”运算符可提供编译时和运行时的安全性。</p>
<p>首先，让我们看一下以下代码段中的运行时安全性，其中“ &#x3D;&#x3D;”运算符用于比较状态，并且如果两个值均为null 都不会引发 NullPointerException。相反，如果使用equals方法，将抛出 NullPointerException：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(testPz.getStatus().equals(Pizza.PizzaStatus.DELIVERED));</span><br><span class="line">if(testPz.getStatus() == Pizza.PizzaStatus.DELIVERED);</span><br></pre></td></tr></table></figure>

<p>对于编译时安全性，我们看另一个示例，两个不同枚举类型进行比较，使用equal方法比较结果确定为true，因为getStatus方法的枚举值与另一个类型枚举值一致，但逻辑上应该为false。这个问题可以使用&#x3D;&#x3D;操作符避免。因为编译器会表示类型不兼容错误：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(testPz.getStatus().equals(TestColor.GREEN));</span><br><span class="line">if(testPz.getStatus() == TestColor.GREEN);</span><br></pre></td></tr></table></figure>

<h2 id="4-在-switch-语句中使用枚举类型"><a href="#4-在-switch-语句中使用枚举类型" class="headerlink" title="4.在 switch 语句中使用枚举类型"></a><strong>4.在 switch 语句中使用枚举类型</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int getDeliveryTimeInDays() &#123;</span><br><span class="line">    switch (status) &#123;</span><br><span class="line">        case ORDERED: return5;</span><br><span class="line">        case READY: return2;</span><br><span class="line">        case DELIVERED: return0;</span><br><span class="line">    &#125;</span><br><span class="line">    return0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-枚举类型的属性-方法和构造函数"><a href="#5-枚举类型的属性-方法和构造函数" class="headerlink" title="5.枚举类型的属性,方法和构造函数"></a><strong>5.枚举类型的属性,方法和构造函数</strong></h2><blockquote>
<p>“</p>
<p>文末有我(JavaGuide)的补充。</p>
<p>”</p>
</blockquote>
<p>你可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p>
<p>下面，让我们扩展上面的示例，实现从比萨的一个阶段到另一个阶段的过渡，并了解如何摆脱之前使用的if语句和switch语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">publicclass Pizza &#123;</span><br><span class="line"> </span><br><span class="line">    private PizzaStatus status;</span><br><span class="line">    publicenum PizzaStatus &#123;</span><br><span class="line">        ORDERED (5)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isOrdered() &#123;</span><br><span class="line">                returntrue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        READY (2)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isReady() &#123;</span><br><span class="line">                returntrue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        DELIVERED (0)&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean isDelivered() &#123;</span><br><span class="line">                returntrue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        privateint timeToDelivery;</span><br><span class="line"> </span><br><span class="line">        public boolean isOrdered() &#123;returnfalse;&#125;</span><br><span class="line"> </span><br><span class="line">        public boolean isReady() &#123;returnfalse;&#125;</span><br><span class="line"> </span><br><span class="line">        public boolean isDelivered()&#123;returnfalse;&#125;</span><br><span class="line"> </span><br><span class="line">        public int getTimeToDelivery() &#123;</span><br><span class="line">            return timeToDelivery;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        PizzaStatus (int timeToDelivery) &#123;</span><br><span class="line">            this.timeToDelivery = timeToDelivery;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean isDeliverable() &#123;</span><br><span class="line">        returnthis.status.isReady();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void printTimeToDeliver() &#123;</span><br><span class="line">        System.out.println(&quot;Time to delivery is &quot; +</span><br><span class="line">          this.getStatus().getTimeToDelivery());</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // Methods that set and get the status variable.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这段代码展示它是如何 work 的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void givenPizaOrder_whenReady_thenDeliverable() &#123;</span><br><span class="line">    Pizza testPz = new Pizza();</span><br><span class="line">    testPz.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line">    assertTrue(testPz.isDeliverable());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-EnumSet-and-EnumMap"><a href="#6-EnumSet-and-EnumMap" class="headerlink" title="6.EnumSet and EnumMap"></a><strong>6.EnumSet and EnumMap</strong></h2><h3 id="6-1-EnumSet"><a href="#6-1-EnumSet" class="headerlink" title="6.1. EnumSet"></a>6.1. EnumSet</h3><p><code>EnumSet</code> 是一种专门为枚举类型所设计的 <code>Set</code> 类型。</p>
<p>与<code>HashSet</code>相比，由于使用了内部位向量表示，因此它是特定 <code>Enum</code> 常量集的非常有效且紧凑的表示形式。</p>
<p>它提供了类型安全的替代方法，以替代传统的基于int的“位标志”，使我们能够编写更易读和易于维护的简洁代码。</p>
<p><code>EnumSet</code> 是抽象类，其有两个实现：<code>RegularEnumSet</code> 、<code>JumboEnumSet</code>，选择哪一个取决于实例化时枚举中常量的数量。</p>
<p>在很多场景中的枚举常量集合操作（如：取子集、增加、删除、<code>containsAll</code>和<code>removeAll</code>批操作）使用<code>EnumSet</code>非常合适；如果需要迭代所有可能的常量则使用<code>Enum.values()</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">publicclass Pizza &#123;</span><br><span class="line"> </span><br><span class="line">    privatestatic EnumSet&lt;PizzaStatus&gt; undeliveredPizzaStatuses =</span><br><span class="line">      EnumSet.of(PizzaStatus.ORDERED, PizzaStatus.READY);</span><br><span class="line"> </span><br><span class="line">    private PizzaStatus status;</span><br><span class="line"> </span><br><span class="line">    publicenum PizzaStatus &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public boolean isDeliverable() &#123;</span><br><span class="line">        returnthis.status.isReady();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void printTimeToDeliver() &#123;</span><br><span class="line">        System.out.println(&quot;Time to delivery is &quot; +</span><br><span class="line">          this.getStatus().getTimeToDelivery() + &quot; days&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static List&lt;Pizza&gt; getAllUndeliveredPizzas(List&lt;Pizza&gt; input) &#123;</span><br><span class="line">        return input.stream().filter(</span><br><span class="line">          (s) -&gt; undeliveredPizzaStatuses.contains(s.getStatus()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void deliver() &#123;</span><br><span class="line">        if (isDeliverable()) &#123;</span><br><span class="line">            PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()</span><br><span class="line">              .deliver(this);</span><br><span class="line">            this.setStatus(PizzaStatus.DELIVERED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // Methods that set and get the status variable.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的测试演示了展示了 <code>EnumSet</code> 在某些场景下的强大功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void givenPizaOrders_whenRetrievingUnDeliveredPzs_thenCorrectlyRetrieved() &#123;</span><br><span class="line">    List&lt;Pizza&gt; pzList = new ArrayList&lt;&gt;();</span><br><span class="line">    Pizza pz1 = new Pizza();</span><br><span class="line">    pz1.setStatus(Pizza.PizzaStatus.DELIVERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz2 = new Pizza();</span><br><span class="line">    pz2.setStatus(Pizza.PizzaStatus.ORDERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz3 = new Pizza();</span><br><span class="line">    pz3.setStatus(Pizza.PizzaStatus.ORDERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz4 = new Pizza();</span><br><span class="line">    pz4.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line"> </span><br><span class="line">    pzList.add(pz1);</span><br><span class="line">    pzList.add(pz2);</span><br><span class="line">    pzList.add(pz3);</span><br><span class="line">    pzList.add(pz4);</span><br><span class="line"> </span><br><span class="line">    List&lt;Pizza&gt; undeliveredPzs = Pizza.getAllUndeliveredPizzas(pzList);</span><br><span class="line">    assertTrue(undeliveredPzs.size() == 3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-EnumMap"><a href="#6-2-EnumMap" class="headerlink" title="6.2. EnumMap"></a>6.2. EnumMap</h3><p><code>EnumMap</code>是一个专门化的映射实现，用于将枚举常量用作键。与对应的 <code>HashMap</code> 相比，它是一个高效紧凑的实现，并且在内部表示为一个数组:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EnumMap&lt;Pizza.PizzaStatus, Pizza&gt; map;</span><br></pre></td></tr></table></figure>

<p>让我们快速看一个真实的示例，该示例演示如何在实践中使用它：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">publicstatic EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt;</span><br><span class="line">  groupPizzaByStatus(List&lt;Pizza&gt; pizzaList) &#123;</span><br><span class="line">    EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt; pzByStatus =</span><br><span class="line">      new EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt;(PizzaStatus.class);</span><br><span class="line">     </span><br><span class="line">    for (Pizza pz : pizzaList) &#123;</span><br><span class="line">        PizzaStatus status = pz.getStatus();</span><br><span class="line">        if (pzByStatus.containsKey(status)) &#123;</span><br><span class="line">            pzByStatus.get(status).add(pz);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            List&lt;Pizza&gt; newPzList = new ArrayList&lt;Pizza&gt;();</span><br><span class="line">            newPzList.add(pz);</span><br><span class="line">            pzByStatus.put(status, newPzList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pzByStatus;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的测试演示了展示了 <code>EnumMap</code> 在某些场景下的强大功能：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void givenPizaOrders_whenGroupByStatusCalled_thenCorrectlyGrouped() &#123;</span><br><span class="line">    List&lt;Pizza&gt; pzList = new ArrayList&lt;&gt;();</span><br><span class="line">    Pizza pz1 = new Pizza();</span><br><span class="line">    pz1.setStatus(Pizza.PizzaStatus.DELIVERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz2 = new Pizza();</span><br><span class="line">    pz2.setStatus(Pizza.PizzaStatus.ORDERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz3 = new Pizza();</span><br><span class="line">    pz3.setStatus(Pizza.PizzaStatus.ORDERED);</span><br><span class="line"> </span><br><span class="line">    Pizza pz4 = new Pizza();</span><br><span class="line">    pz4.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line"> </span><br><span class="line">    pzList.add(pz1);</span><br><span class="line">    pzList.add(pz2);</span><br><span class="line">    pzList.add(pz3);</span><br><span class="line">    pzList.add(pz4);</span><br><span class="line"> </span><br><span class="line">    EnumMap&lt;Pizza.PizzaStatus,List&lt;Pizza&gt;&gt; map = Pizza.groupPizzaByStatus(pzList);</span><br><span class="line">    assertTrue(map.get(Pizza.PizzaStatus.DELIVERED).size() == 1);</span><br><span class="line">    assertTrue(map.get(Pizza.PizzaStatus.ORDERED).size() == 2);</span><br><span class="line">    assertTrue(map.get(Pizza.PizzaStatus.READY).size() == 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-通过枚举实现一些设计模式"><a href="#7-通过枚举实现一些设计模式" class="headerlink" title="7. 通过枚举实现一些设计模式"></a><strong>7. 通过枚举实现一些设计模式</strong></h2><h3 id="7-1-单例模式"><a href="#7-1-单例模式" class="headerlink" title="7.1 单例模式"></a>7.1 单例模式</h3><p>通常，使用类实现 Singleton 模式并非易事，枚举提供了一种实现单例的简便方法。</p>
<p>《Effective Java 》和《Java与模式》都非常推荐这种方式，使用这种方式方式实现枚举可以有什么好处呢？</p>
<p>《Effective Java》</p>
<blockquote>
<p>“</p>
<p>这种方法在功能上与公有域方法相近，但是它更加简洁，无偿提供了序列化机制，绝对防止多次实例化，即使是在面对复杂序列化或者反射攻击的时候。虽然这种方法还没有广泛采用，但是单元素的枚举类型已经成为实现 Singleton的最佳方法。—-《Effective Java 中文版 第二版》</p>
<p>”</p>
</blockquote>
<p>《Java与模式》</p>
<blockquote>
<p>“</p>
<p>《Java与模式》中，作者这样写道，使用枚举来实现单实例控制会更加简洁，而且无偿地提供了序列化机制，并由JVM从根本上提供保障，绝对防止多次实例化，是更简洁、高效、安全的实现单例的方式。</p>
<p>”</p>
</blockquote>
<p>下面的代码段显示了如何使用枚举实现单例模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">publicenum PizzaDeliverySystemConfiguration &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    PizzaDeliverySystemConfiguration() &#123;</span><br><span class="line">        // Initialization configuration which involves</span><br><span class="line">        // overriding defaults like delivery strategy</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    private PizzaDeliveryStrategy deliveryStrategy = PizzaDeliveryStrategy.NORMAL;</span><br><span class="line"> </span><br><span class="line">    public static PizzaDeliverySystemConfiguration getInstance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public PizzaDeliveryStrategy getDeliveryStrategy() &#123;</span><br><span class="line">        return deliveryStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用呢？请看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PizzaDeliveryStrategy deliveryStrategy = PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy();</span><br></pre></td></tr></table></figure>

<p>通过 <code>PizzaDeliverySystemConfiguration.getInstance()</code> 获取的就是单例的 <code>PizzaDeliverySystemConfiguration</code></p>
<h3 id="7-2-策略模式"><a href="#7-2-策略模式" class="headerlink" title="7.2 策略模式"></a>7.2 策略模式</h3><p>通常，策略模式由不同类实现同一个接口来实现的。</p>
<p>这也就意味着添加新策略意味着添加新的实现类。使用枚举，可以轻松完成此任务，添加新的实现意味着只定义具有某个实现的另一个实例。</p>
<p>下面的代码段显示了如何使用枚举实现策略模式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">publicenum PizzaDeliveryStrategy &#123;</span><br><span class="line">    EXPRESS &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void deliver(Pizza pz) &#123;</span><br><span class="line">            System.out.println(&quot;Pizza will be delivered in express mode&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    NORMAL &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void deliver(Pizza pz) &#123;</span><br><span class="line">            System.out.println(&quot;Pizza will be delivered in normal mode&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    public abstract void deliver(Pizza pz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给 <code>Pizza</code>增加下面的方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void deliver() &#123;</span><br><span class="line">    if (isDeliverable()) &#123;</span><br><span class="line">        PizzaDeliverySystemConfiguration.getInstance().getDeliveryStrategy()</span><br><span class="line">          .deliver(this);</span><br><span class="line">        this.setStatus(PizzaStatus.DELIVERED);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何使用呢？请看下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void givenPizaOrder_whenDelivered_thenPizzaGetsDeliveredAndStatusChanges() &#123;</span><br><span class="line">    Pizza pz = new Pizza();</span><br><span class="line">    pz.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line">    pz.deliver();</span><br><span class="line">    assertTrue(pz.getStatus() == Pizza.PizzaStatus.DELIVERED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Java-8-与枚举"><a href="#8-Java-8-与枚举" class="headerlink" title="8. Java 8 与枚举"></a><strong>8. Java 8 与枚举</strong></h2><p>Pizza 类可以用Java 8重写，您可以看到方法 lambda 和Stream API如何使 <code>getAllUndeliveredPizzas（）</code>和<code>groupPizzaByStatus（）</code>方法变得如此简洁：</p>
<p><code>getAllUndeliveredPizzas（）</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Pizza&gt; <span class="title function_">getAllUndeliveredPizzas</span><span class="params">(List&lt;Pizza&gt; input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> input.stream().filter(</span><br><span class="line">      (s) -&gt; !deliveredPizzaStatuses.contains(s.getStatus()))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>groupPizzaByStatus（）</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">publicstatic EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt;</span><br><span class="line">  <span class="title function_">groupPizzaByStatus</span><span class="params">(List&lt;Pizza&gt; pzList)</span> &#123;</span><br><span class="line">    EnumMap&lt;PizzaStatus, List&lt;Pizza&gt;&gt; map = pzList.stream().collect(</span><br><span class="line">      Collectors.groupingBy(Pizza::getStatus,</span><br><span class="line">      () -&gt; <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;&gt;(PizzaStatus.class), Collectors.toList()));</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Enum-类型的-JSON-表现形式"><a href="#9-Enum-类型的-JSON-表现形式" class="headerlink" title="9. Enum 类型的 JSON 表现形式"></a><strong>9. Enum 类型的 JSON 表现形式</strong></h2><p>使用Jackson库，可以将枚举类型的JSON表示为POJO。下面的代码段显示了可以用于同一目的的Jackson批注：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonFormat(shape = JsonFormat.Shape.OBJECT)</span></span><br><span class="line">publicenum PizzaStatus &#123;</span><br><span class="line">    ORDERED (<span class="number">5</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOrdered</span><span class="params">()</span> &#123;</span><br><span class="line">            returntrue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    READY (<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;</span><br><span class="line">            returntrue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DELIVERED (<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDelivered</span><span class="params">()</span> &#123;</span><br><span class="line">            returntrue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    privateint timeToDelivery;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isOrdered</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReady</span><span class="params">()</span> &#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isDelivered</span><span class="params">()</span>&#123;<span class="keyword">return</span> <span class="literal">false</span>;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@JsonProperty(&quot;timeToDelivery&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getTimeToDelivery</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> timeToDelivery;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">PizzaStatus</span> <span class="params">(<span class="type">int</span> timeToDelivery)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.timeToDelivery = timeToDelivery;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以按如下方式使用 <code>Pizza</code> 和 <code>PizzaStatus</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Pizza pz = new Pizza();</span><br><span class="line">pz.setStatus(Pizza.PizzaStatus.READY);</span><br><span class="line">System.out.println(Pizza.getJsonString(pz));</span><br></pre></td></tr></table></figure>

<p>生成 Pizza 状态以以下JSON展示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;status&quot; : &#123;</span><br><span class="line">    &quot;timeToDelivery&quot; : 2,</span><br><span class="line">    &quot;ready&quot; : true,</span><br><span class="line">    &quot;ordered&quot; : false,</span><br><span class="line">    &quot;delivered&quot; : false</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;deliverable&quot; : true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有关枚举类型的JSON序列化&#x2F;反序列化（包括自定义）的更多信息，请参阅Jackson-将枚举序列化为JSON对象。</p>
<h2 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a><strong>10.总结</strong></h2><p>本文我们讨论了Java枚举类型，从基础知识到高级应用以及实际应用场景，让我们感受到枚举的强大功能。</p>
<h2 id="11-补充"><a href="#11-补充" class="headerlink" title="11. 补充"></a><strong>11. 补充</strong></h2><p>我们在上面讲到了，我们可以通过在枚举类型中定义属性,方法和构造函数让它变得更加强大。</p>
<p>下面我通过一个实际的例子展示一下，当我们调用短信验证码的时候可能有几种不同的用途，我们在下面这样定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">publicenum PinType &#123;</span><br><span class="line"></span><br><span class="line">    REGISTER(100000, &quot;注册使用&quot;),</span><br><span class="line">    FORGET_PASSWORD(100001, &quot;忘记密码使用&quot;),</span><br><span class="line">    UPDATE_PHONE_NUMBER(100002, &quot;更新手机号码使用&quot;);</span><br><span class="line"></span><br><span class="line">    privatefinalint code;</span><br><span class="line">    privatefinal String message;</span><br><span class="line"></span><br><span class="line">    PinType(int code, String message) &#123;</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getCode() &#123;</span><br><span class="line">        return code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return&quot;PinType&#123;&quot; +</span><br><span class="line">                &quot;code=&quot; + code +</span><br><span class="line">                &quot;, message=&#x27;&quot; + message + &#x27;\&#x27;&#x27; +</span><br><span class="line">                &#x27;&#125;&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(PinType.FORGET_PASSWORD.getCode());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.getMessage());</span><br><span class="line">System.out.println(PinType.FORGET_PASSWORD.toString());</span><br></pre></td></tr></table></figure>

<p>Output:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100001</span><br><span class="line">忘记密码使用</span><br><span class="line">PinType&#123;code=100001, message=&#x27;忘记密码使用&#x27;&#125;</span><br></pre></td></tr></table></figure>

<p>这样的话，在实际使用起来就会非常灵活方便！</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Redis和mysql数据怎么保持数据一致的？"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/13/Redis%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%9F/"
    >Redis和mysql数据怎么保持数据一致的？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/01/13/Redis%E5%92%8Cmysql%E6%95%B0%E6%8D%AE%E6%80%8E%E4%B9%88%E4%BF%9D%E6%8C%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E7%9A%84%EF%BC%9F/" class="article-date">
  <time datetime="2020-01-13T11:03:21.000Z" itemprop="datePublished">2020-01-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="需求起因"><a href="#需求起因" class="headerlink" title="需求起因"></a>需求起因</h2><p>在高并发的业务场景下，数据库大多数情况都是用户并发访问最薄弱的环节。所以，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问MySQL等数据库。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gav5412bb9j30m00bmt9d.jpg"></p>
<p>这个业务场景，主要是解决读数据从Redis缓存，一般都是按照下图的流程来进行业务操作。</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gav549rgb6j30is0ge0th.jpg"></p>
<p>读取缓存步骤一般没有什么问题，但是一旦涉及到数据更新：数据库和缓存更新，就容易出现<strong>缓存(Redis)和数据库（MySQL）间的数据一致性问题</strong>。</p>
<p>不管是先写MySQL数据库，再删除Redis缓存；还是先删除缓存，再写库，都有可能出现数据不一致的情况。举一个例子：</p>
<p>1.如果删除了缓存Redis，还没有来得及写库MySQL，另一个线程就来读取，发现缓存为空，则去数据库中读取数据写入缓存，此时缓存中为脏数据。</p>
<p>2.如果先写了库，在删除缓存前，写库的线程宕机了，没有删除掉缓存，则也会出现数据不一致情况。</p>
<p>因为写和读是并发的，没法保证顺序,就会出现缓存和数据库的数据不一致的问题。</p>
<p>如来解决？这里给出两个解决方案，先易后难，结合业务和技术代价选择使用。</p>
<h2 id="缓存和数据库一致性解决方案"><a href="#缓存和数据库一致性解决方案" class="headerlink" title="缓存和数据库一致性解决方案"></a>缓存和数据库一致性解决方案</h2><h3 id="1-第一种方案：采用延时双删策略"><a href="#1-第一种方案：采用延时双删策略" class="headerlink" title="1.第一种方案：采用延时双删策略"></a>1.第一种方案：采用延时双删策略</h3><p>在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。</p>
<p>伪代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">( String key, Object data )</span></span><br><span class="line">&#123;</span><br><span class="line">	redis.delKey( key );</span><br><span class="line">	db.updateData( data );</span><br><span class="line">	Thread.sleep( <span class="number">500</span> );</span><br><span class="line">	redis.delKey( key );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.具体的步骤就是：</strong></p>
<ol>
<li><p>先删除缓存</p>
</li>
<li><p>再写数据库</p>
</li>
<li><p>休眠500毫秒</p>
</li>
<li><p>再次删除缓存</p>
</li>
</ol>
<p><strong>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</strong></p>
<p>需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>
<p>当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。</p>
<p><strong>3.设置缓存过期时间</strong></p>
<p>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。</p>
<p><strong>4.该方案的弊端</strong></p>
<p>结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。</p>
<h3 id="2、第二种方案：异步更新缓存-基于订阅binlog的同步机制"><a href="#2、第二种方案：异步更新缓存-基于订阅binlog的同步机制" class="headerlink" title="2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)"></a><strong>2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)</strong></h3><p><strong>1.技术整体思路：</strong></p>
<p>MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li><strong>读Redis</strong>：热数据基本都在Redis</li>
<li><strong>写MySQL</strong>:增删改都是操作MySQL</li>
<li><strong>更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</li>
</ul>
<p><strong>2.Redis更新</strong></p>
<p><strong>(1）数据操作主要分为两大块：</strong></p>
<ul>
<li>一个是全量(将全部数据一次写入到redis)</li>
<li>一个是增量（实时更新）</li>
</ul>
<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。</p>
<p><strong>(2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong></p>
<p>这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。</p>
<p>其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。</p>
<p>这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。</p>
<p>当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis!</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>后续会持续更新Redis专题知识，写的不好的地方也希望大牛能指点一下，大家觉得不错可以<strong>点个赞在关注下，以后还会分享更多文章！</strong></p>
<p>作者：若小寒链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/5c96fb795188252d5f0fdff2%E6%9D%A5%E6%BA%90%EF%BC%9A%E6%8E%98%E9%87%91%E8%91%97%E4%BD%9C%E6%9D%83%E5%BD%92%E4%BD%9C%E8%80%85%E6%89%80%E6%9C%89%E3%80%82%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E8%81%94%E7%B3%BB%E4%BD%9C%E8%80%85%E8%8E%B7%E5%BE%97%E6%8E%88%E6%9D%83%EF%BC%8C%E9%9D%9E%E5%95%86%E4%B8%9A%E8%BD%AC%E8%BD%BD%E8%AF%B7%E6%B3%A8%E6%98%8E%E5%87%BA%E5%A4%84%E3%80%82">https://juejin.im/post/5c96fb795188252d5f0fdff2来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Arrays-sort-vs-Arrays-parallelSort"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/12/Arrays-sort-vs-Arrays-parallelSort/"
    >译|Arrays.sort VS Arrays.parallelSort</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/01/12/Arrays-sort-vs-Arrays-parallelSort/" class="article-date">
  <time datetime="2020-01-12T12:38:23.000Z" itemprop="datePublished">2020-01-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>英文原文地址：<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-arrays-sort-vs-parallelsort" title="Arrays.sort vs Arrays.parallelSort">Arrays.sort vs Arrays.parallelSort</a></p>
<p>作者：<a target="_blank" rel="noopener" href="https://www.baeldung.com/author/baeldung/" title="baeldung">baeldung</a></p>
<p>翻译：高行行</p>
<p>小结：</p>
<p>当我们要排序的数据集很大时，parallelSort() 可能是更好的选择。但是，在数组较小的情况下，最好使用 sort()，因为它可以提供更好的性能</p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>我们都使用过 Arrays.sort() 对对象或原始数据类型数组（<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>char</code>，<code>float</code>，<code>double</code>和<code>boolean</code>）进行排序。在 JDK 8 中，创造者增强了 API 以提供一种新方法：_Arrays.parallelSort()_。</p>
<p>在本教程中，我们将对 sort() 和 parallelSort() 方法进行比较。</p>
<h2 id="2-Arrays-sort"><a href="#2-Arrays-sort" class="headerlink" title="2. Arrays.sort()"></a>2. Arrays.sort()</h2><p>Arrays.sort() 方法对对象或原始数据类型的数组进行排序。<strong>此方法中使用的排序算法是 Dual-Pivot <a target="_blank" rel="noopener" href="https://www.baeldung.com/algorithm-quicksort" title="Quicksort">Quicksort</a>。</strong> 换句话说，它是快速排序算法的自定义实现，以实现更好的性能。</p>
<p><strong>此方法是单线程的</strong> ，有两种变体：</p>
<ul>
<li>_sort(array)_–将整个数组按升序排序</li>
<li>_sort(array, fromIndex, toIndex)_–仅将从 fromIndex 到 toIndex 的元素排序</li>
</ul>
<p>让我们看一下两种变体的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenArrayOfIntegers_whenUsingArraysSortMethod_thenSortFullArrayInAscendingOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span>[] expected = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Arrays.sort(array);</span><br><span class="line"> </span><br><span class="line">    assertArrayEquals(expected, array);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenArrayOfIntegers_whenUsingArraysSortMethodWithRange_thenSortRangeOfArrayInAscendingOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span>[] expected = &#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Arrays.sort(array, <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">    assertArrayEquals(expected, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们总结一下这种方法的优缺点：</p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">快速处理较小的数据集</td>
<td align="left">大型数据集的性能下降</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">没有利用系统的多个核心</td>
</tr>
</tbody></table>
<h2 id="3-Arrays-parallelSort"><a href="#3-Arrays-parallelSort" class="headerlink" title="3. Arrays.parallelSort()"></a>3. Arrays.parallelSort()</h2><p>此方法对对象或原始数据类型的数组进行排序。与 sort() 类似，它也有两个变体来对完整数组和部分数组进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenArrayOfIntegers_whenUsingArraysParallelSortMethod_thenSortFullArrayInAscendingOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span>[] expected = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Arrays.parallelSort(array);</span><br><span class="line"> </span><br><span class="line">    assertArrayEquals(expected, array);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">givenArrayOfIntegers_whenUsingArraysParallelSortMethodWithRange_thenSortRangeOfArrayInAscendingOrder</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = &#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">int</span>[] expected = &#123; <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span> &#125;;</span><br><span class="line"> </span><br><span class="line">    Arrays.parallelSort(array, <span class="number">2</span>, <span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line">    assertArrayEquals(expected, array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>parallelSort() 在功能上有所不同。与 sort() 使用单个线程对数据进行顺序排序不同，<strong>它使用并行排序-合并排序算法</strong>。它将数组分成子数组，这些子数组本身先进行排序然后合并。</p>
<p><strong>为了执行并行任务，它使用 ForkJoin 池。</strong></p>
<p>但是我们需要知道，只有在满足某些条件时，它才会使用并行性。如果数组大小小于或等于 8192，或者处理器只有一个核心，则它将使用顺序的 Dual-Pivot Quicksort 算法。否则，它使用并行排序。</p>
<p>让我们总结一下使用它的优缺点：</p>
<table>
<thead>
<tr>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">为大型数据集提供更好的性能</td>
<td align="left">对于大小较小的数组，处理速度较慢</td>
</tr>
<tr>
<td align="left">利用系统的多个核心</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="4-比较"><a href="#4-比较" class="headerlink" title="4.比较"></a>4.比较</h2><p>现在，让我们看看在不同大小的数据集上两种方法怎样执行。以下数字是使用<a target="_blank" rel="noopener" href="https://www.baeldung.com/java-microbenchmark-harness" title="JMH基准测试">JMH 基准测试</a>得出的。测试环境使用 AMD A10 PRO 2.1Ghz 四核处理器和 JDK 1.8.0_221：</p>
<table>
<thead>
<tr>
<th align="left">数组大小</th>
<th align="left"><em>Arrays.sort()</em></th>
<th align="left"><em>Arrays.parallelSort()</em></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1000</td>
<td align="left">o.048</td>
<td align="left">0.054</td>
</tr>
<tr>
<td align="left">10000</td>
<td align="left">0.847</td>
<td align="left">0.425</td>
</tr>
<tr>
<td align="left">100000</td>
<td align="left">7.570</td>
<td align="left">4.395</td>
</tr>
<tr>
<td align="left">1000000</td>
<td align="left">65.301</td>
<td align="left">37.998</td>
</tr>
</tbody></table>
<h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5.结论"></a>5.结论</h2><p>在这篇短篇文章中，我们看到了 sort() 和 parallelSort() 的不同之处。</p>
<p>根据性能结果，我们可以得出结论，当我们要排序的数据集很大时，parallelSort() 可能是更好的选择。但是，在数组较小的情况下，最好使用 sort()，因为它可以提供更好的性能。</p>
<p>与往常一样，完整的源代码可以在 <a target="_blank" rel="noopener" href="https://github.com/eugenp/tutorials/tree/master/core-java-modules/core-java-arrays-2" title="GitHub">GitHub</a> 找到。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Synchronized同步静态方法和非静态方法总结"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/10/Synchronized%E5%90%8C%E6%AD%A5%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"
    >转|Synchronized同步静态方法和非静态方法总结</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/01/10/Synchronized%E5%90%8C%E6%AD%A5%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/" class="article-date">
  <time datetime="2020-01-09T17:29:46.000Z" itemprop="datePublished">2020-01-10</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20200111223325.png" alt="Photo by SnapwireSnaps"></p>
<blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010842515/article/details/65443084">https://blog.csdn.net/u010842515/article/details/65443084</a></p>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.csdn.net/u010842515">编程初丁</a></p>
</blockquote>
<h2 id="1-Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。"><a href="#1-Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。" class="headerlink" title="1. Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。"></a>1. Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。</h2><p>Java中每个对象都有一个锁，并且是唯一的。假设分配的一个对象空间，里面有多个方法，相当于空间里面有多个小房间，如果我们把所有的小房间都加锁，因为这个对象只有一把钥匙，因此同一时间只能有一个人打开一个小房间，然后用完了还回去，再由JVM 去分配下一个获得钥匙的人。</p>
<h3 id="情况1：同一个对象在两个线程中分别访问该对象的两个同步方法"><a href="#情况1：同一个对象在两个线程中分别访问该对象的两个同步方法" class="headerlink" title="情况1：同一个对象在两个线程中分别访问该对象的两个同步方法"></a>情况1：同一个对象在两个线程中分别访问该对象的两个同步方法</h3><p><strong>结果</strong>：会产生互斥。</p>
<p><strong>解释</strong>：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。</p>
<h3 id="情况2：不同对象在两个线程中调用同一个同步方法"><a href="#情况2：不同对象在两个线程中调用同一个同步方法" class="headerlink" title="情况2：不同对象在两个线程中调用同一个同步方法"></a>情况2：不同对象在两个线程中调用同一个同步方法</h3><p>结果：不会产生互斥。</p>
<p>解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new 一个对象，那么就会出现两个空间，两把钥匙，</p>
<h2 id="2-Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。"><a href="#2-Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。" class="headerlink" title="2. Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。"></a>2. Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。</h2><h3 id="情况1：用类直接在两个线程中调用两个不同的同步方法"><a href="#情况1：用类直接在两个线程中调用两个不同的同步方法" class="headerlink" title="情况1：用类直接在两个线程中调用两个不同的同步方法"></a>情况1：用类直接在两个线程中调用两个不同的同步方法</h3><p><strong>结果</strong>：会产生互斥。</p>
<p><strong>解释</strong>：因为对静态对象加锁实际上对类（.class）加锁，类对象只有一个，可以理解为任何时候都只有一个空间，里面有N个房间，一把锁，因此房间（同步方法）之间一定是互斥的。</p>
<p>注：上述情况和用单例模式声明一个对象来调用非静态方法的情况是一样的，因为永远就只有这一个对象。所以访问同步方法之间一定是互斥的。</p>
<h3 id="情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法"><a href="#情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法" class="headerlink" title="情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法"></a>情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法</h3><p>结果：会产生互斥。</p>
<p>解释：因为是一个对象调用，同上。</p>
<h3 id="情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法"><a href="#情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法" class="headerlink" title="情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法"></a>情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法</h3><p><strong>结果</strong>：不会产生互斥。</p>
<p><strong>解释</strong>：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。</p>
<p>测试代码：</p>
<p>同步方法类：SynchronizedTest.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedTest</span> &#123;</span><br><span class="line">	<span class="comment">/*private SynchronizedTest()&#123;&#125;</span></span><br><span class="line"><span class="comment">	private static SynchronizedTest st;           //懒汉式单例模式，线程不安全，需要加synchronized同步</span></span><br><span class="line"><span class="comment">	public static SynchronizedTest getInstance()&#123;</span></span><br><span class="line"><span class="comment">		if(st == null)&#123;</span></span><br><span class="line"><span class="comment">			st = new SynchronizedTest();</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">		return st;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	<span class="comment">/*private SynchronizedTest()&#123;&#125;</span></span><br><span class="line"><span class="comment">	private static final SynchronizedTest st = new SynchronizedTest();  //饿汉式单利模式，天生线程安全</span></span><br><span class="line"><span class="comment">	public static SynchronizedTest getInstance()&#123;</span></span><br><span class="line"><span class="comment">		return st;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="type">SynchronizedTest</span> <span class="variable">staticIn</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronizedTest</span>();   <span class="comment">//静态对象</span></span><br><span class="line">	</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;                                      <span class="comment">//非静态方法1</span></span><br><span class="line">    	 <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;  </span><br><span class="line">    		 System.out.println(<span class="string">&quot;method1 is running!&quot;</span>);</span><br><span class="line">    		 <span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">    	 &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;                                   <span class="comment">//非静态方法2</span></span><br><span class="line">    	 <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">    		 System.out.println(<span class="string">&quot;method2 is running!&quot;</span>);</span><br><span class="line">    		 <span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">    	 &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod1</span><span class="params">()</span>&#123;                     <span class="comment">//静态方法1</span></span><br><span class="line">    	<span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">   		 System.out.println(<span class="string">&quot;static method1 is running!&quot;</span>);</span><br><span class="line">   		 <span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">   	 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod2</span><span class="params">()</span>&#123;                      <span class="comment">//静态方法2</span></span><br><span class="line">    	<span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">   		 System.out.println(<span class="string">&quot;static method2 is running!&quot;</span>);</span><br><span class="line">   		 <span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">   	 &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程类1：Thread1.java（释放不同的注释可以测试不同的情况）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//		SynchronizedTest s = SynchronizedTest.getInstance();</span></span><br><span class="line"><span class="comment">//		s.method1();</span></span><br><span class="line"><span class="comment">//		SynchronizedTest s1 = new SynchronizedTest();</span></span><br><span class="line"><span class="comment">//		s1.method1();</span></span><br><span class="line">		SynchronizedTest.staticIn.method1();</span><br><span class="line"> </span><br><span class="line"><span class="comment">//		SynchronizedTest.staticMethod1();</span></span><br><span class="line"><span class="comment">//		SynchronizedTest.staticMethod2();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程类2：Thread2.Java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread2</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//		SynchronizedTest s = SynchronizedTest.getInstance();</span></span><br><span class="line"><span class="comment">//		SynchronizedTest s2 = new SynchronizedTest();</span></span><br><span class="line"><span class="comment">//		s2.method1();</span></span><br><span class="line"><span class="comment">//		s.method2();</span></span><br><span class="line"><span class="comment">//		SynchronizedTest.staticMethod1();</span></span><br><span class="line"><span class="comment">//		SynchronizedTest.staticMethod2();</span></span><br><span class="line"><span class="comment">//		SynchronizedTest.staticIn.method2();</span></span><br><span class="line">		SynchronizedTest.staticIn.staticMethod1();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主类：ThreadMain.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadMain</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread1</span>());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Thread2</span>());</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">exec</span> <span class="operator">=</span> Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(t1);</span><br><span class="line">        exec.execute(t2);</span><br><span class="line">        exec.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结："><a href="#3-总结：" class="headerlink" title="3. 总结："></a>3. 总结：</h2><p>1.对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性</p>
<p>2.在静态方法上的锁，和 实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。</p>
<p>3.关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单利的，就能互斥。</p>
<p>4.静态方法加锁，能和所有其他静态方法加锁的 进行互斥</p>
<p>5.静态方法加锁，和xx.class 锁效果一样，直接属于类的</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gat00jvxyig30p00dw4qq.gif"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-mysql优化：覆盖索引（延迟关联）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/06/mysql%E4%BC%98%E5%8C%96%EF%BC%9A%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%88%E5%BB%B6%E8%BF%9F%E5%85%B3%E8%81%94%EF%BC%89/"
    >mysql优化：覆盖索引、延迟关联</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/01/06/mysql%E4%BC%98%E5%8C%96%EF%BC%9A%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%88%E5%BB%B6%E8%BF%9F%E5%85%B3%E8%81%94%EF%BC%89/" class="article-date">
  <time datetime="2020-01-06T15:14:17.000Z" itemprop="datePublished">2020-01-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wang-meng/" title="一枝花算不算浪漫">一枝花算不算浪漫</a></p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/wang-meng/p/ae6d1c4a7b553e9a5c8f46b67fb3e3aa.html">https://www.cnblogs.com/wang-meng/p/ae6d1c4a7b553e9a5c8f46b67fb3e3aa.html</a></p>
<p>小结：</p>
<p><strong>回表</strong>：回到主键索引树搜索的过程，我们称为回表。</p>
<p><strong>覆盖索引</strong>：就是 select 的数据列只用从索引中就能够取得，不必从数据表中读取。简单点说就是你要查的数据索引里都有，一次搞定，美滋滋 😎。</p>
<p><strong>延迟关联</strong>：通过使用覆盖索引查询返回需要的主键，再根据主键关联原表获得需要的数据。</p>
</blockquote>
<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>上周新系统改版上线，上线第二天就出现了较多的线上<strong>慢 sql</strong> 查询，紧接着 dba 给出了定位及解决方案，这里较多的是使用<strong>延迟关联</strong>去优化。</p>
<p>而我对于这个<strong>延迟关联</strong>也是第一次听说（o(╥﹏╥)o），所以今天一定要学习并产出一篇学习笔记。(<em>^▽^</em>)</p>
<h2 id="2-回表"><a href="#2-回表" class="headerlink" title="2. 回表"></a>2. 回表</h2><p>我们都知道 InnoDB 采用的 B+ tree 来实现索引的，索引又分为主键索引(聚簇索引)和普通索引(二级索引)。</p>
<p>那么我们就来看下<strong>基于主键索引和普通索引的查询有什么区别？</strong></p>
<ul>
<li>如果语句是 select * from T where ID&#x3D;500，即主键查询方式，则只需要搜索 ID 这棵 B+树；</li>
<li>如果语句是 select * from T where k&#x3D;5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>举个栗子：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ganac2wt4kj30l505b3yq.jpg"></p>
<p>可以看出我们有一个普通索引 k，那么两颗 B+树的示意图如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ganacgk91rj30vq0nsgnf.jpg"></p>
<p><strong>（注：图来自极客时间专栏）</strong></p>
<p>当我们查询 <strong><code>select \* from T where k=5</code></strong> 其实会先到 k 那个索引树上查询 k &#x3D; 5，然后找到对应的 id 为 500，最后回表到主键索引的索引树找返回所需数据。</p>
<p>如果我们查询**<code>select id from T where k=5</code>** 则不需要回表就直接返回。</p>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<h2 id="3-覆盖索引"><a href="#3-覆盖索引" class="headerlink" title="3. 覆盖索引"></a>3. 覆盖索引</h2><ul>
<li>解释一： 就是 select 的数据列只用从索引中就能够取得，不必从数据表中读取，换句话说查询列要被所使用的索引覆盖。</li>
<li>解释二： 索引是高效找到行的一个方法，当能通过检索索引就可以读取想要的数据，那就不需要再到数据表中读取行了。如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。</li>
<li>解释三：是非聚集组合索引的一种形式，它包括在查询里的 Select、Join 和 Where 子句用到的所有列（即建立索引的字段正好是覆盖查询语句[select 子句]与查询条件[Where 子句]中所涉及的字段，也即，索引包含了查询正在查找的所有数据）。</li>
<li><strong>不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以 MySQL 只能使用 B-Tree 索引做覆盖索引</strong></li>
<li><strong>当发起一个被索引覆盖的查询(也叫作索引覆盖查询)时，在 EXPLAIN 的 Extra 列可以看到“Using index”的信息</strong></li>
</ul>
<p>概念如上，这里我们还是用例子来说明：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ganad2p4unj30vq0nsgnf.jpg"></p>
<p><strong>（注：图来自极客时间专栏）</strong></p>
<p>现在，我们一起来看看这条 SQL 查询语句的执行流程： select * from T where k between 3 and 5</p>
<ol>
<li>在 k 索引树上找到 k&#x3D;3 的记录，取得 ID &#x3D; 300；</li>
<li>再到 ID 索引树查到 ID&#x3D;300 对应的 R3；</li>
<li>在 k 索引树取下一个值 k&#x3D;5，取得 ID&#x3D;500；</li>
<li>再回到 ID 索引树查到 ID&#x3D;500 对应的 R4；</li>
<li>在 k 索引树取下一个值 k&#x3D;6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表。</strong>可以看到，这个查询过程读了 k 索引树的 3 条记录（步骤 1、3 和 5），回表了两次（步骤 2 和 4）。</p>
<p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经“覆盖了”我们的查询需求，我们称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2。</p>
<h2 id="4-延迟关联"><a href="#4-延迟关联" class="headerlink" title="4. 延迟关联"></a>4. 延迟关联</h2><p>上面介绍了那么多 其实是在为延迟关联做铺垫，这里直接续上我们本次慢查询的 sql：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ganadnaw4nj30w70a4dhu.jpg"></p>
<p>我们都知道在做分页时会用到 Limit 关键字去筛选所需数据，limit 接受 1 个或者 2 个参数，接受两个参数时第一个参数表示偏移量，即从哪一行开始取数据，第二个参数表示要取的行数。 如果只有一个参数，相当于偏移量为 0。</p>
<p>当偏移量很大时，如 limit 100000,10 取第 100001-100010 条记录，mysql 会取出 100010 条记录然后将前 100000 条记录丢弃，这无疑是一种巨大的性能浪费。</p>
<p>这个 sql 并没有利用索引覆盖，因为所要 select 的字段不全都在索引上，每次根据二级索引（expert_id） 查询到一条记录，都要再走一遍主键索引去表里找出所需要的其他列，速度自然慢。</p>
<p>当有这种写法时，我们可以采用延迟关联来进行优化，重点关注：<strong>SELECT id FROM qa_question WHERE expert_id &#x3D; 69 AND STATUS &#x3D; 30 ORDER BY over_time DESC LIMIT 0, 10</strong>， 这里其实利用了索引覆盖，where 条件后的 expert_id 是有添加索引的，这里查询 id 可以避免回表，大大提升效率。</p>
<h2 id="5-结语"><a href="#5-结语" class="headerlink" title="5. 结语"></a>5. 结语</h2><p>工作中会遇到各种各样的问题，对于一个研发来说最重要的是能够从这些问题中学到什么。好久没有写博客了，究其原因还是自己变得懒惰了。 (￣ェ￣)</p>
<p>最后以《高性能 Mysql》中的一段话结束：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwly1ganae8vmo7j30na0awq66.jpg"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-傻傻分不清之-Cookie、Session、Token、JWT"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/01/04/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8B-Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/"
    >傻傻分不清之 Cookie、Session、Token、JWT</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2020/01/04/%E5%82%BB%E5%82%BB%E5%88%86%E4%B8%8D%E6%B8%85%E4%B9%8B-Cookie%E3%80%81Session%E3%80%81Token%E3%80%81JWT/" class="article-date">
  <time datetime="2020-01-04T05:19:48.000Z" itemprop="datePublished">2020-01-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://juejin.im/post/5e055d9ef265da33997a42cc">https://juejin.im/post/5e055d9ef265da33997a42cc</a></p>
<p>作者：秋天不落叶</p>
</blockquote>
<h2 id="1-什么是认证（Authentication）"><a href="#1-什么是认证（Authentication）" class="headerlink" title="1. 什么是认证（Authentication）"></a>1. 什么是认证（Authentication）</h2><ul>
<li>通俗地讲就是<strong>验证当前用户的身份</strong>，证明“你是你自己”（比如：你每天上下班打卡，都需要通过指纹打卡，当你的指纹和系统里录入的指纹相匹配时，就打卡成功）</li>
<li>互联网中的认证：<ul>
<li>用户名密码登录</li>
<li>邮箱发送登录链接</li>
<li>手机号接收验证码</li>
<li>只要你能收到邮箱&#x2F;验证码，就默认你是账号的主人</li>
</ul>
</li>
</ul>
<h2 id="2-什么是授权（Authorization）"><a href="#2-什么是授权（Authorization）" class="headerlink" title="2. 什么是授权（Authorization）"></a>2. 什么是授权（Authorization）</h2><ul>
<li>用户授予第三方应用访问该用户某些资源的权限<ul>
<li>你在安装手机应用的时候，APP 会询问是否允许授予权限（访问相册、地理位置等权限）</li>
<li>你在访问微信小程序时，当登录时，小程序会询问是否允许授予权限（获取昵称、头像、地区、性别等个人信息）</li>
</ul>
</li>
<li>实现授权的方式有：cookie、session、token、OAuth</li>
</ul>
<h2 id="3-什么是凭证（Credentials）"><a href="#3-什么是凭证（Credentials）" class="headerlink" title="3. 什么是凭证（Credentials）"></a>3. 什么是凭证（Credentials）</h2><ul>
<li><p>实现认证和授权的前提</p>
<p>是需要一种</p>
<p>媒介（证书）</p>
<p>来标记访问者的身份</p>
<ul>
<li>在战国时期，商鞅变法，发明了照身帖。照身帖由官府发放，是一块打磨光滑细密的竹板，上面刻有持有人的头像和籍贯信息。国人必须持有，如若没有就被认为是黑户，或者间谍之类的。</li>
<li>在现实生活中，每个人都会有一张专属的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%B1%85%E6%B0%91%E8%BA%AB%E4%BB%BD%E8%AF%81/2080960" title="居民身份证">居民身份证</a>，是用于证明持有人身份的一种法定<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AF%81%E4%BB%B6/5804999" title="证件">证件</a>。通过身份证，我们可以办理手机卡&#x2F;银行卡&#x2F;个人贷款&#x2F;交通出行等等，这就是<strong>认证的凭证。</strong></li>
<li>在互联网应用中，一般网站（如掘金）会有两种模式，游客模式和登录模式。游客模式下，可以正常浏览网站上面的文章，一旦想要点赞&#x2F;收藏&#x2F;分享文章，就需要登录或者注册账号。当用户登录成功后，服务器会给该用户使用的浏览器颁发一个令牌（token），这个令牌用来表明你的身份，每次浏览器发送请求时会带上这个令牌，就可以使用游客模式下无法使用的功能。</li>
</ul>
</li>
</ul>
<h2 id="4-什么是-Cookie"><a href="#4-什么是-Cookie" class="headerlink" title="4. 什么是 Cookie"></a>4. 什么是 Cookie</h2><ul>
<li><strong>HTTP 是无状态的协议（对于事务处理没有记忆能力，每次客户端和服务端会话完成时，服务端不会保存任何会话信息</strong>）：每个请求都是完全独立的，服务端无法确认当前访问者的身份信息，无法分辨上一次的请求发送者和这一次的发送者是不是同一个人。所以服务器与浏览器为了进行会话跟踪（知道是谁在访问我），就必须主动的去维护一个状态，这个状态用于告知服务端前后两个请求是否来自同一浏览器。而这个状态需要通过 cookie 或者 session 去实现。</li>
<li><strong>cookie 存储在客户端：</strong> cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。</li>
<li><strong>cookie 是不可跨域的：</strong> 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，<strong>一级域名和二级域名之间是允许共享使用的</strong>（<strong>靠的是 domain）</strong>。</li>
</ul>
<p><strong>cookie 重要的属性</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>name&#x3D;value</strong></td>
<td align="left">键值对，设置 Cookie 的名称及相对应的值，都必须是<strong>字符串类型</strong> - 如果值为 Unicode 字符，需要为字符编码。 - 如果值为二进制数据，则需要使用 BASE64 编码。</td>
</tr>
<tr>
<td align="left"><strong>domain</strong></td>
<td align="left">指定 cookie 所属域名，默认是当前域名</td>
</tr>
<tr>
<td align="left"><strong>path</strong></td>
<td align="left">**指定 cookie 在哪个路径（路由）下生效，默认是 ‘&#x2F;‘**。 如果设置为 <code>/abc</code>，则只有 <code>/abc</code> 下的路由可以访问到该 cookie，如：<code>/abc/read</code>。</td>
</tr>
<tr>
<td align="left"><strong>maxAge</strong></td>
<td align="left">cookie 失效的时间，单位秒。如果为整数，则该 cookie 在 maxAge 秒后失效。如果为负数，该 cookie 为临时 cookie ，关闭浏览器即失效，浏览器也不会以任何形式保存该 cookie 。如果为 0，表示删除该 cookie 。默认为 -1。 - <strong>比 expires 好用</strong>。</td>
</tr>
<tr>
<td align="left"><strong>expires</strong></td>
<td align="left">过期时间，在设置的某个时间点后该 cookie 就会失效。 一般浏览器的 cookie 都是默认储存的，当关闭浏览器结束这个会话的时候，这个 cookie 也就会被删除</td>
</tr>
<tr>
<td align="left"><strong>secure</strong></td>
<td align="left">该 cookie 是否仅被使用安全协议传输。安全协议有 HTTPS，SSL 等，在网络上传输数据之前先将数据加密。默认为 false。 当 secure 值为 true 时，cookie 在 HTTP 中是无效，在 HTTPS 中才有效。</td>
</tr>
<tr>
<td align="left"><strong>httpOnly</strong></td>
<td align="left"><strong>如果给某个 cookie 设置了 httpOnly 属性，则无法通过 JS 脚本 读取到该 cookie 的信息，但还是能通过 Application 中手动修改 cookie，所以只是在一定程度上可以防止 XSS 攻击，不是绝对的安全</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="5-什么是-Session"><a href="#5-什么是-Session" class="headerlink" title="5. 什么是 Session"></a>5. 什么是 Session</h2><ul>
<li><strong>session 是另一种记录服务器和客户端会话状态的机制</strong></li>
<li><strong>session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的 cookie 中</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04d0b3cf5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="session.png"></p>
<ul>
<li>session 认证流程：<ul>
<li>用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 Session</li>
<li>请求返回时将此 Session 的唯一标识信息 SessionID 返回给浏览器</li>
<li>浏览器接收到服务器返回的 SessionID 信息后，会将此信息存入到 Cookie 中，同时 Cookie 记录此 SessionID 属于哪个域名</li>
<li>当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 Cookie 信息，如果存在自动将 Cookie 信息也发送给服务端，服务端会从 Cookie 中获取 SessionID，再根据 SessionID 查找对应的 Session 信息，如果没有找到说明用户没有登录或者登录失效，如果找到 Session 证明用户已经登录可执行后面操作。</li>
</ul>
</li>
</ul>
<p>根据以上流程可知，<strong>SessionID 是连接 Cookie 和 Session 的一道桥梁</strong>，大部分系统也是根据此原理来验证用户登录状态。</p>
<h2 id="6-Cookie-和-Session-的区别"><a href="#6-Cookie-和-Session-的区别" class="headerlink" title="6. Cookie 和 Session 的区别"></a>6. Cookie 和 Session 的区别</h2><ul>
<li><strong>安全性：</strong> Session 比 Cookie 安全，Session 是存储在服务器端的，Cookie 是存储在客户端的。</li>
<li><strong>存取值的类型不同</strong>：Cookie 只支持存字符串数据，想要设置其他类型的数据，需要将其转换成字符串，Session 可以存任意数据类型。</li>
<li><strong>有效期不同：</strong> Cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，Session 一般失效时间较短，客户端关闭（默认情况下）或者 Session 超时都会失效。</li>
<li><strong>存储大小不同：</strong> 单个 Cookie 保存的数据不能超过 4K，Session 可存储数据远高于 Cookie，但是当访问量过多，会占用过多的服务器资源。</li>
</ul>
<h2 id="7-什么是-Token（令牌）"><a href="#7-什么是-Token（令牌）" class="headerlink" title="7. 什么是 Token（令牌）"></a>7. 什么是 Token（令牌）</h2><h3 id="7-1-Acesss-Token"><a href="#7-1-Acesss-Token" class="headerlink" title="7.1 Acesss Token"></a>7.1 Acesss Token</h3><ul>
<li><strong>访问资源接口（API）时所需要的资源凭证</strong></li>
<li><strong>简单 token 的组成：</strong> uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign（签名，token 的前几位以哈希算法压缩成的一定长度的十六进制字符串）</li>
<li>特点：<ul>
<li><strong>服务端无状态化、可扩展性好</strong></li>
<li><strong>支持移动端设备</strong></li>
<li>安全</li>
<li>支持跨程序调用</li>
</ul>
</li>
<li><strong>token 的身份验证流程：</strong></li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04d9c745f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ol>
<li>客户端使用用户名跟密码请求登录</li>
<li>服务端收到请求，去验证用户名与密码</li>
<li>验证成功后，服务端会签发一个 token 并把这个 token 发送给客户端</li>
<li>客户端收到 token 以后，会把它存储起来，比如放在 cookie 里或者 localStorage 里</li>
<li>客户端每次向服务端请求资源的时候需要带着服务端签发的 token</li>
<li>服务端收到请求，然后去验证客户端请求里面带着的 token ，如果验证成功，就向客户端返回请求的数据</li>
</ol>
<ul>
<li><strong>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</strong></li>
<li><strong>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压力，减少频繁的查询数据库</strong></li>
<li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li>
</ul>
<h3 id="7-2-Refresh-Token"><a href="#7-2-Refresh-Token" class="headerlink" title="7.2 Refresh Token"></a>7.2 Refresh Token</h3><ul>
<li>另外一种 token——refresh token</li>
<li>refresh token 是专用于刷新 access token 的 token。如果没有 refresh token，也可以刷新 access token，但每次刷新都要用户输入登录用户名与密码，会很麻烦。有了 refresh token，可以减少这个麻烦，客户端直接用 refresh token 去更新 access token，无需用户进行额外的操作。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04d1c887b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>Access Token 的有效期比较短，当 Acesss Token 由于过期而失效时，使用 Refresh Token 就可以获取到新的 Token，如果 Refresh Token 也失效了，用户就只能重新登录了。</li>
<li>Refresh Token 及过期时间是存储在服务器的数据库中，只有在申请新的 Acesss Token 时才会验证，不会对业务接口响应时间造成影响，也不需要向 Session 一样一直保持在内存中以应对大量的请求。</li>
</ul>
<h2 id="8-Token-和-Session-的区别"><a href="#8-Token-和-Session-的区别" class="headerlink" title="8. Token 和 Session 的区别"></a>8. Token 和 Session 的区别</h2><ul>
<li>Session 是一种<strong>记录服务器和客户端会话状态的机制，使服务端有状态化，可以记录会话信息</strong>。而 Token 是<strong>令牌</strong>，<strong>访问资源接口（API）时所需要的资源凭证</strong>。Token <strong>使服务端无状态化，不会存储会话信息。</strong></li>
<li>Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好，因为每一个请求都有签名还能防止监听以及重放攻击，而 Session 就必须依赖链路层来保障通讯安全了。<strong>如果你需要实现有状态的会话，仍然可以增加 Session 来在服务器端保存一些状态。</strong></li>
<li>所谓 Session 认证只是简单的把 User 信息存储到 Session 里，因为 SessionID 的不可预测性，暂且认为是安全的。而 Token ，如果指的是 OAuth Token 或类似的机制的话，提供的是 认证 和 授权 ，认证是针对用户，授权是针对 App 。其目的是让某 App 有权利访问某用户的信息。这里的 Token 是唯一的。不可以转移到其它 App 上，也不可以转到其它用户上。Session 只提供一种简单的认证，即只要有此 SessionID ，即认为有此 User 的全部权利。是需要严格保密的，这个数据应该只保存在站方，不应该共享给其它网站或者第三方 App。所以简单来说：<strong>如果你的用户数据可能需要和第三方共享，或者允许第三方调用 API 接口，用 Token 。如果永远只是自己的网站，自己的 App，用什么就无所谓了。</strong></li>
</ul>
<h2 id="9-什么是-JWT"><a href="#9-什么是-JWT" class="headerlink" title="9. 什么是 JWT"></a>9. 什么是 JWT</h2><ul>
<li>JSON Web Token（简称 JWT）是目前最流行的<strong>跨域认证</strong>解决方案。</li>
<li>是一种<strong>认证授权机制</strong>。</li>
<li>JWT 是为了在网络应用环境间<strong>传递声明</strong>而执行的一种基于 JSON 的开放标准（<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc7519" title="RFC 7519">RFC 7519</a>）。JWT 的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源。比如用在用户登录上。</li>
<li>可以使用 HMAC 算法或者是 RSA 的公&#x2F;私秘钥对 JWT 进行签名。因为数字签名的存在，这些传递的信息是可信的。</li>
<li><strong>阮一峰老师的 <a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" title="JSON Web Token 入门教程">JSON Web Token 入门教程</a> 讲的非常通俗易懂，这里就不再班门弄斧了</strong></li>
</ul>
<h3 id="9-1-生成-JWT"><a href="#9-1-生成-JWT" class="headerlink" title="9.1 生成 JWT"></a>9.1 生成 JWT</h3><p><a target="_blank" rel="noopener" href="https://jwt.io/" title="jwt.io/">jwt.io&#x2F;</a><br><a target="_blank" rel="noopener" href="https://www.jsonwebtoken.io/" title="www.jsonwebtoken.io/">www.jsonwebtoken.io/</a></p>
<h3 id="9-2-JWT-的原理"><a href="#9-2-JWT-的原理" class="headerlink" title="9.2 JWT 的原理"></a>9.2 JWT 的原理</h3><p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04e881087?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li>JWT 认证流程：<ul>
<li>用户输入用户名&#x2F;密码登录，服务端认证成功后，会返回给客户端一个 JWT</li>
<li>客户端将 token 保存到本地（通常使用 localstorage，也可以使用 cookie）</li>
<li>当用户希望访问一个受保护的路由或者资源的时候，需要请求头的 Authorization 字段中使用 Bearer 模式添加 JWT，其内容看起来是下面这样</li>
</ul>
</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为</li>
<li>因为 JWT 是自包含的（内部包含了一些会话信息），因此减少了需要查询数据库的需要</li>
<li>因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li>
<li>因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制</li>
</ul>
<h3 id="9-3-JWT-的使用方式"><a href="#9-3-JWT-的使用方式" class="headerlink" title="9.3 JWT 的使用方式"></a>9.3 JWT 的使用方式</h3><ul>
<li>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。</li>
</ul>
<h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><ul>
<li><p>当用户希望访问一个受保护的路由或者资源的时候，可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求头信息的 Authorization 字段里，使用 Bearer 模式添加 JWT。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /calendar/v1/events</span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>api.example.com</span><br><span class="line"><span class="attribute">Authorization</span><span class="punctuation">: </span>Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用户的状态不会存储在服务端的内存中，这是一种 <strong>无状态的认证机制</strong></p>
<ul>
<li>服务端的保护路由将会检查请求头 Authorization 中的 JWT 信息，如果合法，则允许用户的行为。</li>
<li>由于 JWT 是自包含的，因此减少了需要查询数据库的需要</li>
<li>JWT 的这些特性使得我们可以完全依赖其无状态的特性提供数据 API 服务，甚至是创建一个下载流服务。</li>
<li>因为 JWT 并不使用 Cookie ，所以你可以使用任何域名提供你的 API 服务而<strong>不需要担心跨域资源共享问题</strong>（CORS）</li>
</ul>
</li>
</ul>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><ul>
<li>跨域的时候，可以把 JWT 放在 POST 请求的数据体里。</li>
</ul>
<h4 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h4><ul>
<li>通过 URL 传输</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.example.com/user?token=xxx</span><br></pre></td></tr></table></figure>

<h3 id="9-4-项目中使用-JWT"><a href="#9-4-项目中使用-JWT" class="headerlink" title="9.4 项目中使用 JWT"></a>9.4 项目中使用 JWT</h3><p><a target="_blank" rel="noopener" href="https://github.com/yjdjiayou/jwt-demo" title="**项目地址**"><strong>项目地址</strong></a></p>
<h2 id="10-Token-和-JWT-的区别"><a href="#10-Token-和-JWT-的区别" class="headerlink" title="10. Token 和 JWT 的区别"></a>10. Token 和 JWT 的区别</h2><p><strong>相同：</strong></p>
<ul>
<li>都是访问资源的令牌</li>
<li>都可以记录用户的信息</li>
<li>都是使服务端无状态化</li>
<li>都是只有验证成功后，客户端才能访问服务端上受保护的资源</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li>
<li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li>
</ul>
<h2 id="11-常见的前后端鉴权方式"><a href="#11-常见的前后端鉴权方式" class="headerlink" title="11. 常见的前后端鉴权方式"></a>11. 常见的前后端鉴权方式</h2><ol>
<li>Session-Cookie</li>
<li>Token 验证（包括 JWT，SSO）</li>
<li>OAuth2.0（开放授权）</li>
</ol>
<h2 id="12-常见的加密算法"><a href="#12-常见的加密算法" class="headerlink" title="12. 常见的加密算法"></a>12. 常见的加密算法</h2><p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04f17f2fc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="image.png"></p>
<ul>
<li>哈希算法(Hash Algorithm)又称散列算法、散列函数、哈希函数，是一种从任何一种数据中创建小的数字“指纹”的方法。哈希算法将数据重新打乱混合，重新创建一个哈希值。</li>
<li>哈希算法主要用来保障数据真实性(即完整性)，即发信人将原始消息和哈希值一起发送，收信人通过相同的哈希函数来校验原始数据是否真实。</li>
<li>哈希算法通常有以下几个特点：<ul>
<li>正像快速：原始数据可以快速计算出哈希值</li>
<li>逆向困难：通过哈希值基本不可能推导出原始数据</li>
<li>输入敏感：原始数据只要有一点变动，得到的哈希值差别很大</li>
<li>冲突避免：很难找到不同的原始数据得到相同的哈希值，宇宙中原子数大约在 10 的 60 次方到 80 次方之间，所以 2 的 256 次方有足够的空间容纳所有的可能，算法好的情况下冲突碰撞的概率很低：<ul>
<li>2 的 128 次方为 340282366920938463463374607431768211456，也就是 10 的 39 次方级别</li>
<li>2 的 160 次方为 1.4615016373309029182036848327163e+48，也就是 10 的 48 次方级别</li>
<li>2 的 256 次方为 1.1579208923731619542357098500869 × 10 的 77 次方，也就是 10 的 77 次方</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li>以上不能保证数据被恶意篡改，原始数据和哈希值都可能被恶意篡改，要保证不被篡改，可以使用 RSA 公钥私钥方案，再配合哈希值。</li>
<li>哈希算法主要用来防止计算机传输过程中的错误，早期计算机通过前 7 位数据第 8 位奇偶校验码来保障（12.5% 的浪费效率低），对于一段数据或文件，通过哈希算法生成 128bit 或者 256bit 的哈希值，如果校验有问题就要求重传。</li>
</ol>
<h2 id="13-常见问题"><a href="#13-常见问题" class="headerlink" title="13. 常见问题"></a>13. 常见问题</h2><h3 id="13-1-使用-cookie-时需要考虑的问题"><a href="#13-1-使用-cookie-时需要考虑的问题" class="headerlink" title="13.1 使用 cookie 时需要考虑的问题"></a>13.1 使用 cookie 时需要考虑的问题</h3><ul>
<li>因为存储在客户端，容易被客户端篡改，使用前需要验证合法性</li>
<li>不要存储敏感数据，比如用户密码，账户余额</li>
<li>使用 httpOnly 在一定程度上提高安全性</li>
<li>尽量减少 cookie 的体积，能存储的数据量不能超过 4kb</li>
<li>设置正确的 domain 和 path，减少数据传输</li>
<li><strong>cookie 无法跨域</strong></li>
<li>一个浏览器针对一个网站最多存 20 个 Cookie，浏览器一般只允许存放 300 个 Cookie</li>
<li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li>
</ul>
<h3 id="13-2-使用-session-时需要考虑的问题"><a href="#13-2-使用-session-时需要考虑的问题" class="headerlink" title="13.2 使用 session 时需要考虑的问题"></a>13.2 使用 session 时需要考虑的问题</h3><ul>
<li>将 session 存储在服务器里面，当用户同时在线量比较多时，这些 session 会占据较多的内存，需要在服务端定期的去清理过期的 session</li>
<li>当网站采用<strong>集群部署</strong>的时候，会遇到多台 web 服务器之间如何做 session 共享的问题。因为 session 是由单个服务器创建的，但是处理用户请求的服务器不一定是那个创建 session 的服务器，那么该服务器就无法拿到之前已经放入到 session 中的登录凭证之类的信息了。</li>
<li>当多个应用要共享 session 时，除了以上问题，还会遇到跨域问题，因为不同的应用可能部署的主机不一样，需要在各个应用做好 cookie 跨域的处理。</li>
<li><strong>sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？</strong> 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现</li>
<li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li>
</ul>
<h3 id="13-3-使用-token-时需要考虑的问题"><a href="#13-3-使用-token-时需要考虑的问题" class="headerlink" title="13.3 使用 token 时需要考虑的问题"></a>13.3 使用 token 时需要考虑的问题</h3><ul>
<li>如果你认为用数据库来存储 token 会导致查询时间太长，可以选择放在内存当中。比如 redis 很适合你对 token 查询的需求。</li>
<li><strong>token 完全由应用管理，所以它可以避开同源策略</strong></li>
<li><strong>token 可以避免 CSRF 攻击(因为不需要 cookie 了)</strong></li>
<li><strong>移动端对 cookie 的支持不是很好，而 session 需要基于 cookie 实现，所以移动端常用的是 token</strong></li>
</ul>
<h3 id="13-4-使用-JWT-时需要考虑的问题"><a href="#13-4-使用-JWT-时需要考虑的问题" class="headerlink" title="13.4 使用 JWT 时需要考虑的问题"></a>13.4 使用 JWT 时需要考虑的问题</h3><ul>
<li>因为 JWT 并不依赖 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）</li>
<li>JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。</li>
<li>JWT 不加密的情况下，不能将秘密数据写入 JWT。</li>
<li>JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。</li>
<li>JWT 最大的优势是服务器不再需要存储 Session，使得服务器认证鉴权业务可以方便扩展。但这也是 JWT 最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，除非服务器部署额外的逻辑。</li>
<li>JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。</li>
<li>JWT 适合一次性的命令认证，颁发一个有效期极短的 JWT，即使暴露了危险也很小，由于每次操作都会生成新的 JWT，因此也没必要保存 JWT，真正实现无状态。</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。</li>
</ul>
<h3 id="13-5-使用加密算法时需要考虑的问题"><a href="#13-5-使用加密算法时需要考虑的问题" class="headerlink" title="13.5 使用加密算法时需要考虑的问题"></a>13.5 使用加密算法时需要考虑的问题</h3><ul>
<li>绝不要以<strong>明文存储</strong>密码</li>
<li><strong>永远使用 哈希算法 来处理密码，绝不要使用 Base64 或其他编码方式来存储密码，这和以明文存储密码是一样的，使用哈希，而不要使用编码</strong>。编码以及加密，都是双向的过程，而密码是保密的，应该只被它的所有者知道， 这个过程必须是单向的。哈希正是用于做这个的，从来没有解哈希这种说法， 但是编码就存在解码，加密就存在解密。</li>
<li>绝不要使用弱哈希或已被破解的哈希算法，像 MD5 或 SHA1 ，只使用强密码哈希算法。</li>
<li>绝不要以明文形式显示或发送密码，即使是对密码的所有者也应该这样。如果你需要 “忘记密码” 的功能，可以随机生成一个新的 <strong>一次性的</strong>（这点很重要）密码，然后把这个密码发送给用户。</li>
</ul>
<h3 id="13-6-分布式架构下-session-共享方案"><a href="#13-6-分布式架构下-session-共享方案" class="headerlink" title="13.6 分布式架构下 session 共享方案"></a>13.6 分布式架构下 session 共享方案</h3><h4 id="1-session-复制"><a href="#1-session-复制" class="headerlink" title="1. session 复制"></a>1. session 复制</h4><ul>
<li>任何一个服务器上的 session 发生改变（增删改），该节点会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步</li>
</ul>
<p><strong>优点：</strong> 可容错，各个服务器间 session 能够实时响应。<br><strong>缺点：</strong> 会对网络负荷造成一定压力，如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。</p>
<h4 id="2-粘性-session-x2F-IP-绑定策略"><a href="#2-粘性-session-x2F-IP-绑定策略" class="headerlink" title="2. 粘性 session &#x2F;IP 绑定策略"></a>2. 粘性 session &#x2F;IP 绑定策略</h4><ul>
<li><strong>采用 Ngnix 中的 ip_hash 机制，将某个 ip 的所有请求都定向到同一台服务器上，即将用户与服务器绑定。</strong> 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。</li>
</ul>
<p><strong>优点：</strong> 简单，不需要对 session 做任何处理。<br><strong>缺点：</strong> 缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的 session 信息都将失效。<br><strong>适用场景：</strong> 发生故障对客户产生的影响较小；服务器发生故障是低概率事件 。<br><strong>实现方式：</strong> 以 Nginx 为例，在 upstream 模块配置 ip_hash 属性即可实现粘性 session。</p>
<h4 id="3-session-共享（常用）"><a href="#3-session-共享（常用）" class="headerlink" title="3. session 共享（常用）"></a>3. session 共享（常用）</h4><ul>
<li>使用分布式缓存方案比如 Memcached 、Redis 来缓存 session，但是要求 Memcached 或 Redis 必须是集群</li>
<li>把 session 放到 Redis 中存储，虽然架构上变得复杂，并且需要多访问一次 Redis ，但是这种方案带来的好处也是很大的：<ul>
<li>实现了 session 共享；</li>
<li>可以水平扩展（增加 Redis 服务器）；</li>
<li>服务器重启 session 不丢失（不过也要注意 session 在 Redis 中的刷新&#x2F;失效机制）；</li>
<li>不仅可以跨服务器 session 共享，甚至可以跨平台（例如网页端和 APP 端）</li>
</ul>
</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/12/29/16f523a04fb8b4b8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h4 id="4-session-持久化"><a href="#4-session-持久化" class="headerlink" title="4. session 持久化"></a>4. session 持久化</h4><ul>
<li>将 session 存储到数据库中，保证 session 的持久化</li>
</ul>
<p><strong>优点：</strong> 服务器出现问题，session 不会丢失<br><strong>缺点：</strong> 如果网站的访问量很大，把 session 存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。</p>
<h3 id="13-7-只要关闭浏览器-，session-真的就消失了？"><a href="#13-7-只要关闭浏览器-，session-真的就消失了？" class="headerlink" title="13.7 只要关闭浏览器 ，session 真的就消失了？"></a>13.7 <strong>只要关闭浏览器 ，session 真的就消失了？</strong></h3><p>不对。对 session 来说，除非程序通知服务器删除一个 session，否则服务器会一直保留，程序一般都是在用户做 log off 的时候发个指令去删除 session。<br>然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分 session 机制都使用会话 cookie 来保存 session id，而关闭浏览器后这个 session id 就消失了，再次连接服务器时也就无法找到原来的 session。如果服务器设置的 cookie 被保存在硬盘上，或者使用某种手段改写浏览器发出的 HTTP 请求头，把原来的 session id 发送给服务器，则再次打开浏览器仍然能够打开原来的 session。<br>恰恰是<strong>由于关闭浏览器不会导致 session 被删除，迫使服务器为 session 设置了一个失效时间，当距离客户端上一次使用 session 的时间超过这个失效时间时，服务器就认为客户端已经停止了活动，才会把 session 删除以节省存储空间。</strong></p>
<h2 id="14-项目地址"><a href="#14-项目地址" class="headerlink" title="14. 项目地址"></a>14. 项目地址</h2><p><a target="_blank" rel="noopener" href="https://github.com/yjdjiayou/jwt-demo" title="**在项目中使用 JWT**"><strong>在项目中使用 JWT</strong></a></p>
<h2 id="15-后语"><a href="#15-后语" class="headerlink" title="15. 后语"></a>15. 后语</h2><ul>
<li>本文只是基于自己的理解讲了理论知识，因为对后端&#x2F;算法知识不是很熟，如有谬误，还请告知，万分感谢</li>
<li>如果本文对你有所帮助，还请点个赞~~</li>
</ul>
<h2 id="16-参考"><a href="#16-参考" class="headerlink" title="16. 参考"></a>16. 参考</h2><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/cookie/1119?fr=aladdin" title="**百度百科-cookie**"><strong>百度百科-cookie</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/session/479100?fr=aladdin#3" title="**百度百科-session**"><strong>百度百科-session</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5d01f82cf265da1b67210869" title="**详解 Cookie，Session，Token**"><strong>详解 Cookie，Session，Token</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5de4c3c76fb9a071b86cc482#heading-0" title="**一文彻底搞懂Cookie、Session、Token到底是什么**"><strong>一文彻底搞懂 Cookie、Session、Token 到底是什么</strong></a></p>
<p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/lyzg/p/6067766.html" title="3种web会话管理的方式">3 种 web 会话管理的方式</a>！！！</strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/JamesWang1993/p/8593494.html" title="Token ，Cookie和Session的区别">Token ，Cookie 和 Session 的区别</a>！！！</strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/moyand/p/9047978.html" title="彻底理解 cookie、session、token">彻底理解 cookie、session、token</a>！！！</strong></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c6e6063f265da2da53ec8f3" title="**前端鉴权**"><strong>前端鉴权</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-1" title="**SHA-1**"><strong>SHA-1</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-2" title="**SHA-2**"><strong>SHA-2</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-3" title="**SHA-3**"><strong>SHA-3</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhezhebie/article/details/71631077" title="**不要再使用MD5和SHA1加密密码了！**"><strong>不要再使用 MD5 和 SHA1 加密密码了！</strong></a></p>
<p><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640" title="**廖雪峰 Node 教程之 crypto**"><strong>廖雪峰 Node 教程之 crypto</strong></a><a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023025778520640" title=" "> </a></p>
<h2 id="17-推荐阅读"><a href="#17-推荐阅读" class="headerlink" title="17. 推荐阅读"></a>17. 推荐阅读</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5df648836fb9a016526eba01" title="**你真的了解 React 生命周期吗**"><strong>你真的了解 React 生命周期吗</strong></a></p>
<p><strong><a target="_blank" rel="noopener" href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d" title="React Hooks 详解 【近 1W 字】+ 项目实战">React Hooks 详解 【近 1W 字】+ 项目实战</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://juejin.im/post/5def0816f265da33aa6aa7fe" title="React SSR 详解【近 1W 字】+ 2个项目实战">React SSR 详解【近 1W 字】+ 2 个项目实战</a></strong></p>
<p><strong><a target="_blank" rel="noopener" href="https://juejin.im/post/5da56e34f265da5b932e73fa" title="从 0 到 1 实现一款简易版 Webpack">从 0 到 1 实现一款简易版 Webpack</a></strong></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-反射的基本原理"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/30/%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"
    >反射的基本原理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/30/%E5%8F%8D%E5%B0%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/" class="article-date">
  <time datetime="2019-12-30T14:53:54.000Z" itemprop="datePublished">2019-12-30</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://juejin.im/post/5b2f8bd2f265da59b457cf47">https://juejin.im/post/5b2f8bd2f265da59b457cf47</a></p>
<p>作者：YangAM</p>
<p>小结：</p>
<p>反射就是指程序在运行时能够动态的获取到一个类的类型信息的一种操作。</p>
<p>获取一个 Class 对象的方法主要有以下三种。</p>
<p><strong>类名.class</strong></p>
<p><strong>getClass 方法</strong></p>
<p><strong>forName 方法</strong></p>
</blockquote>
<p><img src="https://images2015.cnblogs.com/blog/1037972/201610/1037972-20161018144629217-1068318939.png" alt="img"></p>
<p>图片来自 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/fengmingyue/p/5973260.html">https://www.cnblogs.com/fengmingyue/p/5973260.html</a></p>
<p>『反射』就是指程序在运行时能够动态的获取到一个类的类型信息的一种操作。它是现代框架的灵魂，几尽所有的框架能够提供的一些自动化机制都是靠反射实现的，这也是为什么各类框架都不允许你覆盖掉默认的无参构造器的原因，因为框架需要以反射机制利用无参构造器创建实例。</p>
<p>总的来说，『反射』是很值得大家花时间学习的，尽管大部分人都很少有机会去手写框架，但是这将有助于你对于各类框架的理解。不奢求你通过本篇文章的学习对于『反射』能够有多么深层次的理解，但至少保证你了解『反射』的基本原理及使用。</p>
<h3 id="1-Class-类型信息"><a href="#1-Class-类型信息" class="headerlink" title="1. Class 类型信息"></a>1. Class 类型信息</h3><p>之间介绍过虚拟机的类加载机制，其中我们提到过，每一种类型都会在初次使用时被加载进虚拟机内存的『方法区』中，包含类中定义的属性字段，方法字节码等信息。</p>
<p>Java 中使用类 java.lang.Class 来指向一个类型信息，通过这个 Class 对象，我们就可以得到该类的所有内部信息。而获取一个 Class 对象的方法主要有以下三种。</p>
<p><strong>类名.class</strong></p>
<p>这种方式就比较简单，只要使用类名点 class 即可得到方法区该类型的类型信息。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.class;</span><br><span class="line">Integer.class;</span><br><span class="line"><span class="type">int</span>.class;</span><br><span class="line">String.class;</span><br><span class="line"><span class="comment">//等等</span></span><br></pre></td></tr></table></figure>

<p><strong>getClass 方法</strong></p>
<p>Object 类有这么一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure>

<p>这是一个本地方法，并且不允许子类重写，所以理论上所有类型的实例都具有同一个 getClass 方法。具体使用上也很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = new Integer(12);</span><br><span class="line">integer.getClass();</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><strong>forName 方法</strong></p>
<p>forName 算是获取 Class 类型的一个最常用的方法，它允许你传入一个全类名，该方法会返回方法区代表这个类型的 Class 对象，如果这个类还没有被加载进方法区，forName 会先进行类加载。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String className) &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    return forName0(className, true, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于方法区 Class 类型信息由类加载器和类全限定名唯一确定，所以想要去找这么一个 Class 就必须提供类加载器和类全限定名，这个 forName 方法默认使用调用者的类加载器。</p>
<p>当然，Class 类中也有一个 forName 重载，允许你传入类加载器和类全限定名来匹配方法区类型信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static Class&lt;?&gt; forName(String name, boolean initialize,</span><br><span class="line">ClassLoader loader)&#123;</span><br><span class="line">    //.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，通过这些方法你可以得到任意类的类型信息，该类的所有字段属性，方法表等信息都可以通过这个 Class 对象进行获取。</p>
<h3 id="2-反射字段属性"><a href="#2-反射字段属性" class="headerlink" title="2. 反射字段属性"></a>2. 反射字段属性</h3><p>Class 中有关获取字段属性的方法主要以下几个：</p>
<ul>
<li>public Field[] getFields()：返回该类型的所有 public 修饰的属性，包括父类的</li>
<li>public Field getField(String name)：根据字段名称返回相应的字段</li>
<li>public Field[] getDeclaredFields()：返回本类型中申明的所有字段，包含非 public 修饰的但不包含父类中的</li>
<li>public Field getDeclaredField(String name)：同理</li>
</ul>
<p>当然，一个 Field 实例包含某个类的一个属性的所有信息，包括字段名称，访问修饰符，字段类型。除此之外，Field 还提供了大量的操作该属性值的方法，通过传入一个类实例，就可以直接使用 Field 实例操作该实例的当前字段属性的值。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个待反射类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;People&gt; cls = People.class;</span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">name.set(people,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(people.name);</span><br></pre></td></tr></table></figure>

<p>程序会输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>其实也很简单，set 方法会检索 People 对象是否具有一个 name 代表的字段，如果有将字符串 hello 赋值给该字段即可。</p>
<p>整个 Field 类主要由两大部分组成，第一部分就是有关该字段属性的描述信息，例如名称，类型，外围类 Class 对象等，第二部分就是大量的 get 和 set 方法用于间接操作任意的外围类实例的当前属性值。</p>
<h3 id="3-反射方法"><a href="#3-反射方法" class="headerlink" title="3. 反射方法"></a>3. 反射方法</h3><p>同样的，Class 类也提供了四种方法来获取其中的方法属性：</p>
<ul>
<li>public Method[] getMethods()：返回所有的 public 方法，包括父类中的</li>
<li>public Method getMethod(String name, Class&lt;?&gt;… parameterTypes)：返回指定的方法</li>
<li>public Method[] getDeclaredMethods()：返回本类申明的所有方法，包括非 public 修饰的，但不包括父类中的</li>
<li>public Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes)：同理</li>
</ul>
<p>Method 抽象地代表了一个方法，同样有描述这个方法基本信息的字段和方法，例如方法名，方法的参数集合，方法的返回值类型，异常类型集合，方法的注解等。</p>
<p>除此之外的还有一个 invoke 方法用于间接调用其他实例的该方法，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">People</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello wrold &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;People&gt; cls = People.class;</span><br><span class="line"><span class="type">Method</span> <span class="variable">sayHello</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line"><span class="type">People</span> <span class="variable">people</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">People</span>();</span><br><span class="line">sayHello.invoke(people);</span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello wrold</span><br></pre></td></tr></table></figure>

<h3 id="4-反射构造器"><a href="#4-反射构造器" class="headerlink" title="4. 反射构造器"></a>4. 反射构造器</h3><p>对于 Constructor 来说，Class 类依然为它提供了四种获取实例的方法：</p>
<ul>
<li>public Constructor&lt;?&gt;[] getConstructors()：返回所有 public 修饰的构造器</li>
<li>public Constructor&lt;?&gt;[] getDeclaredConstructors()：返回所有的构造器，无视访问修饰符</li>
<li>public Constructor getConstructor(Class&lt;?&gt;… parameterTypes)：带指定参数的</li>
<li>public Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes) ：同理</li>
</ul>
<p>Constructor 本质上也是一个方法，只是没有返回值而已，所以内部的基本内容和 Method 是类似的，只不过 Constructor 类中有一个 newInstance 方法用于创建一个该 Class 类型的实例对象出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最简单的一个反射创建实例的过程</span></span><br><span class="line">Class&lt;People&gt; cls = People.class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">c</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line"><span class="type">People</span> <span class="variable">p</span> <span class="operator">=</span> (People) c.newInstance();</span><br></pre></td></tr></table></figure>

<p>以上，我们简单的介绍了反射的基本使用情况，但都很基础，下面我们看看反射和一些稍微复杂的类型结合使用的情况，例如：数组，泛型，注解等。</p>
<h3 id="5-反射的其他细节"><a href="#5-反射的其他细节" class="headerlink" title="5. 反射的其他细节"></a>5. 反射的其他细节</h3><h4 id="5-1-反射与数组"><a href="#5-1-反射与数组" class="headerlink" title="5.1 反射与数组"></a>5.1 <strong>反射与数组</strong></h4><p>我们都知道，数组是一种特殊的类型，它本质上由虚拟机在运行时动态生成，所以在反射这种类型的时候会稍有不同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> Class&lt;?&gt; getComponentType();</span><br></pre></td></tr></table></figure>

<p>Class 中有这么一个方法，该方法将返回数组 Class 实例元素的基本类型。只有当前的 Class 对象代表的是一个数组类型的时候，该方法才会返回数组的元素实际类型，其他的任何时候都会返回 null。</p>
<p>当然，有一点需要注意下，代表数组的这个由虚拟机动态创建的类型，它直接继承的 Object 类，并且所有有关数组类的操作，比如为某个元素赋值或是获取数组长度的操作都直接对应一个单独的虚拟机数组操作指令。</p>
<p>同样也因为数组类直接由虚拟机运行时动态创建，所以你不可能从一个数组类型的 Class 实例中得到构造方法，编译器根本没机会为类生成默认的构造器。于是你也不能以常规的方法通过 Constructor 来创建一个该类的实例对象。</p>
<p>如果你非要尝试使用 Constructor 来创建一个新的实例的话，那么运行时程序将告诉你无法匹配一个构造器。像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String[]&gt; cls = String[].class;</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> cls.getConstructor();</span><br><span class="line">String[] strs = (String[]) constructor.newInstance();</span><br></pre></td></tr></table></figure>

<p>控制台输出：</p>
<p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gaf6k587kej30kq04oaaz.jpg"></p>
<p>告诉你，Class 实例中根本找不到一个无参的构造器。那么难道我们就没有办法来动态创建一个数组了吗？</p>
<p>当然不是，Java 中有一个类 java.lang.reflect.Array 提供了一些静态的方法用于动态的创建和获取一个数组类型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//创建一个一维数组，componentType 为数组元素类型，length 数组长度</span><br><span class="line">public static Object newInstance(Class&lt;?&gt; componentType, int length)</span><br><span class="line"></span><br><span class="line">//可变参数 dimensions，指定多个维度的单维度长度</span><br><span class="line">public static Object newInstance(Class&lt;?&gt; componentType, int... dimensions)</span><br></pre></td></tr></table></figure>

<p>这是我认为 Array 类中最重要的两个方法，当然了 Array 类中还有一些其它方法用于获取指定数组的指定位置元素，这里不再赘述了。</p>
<p>完全是因为数组这种类型并不是由常规的编译器编译生成，而是由虚拟机动态创建的，所以想要通过反射的方式实例化一个数组类型是得依赖 Array 这个类型的相关 newInstance 方法的。</p>
<h4 id="5-2-反射与泛型"><a href="#5-2-反射与泛型" class="headerlink" title="5.2 反射与泛型"></a>5.2 <strong>反射与泛型</strong></h4><p>泛型是 Java 编译器范围内的概念，它能够在程序运行之前提供一定的安全检查，而反射是运行时发生的，也就是说如果你反射调用一个泛型方法，实际上就绕过了编译器的泛型检查了。我们看一段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">list.add(<span class="number">23</span>);</span><br><span class="line"><span class="comment">//list.add(&quot;fads&quot;);编译不通过</span></span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; cls = list.getClass();</span><br><span class="line"><span class="type">Method</span> <span class="variable">add</span> <span class="operator">=</span> cls.getMethod(<span class="string">&quot;add&quot;</span>,Object.class);</span><br><span class="line">add.invoke(list,<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">System.out.println(list.get(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p>最终你会发现我们从整型容器中取出一个字符串，因为虚拟机只管在运行时从方法区找到 ArrayList 这个类的类型信息并解析出它的 add 方法，接着执行这个方法。</p>
<p>它不像一般的方法调用，调用之前编译器会检测这个方法存在不存在，参数类型是否匹配等，所以没了编译器的这层安全检查，反射地调用方法更容易遇到问题。</p>
<p>除此之外，之前我们说过的泛型在经过编译期之后会被类型擦除，但实际上代表该类型的 Class 类型信息中是保存有一些基本的泛型信息的，这一点我们可以通过反射得到。</p>
<p>这里不再带大家一起去看了，Class ，Field 和 Method 中都是有相关方法可以获取类或者方法在定义的时候所使用到的泛型类名名称。注意这里说的，只是名称，类似 E、V 这样的东西。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Spring-IOC过程源码分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/12/30/Spring-IOC%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"
    >Spring IOC过程源码分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/12/30/Spring-IOC%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2019-12-29T16:04:10.000Z" itemprop="datePublished">2019-12-30</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>作者：<a target="_blank" rel="noopener" href="http://vc2x.com/" title="valarchie">valarchie</a><br>原文地址：<a target="_blank" rel="noopener" href="http://vc2x.com/articles/2019/09/10/1568056055049.html">http://vc2x.com/articles/2019/09/10/1568056055049.html</a></p>
<p>小结：</p>
<ul>
<li>第一步：读取 xml 文件形成 DOM 对象</li>
<li>第二步：读取 DOM 文档对象里的 Bean 定义并装载进 BeanFactory 中</li>
<li>第三步：使用创建好的 Bean 定义，开始实例化 Bean。</li>
</ul>
</blockquote>
<h3 id="废话不多说，我们先做一个傻瓜版的-IOC-demo-作为例子"><a href="#废话不多说，我们先做一个傻瓜版的-IOC-demo-作为例子" class="headerlink" title="废话不多说，我们先做一个傻瓜版的 IOC demo 作为例子"></a>废话不多说，我们先做一个傻瓜版的 IOC demo 作为例子</h3><p>自定义的 Bean 定义</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBeanDefinition</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String id;</span><br><span class="line">    <span class="keyword">public</span> String className;</span><br><span class="line">    <span class="keyword">public</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBeanDefinition</span><span class="params">(String id, String className, String value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.className = className;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的 Bean 工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBeanFactory</span><span class="params">(MyBeanDefinition beanDefinition)</span> <span class="keyword">throws</span> ClassNotFoundException,</span><br><span class="line">            IllegalAccessException, InstantiationException &#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; beanClass = Class.forName(beanDefinition.className);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> beanClass.newInstance();</span><br><span class="line">        ((UserService) bean).setName(beanDefinition.value);</span><br><span class="line">        beanMap.put(beanDefinition.id, bean);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getBean</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试傻瓜版 IOC 容器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyIOC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MyBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanDefinition</span>(<span class="string">&quot;userService&quot;</span>,</span><br><span class="line">                <span class="string">&quot;com.valarchie.UserService&quot;</span>, <span class="string">&quot;archie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">MyBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBeanFactory</span>(beanDefinition);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) beanFactory.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(userService.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="看完以上这个傻瓜版的例子我们可以思考一下？让我们自己实现-IOC-的容器的关键是什么呢？"><a href="#看完以上这个傻瓜版的例子我们可以思考一下？让我们自己实现-IOC-的容器的关键是什么呢？" class="headerlink" title="看完以上这个傻瓜版的例子我们可以思考一下？让我们自己实现 IOC 的容器的关键是什么呢？"></a>看完以上这个傻瓜版的例子我们可以思考一下？让我们自己实现 IOC 的容器的关键是什么呢？</h3><p>按照我的理解，我总结为以下三步</p>
<ul>
<li>读取 xml 文件形成 DOM 对象</li>
<li>读取 DOM 文档对象里的 Bean 定义并装载进 BeanFactory 中</li>
<li>根据 bean 定义生成实例放进容器，以供使用</li>
</ul>
<p>所以，接下来我们不会通盘分析整个 IOC 的流程，因为旁枝细节太多读者看完也云里雾里抓不到重点。<br>我们通过分析最重要的这条代码主干线来理解 IOC 的过程。</p>
<h2 id="开始分析："><a href="#开始分析：" class="headerlink" title="开始分析："></a>开始分析：</h2><p>首先我们从 xml 的配置方式开始分析，因为 Spring 最初的配置方式就是利用 xml 来进行配置，所以大部分人对 xml 的配置形式较为熟悉，也比较方便理解。</p>
<p>从 ClassPathXmlApplicationContext 的构造器开始讲起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestSpring</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// IOC容器的启动就从ClassPathXmlApplicationContext的构造方法开始</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:application.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) context.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        System.out.println(userService.getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到构造方法中，调用重载的另一个构造方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建ClassPathXmlApplicationContext，加载给定的位置的xml文件，并自动刷新context</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">		<span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">String</span>[] &#123;configLocation&#125;, <span class="literal">true</span>, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重载的构造方法中，由于刚才 parrent 参数传为 null，所以不设置父容器。refresh 刚才设置为 true，流程就会进入 refresh()方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="type">boolean</span> refresh, ApplicationContext parent)</span></span><br><span class="line">			<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 由于之前的方法调用将parent设置为null，所以我们就不分析了</span></span><br><span class="line">		<span class="built_in">super</span>(parent);</span><br><span class="line">		<span class="comment">// 设置路径数组，并依次对配置路径进行简单占位符替换处理，比较简单，我们也不进入分析了</span></span><br><span class="line">		setConfigLocations(configLocations);</span><br><span class="line">		<span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">			refresh();</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 refresh()方法中就是 IOC 容器启动的主干脉络了，Spring 采用了模板方法设计模式进行 refresh()方法的设计，先规定好整个 IOC 容器的具体步骤，然后将每一个小步骤由各种不同的子类自己实现。</p>
<p>所有重要的操作都是围绕着 BeanFactory 在进行。<br>在注释当中，我们详细的列出了每一步方法所完成的事情。ApplicationContext 内部持有了 FactoryBean 的实例。其实 ApplicationContext 本身最上层的父接口也是 BeanFactory，他拓展了 BeanFactory 之外的功能（提供国际化的消息访问、资源访问，如 URL 和文件、事件传播、载入多个（有继承关系）上下文）</p>
<p>我们先通过阅读代码中的注释来了解大概的脉络。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException &#123;</span><br><span class="line">        <span class="comment">// 先加锁防止启动、结束冲突</span></span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">			<span class="comment">// 在刷新之前做一些准备工作</span></span><br><span class="line">			<span class="comment">// 设置启动的时间、相关状态的标志位（活动、关闭）、初始化占位符属性源，并确认</span></span><br><span class="line">			<span class="comment">// 每个标记为必须的属性都是可解析的。</span></span><br><span class="line">			prepareRefresh();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取一个已刷新的BeanFactory实例。</span></span><br><span class="line">			<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 定义好Bean工厂的环境特性，例如类加载器，或者后置处理器</span></span><br><span class="line">			prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 设置在BeanFactory完成初始化之后做一些后置操作，spring留给子类的扩展。</span></span><br><span class="line">				postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 启动之前已设置的BeanFactory后置处理器</span></span><br><span class="line">				invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 注册Bean处理器</span></span><br><span class="line">				registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 为我们的应用上下文设置消息源（i18n）</span></span><br><span class="line">				initMessageSource();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 初始化事件广播器</span></span><br><span class="line">				initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 初始化特殊的Bean在特殊的Context中，默认实现为空，交给各个具体子类实现</span></span><br><span class="line">				onRefresh();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 检查监听器并注册</span></span><br><span class="line">				registerListeners();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 实例化所有非懒加载的Bean</span></span><br><span class="line">				finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 最后一步发布相应的事件</span></span><br><span class="line">				finishRefresh();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">					logger.warn(<span class="string">&quot;Exception encountered during context initialization - &quot;</span> +</span><br><span class="line">							<span class="string">&quot;cancelling refresh attempt: &quot;</span> + ex);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 如果启动失败的话，要销毁之前创建的Beans。</span></span><br><span class="line">				destroyBeans();</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 重置ApplicationContext内部active的标志位</span></span><br><span class="line">				cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 向调用者抛出异常</span></span><br><span class="line">				<span class="keyword">throw</span> ex;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">finally</span> &#123;</span><br><span class="line">			    <span class="comment">// 重置Spring核心内的缓存，因为我们可能不再需要单例bean相关的元数据</span></span><br><span class="line">				resetCommonCaches();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>阅读完之后我们重点关注 obtainFreshBeanFactory()、finishBeanFactoryInitialization(beanFactory)这两个方法，因为实质上整个 IOC 的流程都在这两个方法当中，其他的方法一部分是 Spring 预留给用户的自定义操作如 BeanFactory 的后置处理器和 Bean 后置处理器，一部分是关键启动事件的发布和监听操作，一部分是关于 AOP 的操作。</p>
<p>首先，先从 obtainFreshBeanFactory()开始说起。</p>
<h2 id="第一步：读取-xml-文件形成-DOM-对象"><a href="#第一步：读取-xml-文件形成-DOM-对象" class="headerlink" title="第一步：读取 xml 文件形成 DOM 对象"></a>第一步：读取 xml 文件形成 DOM 对象</h2><p>在 getBeanFactory()方法之前，先调用 refreshBeanFactory()方法进行刷新。我们先说明一下，getBeanFactory()非常简单，默认实现只是将上一步刷新成功好构建好的 Bean 工厂进行返回。返回出去的 Bean 工厂已经加载好 Bean 定义了。所以在 refreshBeanFactory()这个方法中已经包含了第一步读取 xml 文件构建 DOM 对象和第二步解析 DOM 中的元素生成 Bean 定义进行保存。记住，这里仅仅是保存好 Bean 定义，此时并未涉及 Bean 的实例化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title function_">obtainFreshBeanFactory</span><span class="params">()</span> &#123;</span><br><span class="line">		refreshBeanFactory();</span><br><span class="line">		<span class="type">ConfigurableListableBeanFactory</span> <span class="variable">beanFactory</span> <span class="operator">=</span> getBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			logger.debug(<span class="string">&quot;Bean factory for &quot;</span> + getDisplayName() + <span class="string">&quot;: &quot;</span> + beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 refreshBeanFactory()方法中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">protected final void refreshBeanFactory() throws BeansException &#123;</span><br><span class="line">        // 如果当前ApplicationContext中已存在FactoryBean的话进行销毁</span><br><span class="line">		if (hasBeanFactory()) &#123;</span><br><span class="line">			destroyBeans();</span><br><span class="line">			closeBeanFactory();</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">		    // 先生成一个BeanFactory</span><br><span class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">			// 设置序列化</span><br><span class="line">			beanFactory.setSerializationId(getId());</span><br><span class="line">			// 设置是否可以覆盖Bean定义和是否可以循环依赖，具体我就不解释了</span><br><span class="line">			customizeBeanFactory(beanFactory);</span><br><span class="line">			// 加载Bean定义到Factory当中去</span><br><span class="line">			// 重点！</span><br><span class="line">			loadBeanDefinitions(beanFactory);</span><br><span class="line">			synchronized (this.beanFactoryMonitor) &#123;</span><br><span class="line">				this.beanFactory = beanFactory;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，进入核心方法 loadBeanDefinitions(beanFactory)中，参数是刚创建的 beanFactory</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123;</span><br><span class="line">		// 根据传入的beanfactory创建一个xml读取器</span><br><span class="line">		XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		// 设置bean定义读取器的相关资源加载环境</span><br><span class="line">		beanDefinitionReader.setEnvironment(this.getEnvironment());</span><br><span class="line">		beanDefinitionReader.setResourceLoader(this);</span><br><span class="line">		beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));</span><br><span class="line"></span><br><span class="line">		// 这个方法让子类自定义读取器Reader的初始化</span><br><span class="line">		initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">		// 接着开始实际加载Bean定义</span><br><span class="line">		loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>进入 loadBeanDefinitions(beanDefinitionReader)方法中，参数是刚刚创建好的 Reader 读取器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123;</span><br><span class="line">        // 如果有已经生成好的Resouce实例的话就直接进行解析。</span><br><span class="line">        // 默认的实现是返回null，由子类自行实现。</span><br><span class="line">		Resource[] configResources = getConfigResources();</span><br><span class="line">		if (configResources != null) &#123;</span><br><span class="line">			reader.loadBeanDefinitions(configResources);</span><br><span class="line">		&#125;</span><br><span class="line">		// 没有Resouces的话就进行路径解析。</span><br><span class="line">		String[] configLocations = getConfigLocations();</span><br><span class="line">		if (configLocations != null) &#123;</span><br><span class="line">			reader.loadBeanDefinitions(configLocations);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们进入 reader.loadBeanDefinitions(configLocations)方法中，这里面方法调用有点绕，我这边只简单地描述一下</p>
<p>该方法会根据多个不同位置的 xml 文件依次进行处理。<br>接着会对路径的不同写法进行不同处理，例如 classpath 或者 WEB-INF 的前缀路径。<br>根据传入的 locations 变量生成对应的 Resouces。<br>紧接着进入 reader.loadBeanDefinitions(resource)此时参数是 Resource。<br>在经过一层进入 loadBeanDefinitions(new EncodedResource(resource))的方法调用中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">	Assert.notNull(encodedResource, <span class="string">&quot;EncodedResource must not be null&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">		logger.info(<span class="string">&quot;Loading XML bean definitions from &quot;</span> + encodedResource.getResource());</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 通过ThreadLocal实现的当前currentResource</span></span><br><span class="line">	Set&lt;EncodedResource&gt; currentResources = <span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">	<span class="keyword">if</span> (currentResources == <span class="literal">null</span>) &#123;</span><br><span class="line">		currentResources = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">		<span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">				<span class="string">&quot;Detected cyclic loading of &quot;</span> + encodedResource + <span class="string">&quot; - check your import definitions!&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">// 最主要的方法在这段</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> encodedResource.getResource().getInputStream();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">// 传入流对象，并设置好编码</span></span><br><span class="line">			<span class="type">InputSource</span> <span class="variable">inputSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputSource</span>(inputStream);</span><br><span class="line">			<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="literal">null</span>) &#123;</span><br><span class="line">				inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">finally</span> &#123;</span><br><span class="line">			inputStream.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionStoreException</span>(</span><br><span class="line">				<span class="string">&quot;IOException parsing XML document from &quot;</span> + encodedResource.getResource(), ex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">finally</span> &#123;</span><br><span class="line">		currentResources.remove(encodedResource);</span><br><span class="line">		<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">			<span class="built_in">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法最主要是创建了对应的输入流，并设置好编码。</p>
<p>然后开始调用 doLoadBeanDefinitions()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部核心代码就这两句</span></span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 loadDocument()方法中会生成一个 DocumentBuilderImpl 对象，这个对象会调用 parse 方法，在 parse 方法中使用 SAX 进行解析刚才的输入流包装的 InputSource，生成 DOM 对象返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Document <span class="title function_">parse</span><span class="params">(InputSource is)</span> <span class="keyword">throws</span> SAXException, IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (is == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                DOMMessageFormatter.formatMessage(DOMMessageFormatter.DOM_DOMAIN,</span><br><span class="line">                <span class="string">&quot;jaxp-null-input-source&quot;</span>, <span class="literal">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fSchemaValidator != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fSchemaValidationManager != <span class="literal">null</span>) &#123;</span><br><span class="line">                fSchemaValidationManager.reset();</span><br><span class="line">                fUnparsedEntityHandler.reset();</span><br><span class="line">            &#125;</span><br><span class="line">            resetSchemaValidator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析xml</span></span><br><span class="line">        domParser.parse(is);</span><br><span class="line">        <span class="comment">// 获取刚才解析好的dom</span></span><br><span class="line">        <span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> domParser.getDocument();</span><br><span class="line">        domParser.dropDocumentReferences();</span><br><span class="line">        <span class="keyword">return</span> doc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="此时我们的-xml-文件已经加载并解析成-DOM-结构对象了，第一步已经完成了。"><a href="#此时我们的-xml-文件已经加载并解析成-DOM-结构对象了，第一步已经完成了。" class="headerlink" title="此时我们的 xml 文件已经加载并解析成 DOM 结构对象了，第一步已经完成了。"></a>此时我们的 xml 文件已经加载并解析成 DOM 结构对象了，第一步已经完成了。</h4><h2 id="第二步：读取-DOM-文档对象里的-Bean-定义并装载进-BeanFactory-中"><a href="#第二步：读取-DOM-文档对象里的-Bean-定义并装载进-BeanFactory-中" class="headerlink" title="第二步：读取 DOM 文档对象里的 Bean 定义并装载进 BeanFactory 中"></a>第二步：读取 DOM 文档对象里的 Bean 定义并装载进 BeanFactory 中</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部核心代码就这两句</span></span><br><span class="line"><span class="type">Document</span> <span class="variable">doc</span> <span class="operator">=</span> doLoadDocument(inputSource, resource);</span><br><span class="line"><span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们再回到刚刚讲到的这两句核心代码，第一句获取 DOM 对象后，紧接着第二句 registerBeanDefinitions(doc, resource)开始了 bean 定义的注册工作。</p>
<p>进入 registerBeanDefinitions(doc, resource)方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException &#123;</span><br><span class="line">    <span class="comment">// 生成DOM读取器，这个和刚才的读取器不一样，之前的读取器是xml读取器。</span></span><br><span class="line">		<span class="type">BeanDefinitionDocumentReader</span> <span class="variable">documentReader</span> <span class="operator">=</span> createBeanDefinitionDocumentReader();</span><br><span class="line">		<span class="comment">// 获取之前的bean定义数量</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">countBefore</span> <span class="operator">=</span> getRegistry().getBeanDefinitionCount();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 进入重点</span></span><br><span class="line">		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 用刚刚又创建的bean定义数量 - 之前的bean定义数量 = 刚刚一共创建的bean定义</span></span><br><span class="line">		<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 documentReader.registerBeanDefinitions(doc, createReaderContext(resource))方法。<br>方法内读取文档的 root 元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> &#123;</span><br><span class="line">		<span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">		<span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">		<span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">		<span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">		<span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">		<span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">		<span class="type">BeanDefinitionParserDelegate</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="built_in">this</span>.delegate;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 生成Bean定义解析类</span></span><br><span class="line">		<span class="built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是xml文档中的namespace，进行相应处理</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">			<span class="type">String</span> <span class="variable">profileSpec</span> <span class="operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">			<span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">				<span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">						logger.info(<span class="string">&quot;Skipped XML bean definition file due to specified profiles [&quot;</span> + profileSpec +</span><br><span class="line">								<span class="string">&quot;] not matching: &quot;</span> + getReaderContext().getResource());</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// spring预留给子类的拓展性方法</span></span><br><span class="line">		preProcessXml(root);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 重点</span></span><br><span class="line">		<span class="comment">// 开始解析Bean定义</span></span><br><span class="line">		parseBeanDefinitions(root, <span class="built_in">this</span>.delegate);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// spring预留给子类的拓展性方法</span></span><br><span class="line">		postProcessXml(root);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">this</span>.delegate = parent;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入 parseBeanDefinitions(root, this.delegate)。将之前的文档对象和 bean 定义解析类作为参数传入。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">			<span class="type">NodeList</span> <span class="variable">nl</span> <span class="operator">=</span> root.getChildNodes();</span><br><span class="line">			<span class="comment">// 遍历去解析根节点的每个子节点元素</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">				<span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> nl.item(i);</span><br><span class="line">				<span class="comment">// 如果是标签元素的话</span></span><br><span class="line">				<span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">					<span class="type">Element</span> <span class="variable">ele</span> <span class="operator">=</span> (Element) node;</span><br><span class="line">					<span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line"></span><br><span class="line">					    <span class="comment">// 解析默认的元素</span></span><br><span class="line">					    <span class="comment">// 重点</span></span><br><span class="line">						parseDefaultElement(ele, delegate);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">					    <span class="comment">// 解析指定自定义元素</span></span><br><span class="line">						delegate.parseCustomElement(ele);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">		    <span class="comment">// 非默认命名空间的，进行自定义解析，命名空间就是xml文档头内的xmlns，用来定义标签。</span></span><br><span class="line">			delegate.parseCustomElement(root);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到 parseDefaultElement(ele, delegate)当中，会发现其实对四种标签进行分别的解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">			importBeanDefinitionResource(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">			processAliasRegistration(ele);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">		    <span class="comment">// 分析Bean标签</span></span><br><span class="line">			processBeanDefinition(ele, delegate);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">			<span class="comment">// recurse</span></span><br><span class="line">			doRegisterBeanDefinitions(ele);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要分析 Bean 元素标签的解析，进入 processBeanDefinition(ele, delegate)方法中最内层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> BeanDefinitionHolder <span class="title function_">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取bean标签内的id</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">		<span class="comment">// 获取bean标签内的name</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">nameAttr</span> <span class="operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置多别名</span></span><br><span class="line">		List&lt;String&gt; aliases = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">		<span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">			aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当没有设置id的时候</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> id;</span><br><span class="line">		<span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">			beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;No XML &#x27;id&#x27; specified - using &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; as bean name and &quot;</span> + aliases + <span class="string">&quot; as aliases&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查beanName是否唯一</span></span><br><span class="line">		<span class="keyword">if</span> (containingBean == <span class="literal">null</span>) &#123;</span><br><span class="line">			checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 内部做了Bean标签的解析工作</span></span><br><span class="line">		<span class="type">AbstractBeanDefinition</span> <span class="variable">beanDefinition</span> <span class="operator">=</span> parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">		<span class="keyword">if</span> (beanDefinition != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (containingBean != <span class="literal">null</span>) &#123;</span><br><span class="line">						beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">								beanDefinition, <span class="built_in">this</span>.readerContext.getRegistry(), <span class="literal">true</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						beanName = <span class="built_in">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">						<span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">						<span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">						<span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">						<span class="type">String</span> <span class="variable">beanClassName</span> <span class="operator">=</span> beanDefinition.getBeanClassName();</span><br><span class="line">						<span class="keyword">if</span> (beanClassName != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">								!<span class="built_in">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">							aliases.add(beanClassName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(<span class="string">&quot;Neither XML &#x27;id&#x27; nor &#x27;name&#x27; specified - &quot;</span> +</span><br><span class="line">								<span class="string">&quot;using generated bean name [&quot;</span> + beanName + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">					error(ex.getMessage(), ele);</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BeanDefinitionHolder</span>(beanDefinition, beanName, aliasesArray);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将解析好的 Bean 定义并附加别名数组填入 new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray)中进行返回。然后调用以下这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry())</span><br></pre></td></tr></table></figure>

<p>最主要的操作就是将刚才解析好的 Bean 定义放入 beanDefinitionMap 中去。</p>
<h4 id="解析成功后将-Bean-定义进行保存。第二步也已经完成。"><a href="#解析成功后将-Bean-定义进行保存。第二步也已经完成。" class="headerlink" title="解析成功后将 Bean 定义进行保存。第二步也已经完成。"></a>解析成功后将 Bean 定义进行保存。第二步也已经完成。</h4><h2 id="第三步：使用创建好的-Bean-定义，开始实例化-Bean。"><a href="#第三步：使用创建好的-Bean-定义，开始实例化-Bean。" class="headerlink" title="第三步：使用创建好的 Bean 定义，开始实例化 Bean。"></a>第三步：使用创建好的 Bean 定义，开始实例化 Bean。</h2><p>我们回到最开始的 refresh 方法中，在 finishBeanFactoryInitialization(beanFactory)方法中，开始实例化非懒加载的 Bean 对象。我们跟着调用链进入到 preInstantiateSingletons()方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">		<span class="built_in">this</span>.logger.debug(<span class="string">&quot;Pre-instantiating singletons in &quot;</span> + <span class="built_in">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将之前做好的bean定义名列表拷贝放进beanNames中，然后开始遍历</span></span><br><span class="line">	List&lt;String&gt; beanNames = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(<span class="built_in">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 触发所有非懒加载的单例Bean实例化</span></span><br><span class="line">	<span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">		<span class="type">RootBeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果非抽象并且是单例和非懒加载的话</span></span><br><span class="line">		<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">		    <span class="comment">// 检测是否是工厂方法Bean。 创建Bean的不同方式，读者可自行百度。</span></span><br><span class="line">			<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">				<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">				<span class="type">boolean</span> isEagerInit;</span><br><span class="line">				<span class="keyword">if</span> (System.getSecurityManager() != <span class="literal">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">					isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="keyword">public</span> Boolean <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;, getAccessControlContext());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">							((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				getBean(beanName);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于实例化之后做的自定义操作代码省略....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中根据 Bean 实例是通过工厂方法实例还是普通实例化，最主要的方法还是 getBean(beanName)方法。我们继续分析普通实例化的过程。进入 getBean()方法当中 doGetBean()方法，发现方法参数 doGetBean(name, null, null, false)后三个参数全部为 null,它就是整个 IOC 中的核心代码。</p>
<p>代码中先通过实例化 Bean,实例化好之后再判断该 Bean 所需的依赖，并递归调用进行实例化 bean，成功后整个 IOC 的核心流程也就完成了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; T <span class="title function_">doGetBean</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="type">boolean</span> typeCheckOnly)</span></span><br><span class="line">		<span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">final</span> <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> transformedBeanName(name);</span><br><span class="line">	Object bean;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从缓存中获取beanName对应的单例</span></span><br><span class="line">	<span class="type">Object</span> <span class="variable">sharedInstance</span> <span class="operator">=</span> getSingleton(beanName);</span><br><span class="line">	<span class="keyword">if</span> (sharedInstance != <span class="literal">null</span> &amp;&amp; args == <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">						<span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 返回beanName对应的实例对象（主要用于FactoryBean的特殊处理，</span></span><br><span class="line">		<span class="comment">// 普通Bean会直接返回sharedInstance本身）</span></span><br><span class="line">		bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">	    <span class="comment">// scope为prototype的循环依赖校验：如果beanName已经正在创建Bean实</span></span><br><span class="line">	    <span class="comment">// 例中，而此时我们又要再一次创建beanName的实例，则代表出现了循环</span></span><br><span class="line">	    <span class="comment">// 依赖，需要抛出异常。</span></span><br><span class="line">            <span class="comment">// 例子：如果存在A中有B的属性，B中有A的属性，那么当依赖注入的时候</span></span><br><span class="line">            <span class="comment">//，就会产生当A还未创建完的时候因为对于B的创建再次返回创建A，造成</span></span><br><span class="line">            <span class="comment">//循环依赖</span></span><br><span class="line">		<span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//如果parentBeanFactory存在，并且beanName在当前BeanFactory不存在</span></span><br><span class="line">    	<span class="comment">//Bean定义，则尝试从parentBeanFactory中获取bean实例</span></span><br><span class="line">		<span class="type">BeanFactory</span> <span class="variable">parentBeanFactory</span> <span class="operator">=</span> getParentBeanFactory();</span><br><span class="line">		<span class="keyword">if</span> (parentBeanFactory != <span class="literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			<span class="comment">// 将别名解析成真正的beanName</span></span><br><span class="line">			<span class="type">String</span> <span class="variable">nameToLookup</span> <span class="operator">=</span> originalBeanName(name);</span><br><span class="line">			<span class="keyword">if</span> (args != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">				<span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">				<span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不需要类型检查的话 标记为已创建</span></span><br><span class="line">		<span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">			markBeanAsCreated(beanName);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">		    <span class="comment">// 将子Bean定义与父Bean定义进行整合</span></span><br><span class="line">			<span class="keyword">final</span> <span class="type">RootBeanDefinition</span> <span class="variable">mbd</span> <span class="operator">=</span> getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="comment">// 整合后如果发现是抽象类不能实例 抛出异常</span></span><br><span class="line">			checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 获取Bean定义所需的依赖并逐一初始化填充</span></span><br><span class="line">			String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">			<span class="keyword">if</span> (dependsOn != <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">				    <span class="comment">// 判断是否循环依赖</span></span><br><span class="line">					<span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 注册依赖的Bean</span></span><br><span class="line">					registerDependentBean(dep, beanName);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="comment">// 递归调用生成所需依赖的Bean</span></span><br><span class="line">						getBean(dep);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line">								<span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 如果是单例的话</span></span><br><span class="line">			<span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">				sharedInstance = getSingleton(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">							<span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">							<span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">							<span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">							destroySingleton(beanName);</span><br><span class="line">							<span class="keyword">throw</span> ex;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是原型的话</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">				<span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">				<span class="type">Object</span> <span class="variable">prototypeInstance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					beforePrototypeCreation(beanName);</span><br><span class="line">					prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					afterPrototypeCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">			&#125;</span><br><span class="line">            		<span class="comment">// 非单例和原型 范围的情况 例如session,request等情况</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="type">String</span> <span class="variable">scopeName</span> <span class="operator">=</span> mbd.getScope();</span><br><span class="line">				<span class="keyword">final</span> <span class="type">Scope</span> <span class="variable">scope</span> <span class="operator">=</span> <span class="built_in">this</span>.scopes.get(scopeName);</span><br><span class="line">				<span class="keyword">if</span> (scope == <span class="literal">null</span>) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="type">Object</span> <span class="variable">scopedInstance</span> <span class="operator">=</span> scope.get(beanName, <span class="keyword">new</span> <span class="title class_">ObjectFactory</span>&lt;Object&gt;() &#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">							beforePrototypeCreation(beanName);</span><br><span class="line">							<span class="keyword">try</span> &#123;</span><br><span class="line">								<span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">finally</span> &#123;</span><br><span class="line">								afterPrototypeCreation(beanName);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">					bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(beanName,</span><br><span class="line">							<span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">							<span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">							ex);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">			cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">			<span class="keyword">throw</span> ex;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检测实例Bean的类型和所需类型是否一致</span></span><br><span class="line">	<span class="keyword">if</span> (requiredType != <span class="literal">null</span> &amp;&amp; bean != <span class="literal">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">						ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanNotOfRequiredTypeException</span>(name, requiredType, bean.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="根据-Bean-定义去实例化-Bean。第三步也已经完成。"><a href="#根据-Bean-定义去实例化-Bean。第三步也已经完成。" class="headerlink" title="根据 Bean 定义去实例化 Bean。第三步也已经完成。"></a>根据 Bean 定义去实例化 Bean。第三步也已经完成。</h4><p>文章篇幅有限，IOC 整个的创建过程还是比较冗长的，希望读者看完文章对 IOC 的创建过程有一个主干脉络的思路之后还是需要翻开源码进行解读，其实阅读源码并不难，因为 Spring 的代码注释都挺健全，如果遇到不清楚的稍微 google 一下就知道了。建议读者自己试着一步一步的分析 IOC 过程的源码。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/6/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> 高行行
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="高行行的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://gaohanghang.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/twitter">Twitter</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://weibo.com/u/5125203090">微博</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>