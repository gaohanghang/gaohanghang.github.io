<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="个人公众号《骇客与画家》" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 高行行的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">高行行的个人博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '科技需要人文的浇灌', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-思考-10-犹豫就会败北"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/16/%E6%80%9D%E8%80%83-10-%E7%8A%B9%E8%B1%AB%E5%B0%B1%E4%BC%9A%E8%B4%A5%E5%8C%97/"
    >思考 10 犹豫就会败北 🤔</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/16/%E6%80%9D%E8%80%83-10-%E7%8A%B9%E8%B1%AB%E5%B0%B1%E4%BC%9A%E8%B4%A5%E5%8C%97/" class="article-date">
  <time datetime="2019-11-16T06:19:32.000Z" itemprop="datePublished">2019-11-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>机会出现的时候，先不要考虑以后会有更好的，先把机会牢牢握在手里再说。</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-深入理解并发-并行，阻塞-非阻塞，同步-异步"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C%EF%BC%8C%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/"
    >深入理解并发 / 并行，阻塞 / 非阻塞，同步 / 异步</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/14/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%B9%B6%E5%8F%91-%E5%B9%B6%E8%A1%8C%EF%BC%8C%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E%EF%BC%8C%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5/" class="article-date">
  <time datetime="2019-11-13T18:41:34.000Z" itemprop="datePublished">2019-11-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>作者：HuangQinJian</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://juejin.im/entry/58ae4636b123db0052b1caf8">https://juejin.im/entry/58ae4636b123db0052b1caf8</a></p>
<p>总结：</p>
<p>阻塞调用是指调用结果返回之前，调用者会进入阻塞状态等待。只有在得到结果之后才会返回。</p>
<p>非阻塞调用是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
<p>同步：在发出一个同步调用时，在没有得到结果之前，该调用就不返回。</p>
<p>异步：在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了。</p>
<p>CPU调度策略：</p>
<ul>
<li>先来先服务 - 时间片轮转调度</li>
<li>优先级调度</li>
<li>最短作业优先</li>
<li>最高响应比优先</li>
<li>多级反馈队列调度</li>
</ul>
</blockquote>
<h2 id="1-阻塞，非阻塞"><a href="#1-阻塞，非阻塞" class="headerlink" title="1. 阻塞，非阻塞"></a>1. 阻塞，非阻塞</h2><p><strong>首先，阻塞这个词来自<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/operatingsystem" title="操作系统">操作系统</a>的线程&#x2F;进程的状态模型中，如下图：</strong></p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191114124427.png"></p>
<p>一个线程&#x2F;进程经历的 5 个状态， 创建，就绪，运行，阻塞，终止。各个状态的转换条件如上图，其中有个阻塞状态，就是说当线程中调用某个函数，需要 IO 请求，或者暂时得不到竞争资源的，操作系统会把该线程阻塞起来，避免浪费 CPU 资源，等到得到了资源，再变成就绪状态，等待 CPU 调度运行。</p>
<blockquote>
<p>阻塞调用是指调用结果返回之前，调用者会进入阻塞状态等待。只有在得到结果之后才会返回。</p>
<p>非阻塞调用是指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p>
</blockquote>
<p>阻塞调用：比如 socket 的 recv()，调用这个函数的线程如果没有数据返回，它会一直阻塞着，也就是 recv() 后面的代码都不会执行了，程序就停在 recv() 这里等待，所以一般把 recv() 放在单独的线程里调用。</p>
<p>非阻塞调用：比如非阻塞 socket 的 send()，调用这个函数，它只是把待发送的数据复制到 TCP 输出缓冲区中，就立刻返回了，线程并不会阻塞，数据有没有发出去 send() 是不知道的，不会等待它发出去才返回的。</p>
<p><strong>拓展</strong></p>
<p>如果线程始终阻塞着，永远得不到资源，于是就发生了死锁。</p>
<p>比如 A 线程要 X，Y 资源才能继续运行，B 线程也要 X，Y 资源才能运行，但 X，Y 同时只能给一个线程用（即互斥条件）用的时候其他线程又不能抢夺。</p>
<p>A 有 X，等待 Y。<br>B 有 Y，等待 X。</p>
<p>于是 A，B 发生了循环等待，造成死锁。给用户的感觉就是程序卡着不动了。</p>
<p>在写代码的时候要特别注意共享资源的使用，用信号量控制好，避免造成死锁。死锁的解除有个著名的银行家<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/datastructure" title="算法">算法</a></p>
<p>阻塞和挂起：阻塞是被动的，比如抢不到资源。挂起是主动的，线程自己调用 suspend() 把自己退出运行态了，某些时候调用 resume() 又恢复运行。</p>
<p>线程执行完就会被销毁，如果不想线程被频繁的创建，销毁，怎么办？可以给线程里面写个死循环，或者让线程有任务的时候执行，没任务的时候挂起，就像<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/ios" title="iOS">iOS</a>中的 runloop 机制一样。线程就不会随便的终止了。</p>
<h2 id="2-同步，异步"><a href="#2-同步，异步" class="headerlink" title="2. 同步，异步"></a>2. 同步，异步</h2><blockquote>
<p>同步：在发出一个同步调用时，在没有得到结果之前，该调用就不返回。</p>
<p>异步：在发出一个异步调用后，调用者不会立刻得到结果，该调用就返回了。</p>
</blockquote>
<p><strong>同步例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> func();</span><br><span class="line">next();</span><br><span class="line"><span class="comment">// func() 的结果没有返回，next() 就不会执行，直到 func() 运行完。</span></span><br></pre></td></tr></table></figure>

<p><strong>异步例子</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func(callback);</span><br><span class="line">next();</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">callback</span><span class="params">(<span class="type">int</span> n)</span>     <span class="comment">// func 结果回调</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// func() 执行后，还没得出结果就立即返回，然后执行 next() 了</span></span><br><span class="line"><span class="comment">// 等到结果出来，func() 回调 callback() 通知调用者结果。</span></span><br></pre></td></tr></table></figure>

<p>同步的定义看起来跟阻塞很像，但是同步跟阻塞是两个概念， 同步调用的时候，线程不一定阻塞，调用虽然没返回，但它还是在运行状态中的，CPU 很可能还在执行这段代码，而阻塞的话，它就肯定不在 CPU 中跑这个代码了。这就是同步和阻塞的区别。同步是肯定可以在，阻塞是肯定不在。</p>
<p>异步和非阻塞的定义比较像，两者的区别是异步是说调用的时候结果不会马上返回，线程可能被阻塞起来，也可能不阻塞，两者没关系。非阻塞是说调用的时候，线程肯定不会进入阻塞状态。</p>
<p>上面两组概念，就有 4 种组合。</p>
<blockquote>
<p>同步阻塞调用：得不到结果不返回，线程进入阻塞态等待。</p>
<p>同步非阻塞调用：得不到结果不返回，线程不阻塞一直在 CPU 运行。</p>
<p>异步阻塞调用：去到别的线程，让别的线程阻塞起来等待结果，自己不阻塞。</p>
<p>异步非阻塞调用：去到别的线程，别的线程一直在运行，直到得出结果。</p>
</blockquote>
<h2 id="3-并发，并行"><a href="#3-并发，并行" class="headerlink" title="3. 并发，并行"></a>3. 并发，并行</h2><p>先从定义说起，定义经过我通俗化了，原定义有点难理解。</p>
<blockquote>
<p>并发是指一个时间段内，有几个程序都在同一个 CPU 上运行，但任意一个时刻点上只有一个程序在处理机上运行。</p>
<p>并行是指一个时间段内，有几个程序都在几个 CPU 上运行，任意一个时刻点上，有多个程序在同时运行，并且多道程序之间互不干扰。 两者区别如下图</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191114125539.png"></p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191114125607.png"></p>
<p>并行是多个程序在多个 CPU 上同时运行，任意一个时刻可以有很多个程序同时运行，互不干扰。</p>
<p>并发是多个程序在一个 CPU 上运行，CPU 在多个程序之间快速切换，微观上不是同时运行，任意一个时刻只有一个程序在运行，但宏观上看起来就像多个程序同时运行一样，因为 CPU 切换速度非常快，时间片是 64ms（每 64ms 切换一次，不同的操作系统有不同的时间），人类的反应速度是 100ms，你还没反应过来，CPU 已经切换了好几个程序了。</p>
<p>举个例子吧，并行就是，多个人，有人在扫地，有人在做饭，有人在洗衣服，扫地，做饭，洗衣服都是同时进行的。<br>并发就是，有一个人，这个人一会儿扫地，一会儿做饭，一会儿洗衣服，他在这 3 件事中来回做，同一时刻只做一件事，不是同时做的，但最后 3 件事都可以做完。</p>
<p>时间片大小的选取<br>时间片取的小，假设是 20ms，切换耗时假设是 10ms。<br>那么用户感觉不到多个程序之间会卡，响应很快，因为切换太快了，但是 CPU 的利用率就低了，20 &#x2F; (20 + 10) &#x3D; 66% 只有这么多，33%都浪费了。</p>
<p>时间片取的大，假设是 200ms，切换耗时是 10ms<br>那么用户会觉得程序卡，响应慢，因为要 200ms 后才轮到我的程序运行，但是 CPU 利用率就高了，200 &#x2F; (200 + 10) &#x3D; 95% 有这么多被利用的。</p>
<p>所以时间片取太大或者太小都不好，一般在 10 - 100 ms 之间。</p>
<h3 id="3-1-CPU-调度策略"><a href="#3-1-CPU-调度策略" class="headerlink" title="3.1 CPU 调度策略"></a><strong>3.1 CPU 调度策略</strong></h3><p>在并发运行中，CPU 需要在多个程序之间来回切换，那么如何切换就有一些策略</p>
<h4 id="3-1-1-先来先服务-时间片轮转调度"><a href="#3-1-1-先来先服务-时间片轮转调度" class="headerlink" title="3.1.1 先来先服务 - 时间片轮转调度"></a><strong>3.1.1 先来先服务 - 时间片轮转调度</strong></h4><p>这个很简单，就是谁先来，就给谁分配时间片运行，缺点是有些紧急的任务要很久才能得到运行。</p>
<h4 id="3-1-2-优先级调度"><a href="#3-1-2-优先级调度" class="headerlink" title="3.1.2 优先级调度"></a><strong>3.1.2 优先级调度</strong></h4><p>每个线程有一个优先级，CPU 每次去拿优先级高的运行，优先级低的等等，为了避免等太久，每等一定时间，就给线程提高一个优先级</p>
<h4 id="3-1-3-最短作业优先"><a href="#3-1-3-最短作业优先" class="headerlink" title="3.1.3 最短作业优先"></a><strong>3.1.3 最短作业优先</strong></h4><p>把线程任务量排序，每次拿处理时间短的线程运行，就像我去银行办业务一样，我的事情很快就处理完了，所以让我插队先办完，后面时间长的人先等等，时间长的人就很难得到响应了。</p>
<h4 id="3-1-4-最高响应比优先"><a href="#3-1-4-最高响应比优先" class="headerlink" title="3.1.4 最高响应比优先"></a><strong>3.1.4 最高响应比优先</strong></h4><p>用线程的等待时间除以服务时间，得到响应比，响应比小的优先运行。这样不会造成某些任务一直得不到响应。</p>
<h4 id="3-1-5-多级反馈队列调度"><a href="#3-1-5-多级反馈队列调度" class="headerlink" title="3.1.5 多级反馈队列调度"></a><strong>3.1.5 多级反馈队列调度</strong></h4><p>有多个优先级不同的队列，每个队列里面有多个等待线程。<br>CPU 每次从优先级高的遍历到低的，取队首的线程运行，运行完了放回队尾，优先级越高，时间片越短，即响应越快，时间片就不是固定的了。<br>队列内部还是用先来先服务的策略。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-同步和异步的区别"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/14/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB/"
    >同步和异步的区别</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/14/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB/" class="article-date">
  <time datetime="2019-11-13T18:14:26.000Z" itemprop="datePublished">2019-11-14</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/tennysonsky/article/details/45111623">https://blog.csdn.net/tennysonsky/article/details/45111623</a></p>
<p>总结：</p>
<p>区别：</p>
<p>一个需要等待，一个不需要等待</p>
<p>同步需要等待调用返回结果，异步调用直接返回，没有返回结果</p>
</blockquote>
<p>怎样理解阻塞非阻塞与同步异步的区别？ - 严肃的回答 - 知乎 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/19732473/answer/20851256">https://www.zhihu.com/question/19732473/answer/20851256</a></p>
<p>同步和异步关注的是<strong>消息通信机制</strong> (synchronous communication&#x2F; asynchronous communication)<br>所谓同步，就是在发出一个<em>调用</em>时，在没有得到结果之前，该<em>调用</em>就不返回。但是一旦调用返回，就得到返回值了。<br>换句话说，就是由<em>调用者</em>主动等待这个<em>调用</em>的结果。</p>
<p>而异步则是相反，<em><strong>调用*在发出之后，这个调用就直接返回了，所以没有返回结果</strong>。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在</em>调用<em>发出后，</em>被调用者*通过状态、通知来通知调用者，或通过回调函数处理这个调用。</p>
<p>典型的异步编程模型比如Node.js</p>
<p>举个通俗的例子：<br>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。<br>而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-神一样的CAP理论被应用在何方"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/13/%E7%A5%9E%E4%B8%80%E6%A0%B7%E7%9A%84CAP%E7%90%86%E8%AE%BA%E8%A2%AB%E5%BA%94%E7%94%A8%E5%9C%A8%E4%BD%95%E6%96%B9/"
    >神一样的CAP理论被应用在何方</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/13/%E7%A5%9E%E4%B8%80%E6%A0%B7%E7%9A%84CAP%E7%90%86%E8%AE%BA%E8%A2%AB%E5%BA%94%E7%94%A8%E5%9C%A8%E4%BD%95%E6%96%B9/" class="article-date">
  <time datetime="2019-11-13T12:52:01.000Z" itemprop="datePublished">2019-11-13</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>作者：陈于喆</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://juejin.im/post/5d720e86f265da03cc08de74">https://juejin.im/post/5d720e86f265da03cc08de74</a></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lmb55/article/details/78495629" title="基于数据库的分布式锁实现">基于数据库的分布式锁实现</a></p>
<p>总结：</p>
<ol>
<li><p>CAP：C 是一致性（Consistency），A 是可用性(Availability），P 是分区容错性(Partition Tolerance)，CAP 定理中，要么只能 CP，要么只能 AP</p>
<p>网络无法做到 100%可靠，因此必须选择 CP 或 AP 架构。</p>
</li>
<li><p>分布式事务 BASE 理论：基本可用，AP 方案，采用适合的方式达到最终一致性</p>
</li>
<li><p>服务注册选择 AP，可用性比数据一致更加的重要</p>
</li>
<li><p>分布式锁方案选择：搞社交的选 redis 实现分布式锁，AP架构。搞支付金融的选 Zookeeper 实现分布式锁，CP架构。</p>
</li>
<li><p>分布式事务：</p>
<ul>
<li>两阶段提交（2PC）：CP架构，没被改造过的两阶段提交基本很少被业界应用</li>
<li>补偿事务（TCC）：TCC是服务化的两阶段变成模型，每个业务服务都必须实现 try，confirm，calcel三个方法，这三个方式可以对应到SQL事务中Lock，Commit，Rollback。</li>
<li>本地消息表：本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。</li>
<li>MQ 事务消息：RocketMQ中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了MQ内部。</li>
</ul>
</li>
</ol>
<p>究竟是选AP还是选CP，真的在于对业务的了解，例如金钱，库存相关会优先考虑CP模型，例如社区发帖相关可以优先选择AP模型，这个说白了其实基于对业务的了解是一个选择和妥协的过程。</p>
</blockquote>
<p>对于开发或设计分布式系统的架构师工程师来说，CAP 是必须要掌握的理论。</p>
<p>But：这个文章的重点并不是讨论 CAP 理论和细节，重点是说说 CAP 在微服务中的开发怎么起到一个指引作用，会通过几个微服务开发的例子说明，尽量的去贴近开发。</p>
<p>CAP 定理又被称为布鲁尔定理，是加州大学计算机科学家埃里克·布鲁尔提出来的猜想，后来被证明成为分布式计算领域公认的定理。</p>
<p>不过布鲁尔在出来 CAP 的时候并没有对 CAP 三者（Consistency，Availability，Partition tolerance）进行详细的定义，所以在网上也出现了不少对 CAP 不同解读的声音。</p>
<h3 id="1-CAP-定理"><a href="#1-CAP-定理" class="headerlink" title="1. CAP 定理"></a>1. CAP 定理</h3><p>CAP 定理在发展中存在过两个版本，我们以第二个版本为准</p>
<blockquote>
<p>在一个分布式系统中（指互相连接并共享数据的节点集合）中，当涉及到读写操作时，只能保证一致性（Consistence）、可用性(Availability）、分区容错性（Partition Tolerance）三者中的两个，另外一个必须被牺牲。</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05888f809b3bc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>这个版本的 CAP 理论在探讨分布式系统，更加强调两点是互联和共享数据，其实也是理清楚了第一个版本中三选二的一些缺陷。</p>
<p>分布式系统不一定都存在互联和共享数据，例如 Memcached 集群相互间就没有存在连接和共享数据。</p>
<p>所以 Memcached 集群这类的分布式系统并不在 CAP 理论讨论的范围，而像 MySQL 集群就是互联和数据共享复制，因此 MySQL 集群是属于 CAP 理论讨论的对象。</p>
<h4 id="1-1-一致性（Consistency）"><a href="#1-1-一致性（Consistency）" class="headerlink" title="1.1 一致性（Consistency）"></a>1.1 一致性（Consistency）</h4><p>一致性意思就是写操作之后进行读操作无论在哪个节点都需要返回写操作的值</p>
<h4 id="1-2-可用性-Availability）"><a href="#1-2-可用性-Availability）" class="headerlink" title="1.2 可用性(Availability）"></a>1.2 可用性(Availability）</h4><p>非故障的节点在合理的时间内返回合理的响应</p>
<h4 id="1-3-分区容错性-Partition-Tolerance"><a href="#1-3-分区容错性-Partition-Tolerance" class="headerlink" title="1.3 分区容错性(Partition Tolerance)"></a>1.3 分区容错性(Partition Tolerance)</h4><p>在分布式的环境下，网络无法做到 100% 可靠，有可能出现故障，因此分区是一个必须的选项。</p>
<p>如果选择了 CA 而放弃了 P，若发生分区现象，为了保证 C，系统需要禁止写入，此时就与 A 发生冲突；如果是为了保证 A，则会出现正常的分区可以写入数据，有故障的分区不能写入数据，则与 C 就冲突了。</p>
<p>因此分布式系统理论上不可能选择 CA 架构，而必须选择 CP 或 AP 架构</p>
<h4 id="1-4-分布式事务-BASE-理论"><a href="#1-4-分布式事务-BASE-理论" class="headerlink" title="1.4 分布式事务 BASE 理论"></a>1.4 分布式事务 BASE 理论</h4><p>BASE 理论是对 CAP 的延伸和补充，是对 CAP 中的 AP 方案的一个补充，即在选择 AP 方案的情况下，如何更好的最终达到 C。</p>
<p>BASE 是基本可用，柔性状态，最终一致性三个短语的缩写，核心的思想是即使无法做到强一致性，但应用可以采用适合的方式达到最终一致性。</p>
<h3 id="2-CAP-在服务中实际的应用例子"><a href="#2-CAP-在服务中实际的应用例子" class="headerlink" title="2. CAP 在服务中实际的应用例子"></a>2. CAP 在服务中实际的应用例子</h3><p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05888f63920ec?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>理解貌似讲多了，项目的 CAP 可以参考下李运华的《从零开始学架构》的书，里面的 21，22 章比较详细的描绘了 CAP 的理论细节和 CAP 的版本演化过程。</p>
<p>这里着重的讲解的是神一样的 CAP 在我们的微服务中怎么去指导和应用起来，大概会举几个平时常见的例子</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05888f5068452?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<h3 id="3-服务注册中心，是选择-AP-还是选择-CP-？"><a href="#3-服务注册中心，是选择-AP-还是选择-CP-？" class="headerlink" title="3. 服务注册中心，是选择 AP 还是选择 CP ？"></a>3. 服务注册中心，是选择 AP 还是选择 CP ？</h3><h4 id="3-1-服务注册中心解决的问题"><a href="#3-1-服务注册中心解决的问题" class="headerlink" title="3.1 服务注册中心解决的问题"></a>3.1 服务注册中心解决的问题</h4><p>在讨论 CAP 之前先明确下服务注册中心主要是解决什么问题：一个是服务注册，一个是服务发现。</p>
<ul>
<li>服务注册：实例将自身服务信息注册到注册中心，这部分信息包括服务的主机 IP 和服务的 Port，以及暴露服务自身状态和访问协议信息等。</li>
<li>服务发现：实例请求注册中心所依赖的服务信息，服务实例通过注册中心，获取到注册到其中的服务实例的信息，通过这些信息去请求它们提供的服务。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05888feb8431b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>目前作为注册中心的一些组件大致有：</p>
<ul>
<li><strong>Dubbo 的 Zookeeper</strong></li>
<li><strong>Spring Cloud 的 Eureka，Consul</strong></li>
<li><strong>RocketMQ 的 nameServer</strong></li>
<li><strong>HDFS 的 nameNode</strong></li>
</ul>
<p>目前微服务主流是 Dubbo 和 Spring Cloud，使用最多是 Zookeeper 和 Eureka，我们就来看看应该根据 CAP 理论怎么去选择注册中心。（Spring Cloud 也可以用 ZK，不过不是主流不讨论）</p>
<h4 id="3-2-zookeeper-选择-CP"><a href="#3-2-zookeeper-选择-CP" class="headerlink" title="3.2 zookeeper 选择 CP"></a>3.2 zookeeper 选择 CP</h4><p>Zookeeper 保证 CP，即任何时刻对 Zookeeper 的访问请求能得到一致性的数据结果，同时系统对网络分割具备容错性，但是它不能保证每次服务的可用性。</p>
<p>从实际情况来分析，在使用 Zookeeper 获取服务列表时，如果 ZK 正在选举或者 ZK 集群中半数以上的机器不可用，那么将无法获取数据。所以说，ZK 不能保证服务可用性。</p>
<h4 id="3-3-eureka-选择-AP"><a href="#3-3-eureka-选择-AP" class="headerlink" title="3.3 eureka 选择 AP"></a>3.3 eureka 选择 AP</h4><p>Eureka 保证 AP，Eureka 在设计时优先保证可用性，每一个节点都是平等的。</p>
<p>一部分节点挂掉不会影响到正常节点的工作，不会出现类似 ZK 的选举 Leader 的过程，客户端发现向某个节点注册或连接失败，会自动切换到其他的节点。</p>
<p>只要有一台 Eureka 存在，就可以保证整个服务处在可用状态，只不过有可能这个服务上的信息并不是最新的信息。</p>
<h4 id="3-4-zookeeper-和-eureka-的数据一致性问题"><a href="#3-4-zookeeper-和-eureka-的数据一致性问题" class="headerlink" title="3.4 zookeeper 和 eureka 的数据一致性问题"></a>3.4 zookeeper 和 eureka 的数据一致性问题</h4><p>先要明确一点，Eureka 的创建初心就是为一个注册中心，但是 ZK 更多是作为分布式协调服务的存在。</p>
<p>只不过因为它的特性被 Dubbo 赋予了注册中心，它的职责更多是保证数据（配置数据，状态数据）在管辖下的所有服务之间保持一致。</p>
<p>所以这个就不难理解为何 ZK 被设计成 CP 而不是 AP，ZK 最核心的算法 ZAB，就是为了解决分布式系统下数据在多个服务之间一致同步的问题。</p>
<p>更深层的原因，ZK 是按照 CP 原则构建，也就是说它必须保持每一个节点的数据都保持一致。</p>
<p>如果 ZK 下节点断开或者集群中出现网络分割（例如交换机的子网间不能互访），那么 ZK 会将它们从自己的管理范围中剔除，外界不能访问这些节点，即使这些节点是健康的可以提供正常的服务，所以导致这些节点请求都会丢失。</p>
<p>而 Eureka 则完全没有这方面的顾虑，它的节点都是相对独立，不需要考虑数据一致性的问题，这个应该是 Eureka 的诞生就是为了注册中心而设计。</p>
<p>相对 ZK 来说剔除了 Leader 节点选取和事务日志机制，这样更有利于维护和保证 Eureka 在运行的健壮性。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05888fc2f78b3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>再来看看，数据不一致性在注册服务中会给 Eureka 带来什么问题，无非就是某一个节点被注册的服务多，某个节点注册的服务少，在某一个瞬间可能导致某些 IP 节点被调用数多，某些 IP 节点调用数少的问题。</p>
<p>也有可能存在一些本应该被删除而没被删除的脏数据。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05888f75401e9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<h4 id="3-5-小结：服务注册应该选择-AP-还是-CP"><a href="#3-5-小结：服务注册应该选择-AP-还是-CP" class="headerlink" title="3.5 小结：服务注册应该选择 AP 还是 CP"></a>3.5 小结：服务注册应该选择 AP 还是 CP</h4><p>对于服务注册来说，针对同一个服务，即使注册中心的不同节点保存的服务注册信息不相同，也并不会造成灾难性的后果。</p>
<p>对于服务消费者来说，能消费才是最重要的，就算拿到的数据不是最新的数据，消费者本身也可以进行尝试失败重试。总比为了追求数据的一致性而获取不到实例信息整个服务不可用要好。</p>
<p>所以，对于服务注册来说，可用性比数据一致性更加的重要，选择 AP。</p>
<h3 id="4-分布式锁，是选择-AP-还是选择-CP-？"><a href="#4-分布式锁，是选择-AP-还是选择-CP-？" class="headerlink" title="4. 分布式锁，是选择 AP 还是选择 CP ？"></a>4. 分布式锁，是选择 AP 还是选择 CP ？</h3><p>这里实现分布式锁的方式选取了三种：</p>
<ul>
<li><p>基于数据库实现分布式锁</p>
</li>
<li><p>基于 Redis 实现分布式锁</p>
</li>
<li><p>基于 Zookeeper 实现分布式锁</p>
</li>
</ul>
<h4 id="4-1-基于数据库实现分布式锁"><a href="#4-1-基于数据库实现分布式锁" class="headerlink" title="4.1 基于数据库实现分布式锁"></a>4.1 基于数据库实现分布式锁</h4><p>构建表结构</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a12368882?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>利用表的 UNIQUE KEY <code>idx_lock</code> (<code>method_lock</code>) 作为唯一主键，当进行上锁时进行 insert 动作，数据库成功录入则以为上锁成功，当数据库报出 Duplicate entry 则表示无法获取该锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a11076d99?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>不过这种方式对于单主却无法自动切换主从的 MySQL 来说，基本就无法实现 P 分区容错性（MySQL 自动主从切换在目前并没有十分完美的解决方案）。</p>
<p>可以说这种方式强依赖于数据库的可用性，数据库写操作是一个单点，一旦数据库挂掉，就导致锁的不可用。这种方式基本不在 CAP 的一个讨论范围。。</p>
<h4 id="4-2-基于-Redis-实现分布式锁"><a href="#4-2-基于-Redis-实现分布式锁" class="headerlink" title="4.2 基于 Redis 实现分布式锁"></a>4.2 基于 <strong>Redis</strong> 实现分布式锁</h4><p>Redis 单线程串行处理天然就是解决串行化问题，用来解决分布式锁是再适合不过。</p>
<p>实现方式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx key value Expire_time</span><br><span class="line">获取到锁 返回 1 ， 获取失败 返回 0</span><br></pre></td></tr></table></figure>

<p>为了解决数据库锁的无主从切换的问题，可以选择 Redis 集群，或者是 Sentinel 哨兵模式，实现主从故障转移，当 Master 节点出现故障，哨兵会从 Slave 中选取节点，重新变成新的 Master 节点。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05889f092fb7f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>所以 Redis 的复制模式是属于 AP 的模式。保证可用性，在主从复制中“主”有数据，但是可能“从”还没有数据。</p>
<p>这个时候，一旦主挂掉或者网络抖动等各种原因，可能会切换到“从”节点，这个时候可能会导致两个业务线程同时获取得两把锁。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05889f24be477?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>这个过程如下：</p>
<ol>
<li>业务线程-1 向主节点请求锁</li>
<li>业务线程-1 获取锁</li>
<li>业务线程-1 获取到锁并开始执行业务</li>
<li>这个时候 redis 刚生成的锁在主从之间还未进行同步</li>
<li>redis 这时候主节点挂掉了</li>
<li>redis 的从节点升级为主节点</li>
<li>业务线程-2 向新的主节点请求锁</li>
<li>业务线程-2 获取到新的主节点返回的锁</li>
<li>业务线程-2 获取到锁开始执行业务</li>
<li>这个时候 业务线程-1 和 业务线程-2 同时在执行任务</li>
</ol>
<p>上述的问题其实并不是 Redis 的缺陷，只是 Redis 采用了 AP 模型，它本身无法确保我们对一致性的要求。</p>
<p>Redis 官方推荐 Redlock 算法来保证，问题是 Redlock 至少需要三个 Redis 主从实例来实现，维护成本比较高。</p>
<p>相当于 Redlock 使用三个 Redis 集群实现了自己的另一套一致性算法，比较繁琐，在业界也使用得比较少。</p>
<h5 id="4-2-1-能否使用-redis-作为分布式锁？"><a href="#4-2-1-能否使用-redis-作为分布式锁？" class="headerlink" title="4.2.1 能否使用 redis 作为分布式锁？"></a>4.2.1 能否使用 redis 作为分布式锁？</h5><p>这个本身就不是 Redis 的问题，还是取决于业务场景。</p>
<p>我们先要自己确认我们的场景是适合 AP 还是 CP ， 如果在社交发帖等场景下，我们并没有非常强的事务一致性问题，Redis 提供给我们高性能的 AP 模型是非常适合的。</p>
<p>但如果是交易类型，对数据一致性非常敏感的场景，我们可能要寻找一种更加适合的 CP 模型。</p>
<h4 id="4-3-基于-Zookeeper-实现分布式锁"><a href="#4-3-基于-Zookeeper-实现分布式锁" class="headerlink" title="4.3 基于 Zookeeper 实现分布式锁"></a>4.3 基于 <strong>Zookeeper</strong> 实现分布式锁</h4><p>刚刚也分析过，Redis 其实无法确保数据的一致性，先来看 Zookeeper 是否适合作为我们需要的分布式锁。</p>
<p>首先 ZK 的模式是 CP 模型，也就是说，当 ZK 锁提供给我们进行访问的时候，在 ZK 集群中能确保这把锁在 ZK 的每一个节点都存在。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d05889f6a5ce1c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>这个实际上是 ZK 的 Leader 通过二阶段提交写请求来保证的，这个也是 ZK 的集群规模大了的一个瓶颈点。</p>
<h5 id="4-3-1-ZK-锁实现的原理"><a href="#4-3-1-ZK-锁实现的原理" class="headerlink" title="4.3.1 ZK 锁实现的原理"></a>4.3.1 ZK 锁实现的原理</h5><p>说 ZK 的锁问题之前先看看 Zookeeper 中几个特性，这几个特性构建了 ZK 的一把分布式锁。</p>
<p>ZK 的特性如下：</p>
<ul>
<li><strong>有序节点：</strong> 当在一个父目录下如 &#x2F;lock 下创建 有序节点，节点会按照严格的先后顺序创建出自节点 lock000001，lock000002，lock0000003，以此类推，有序节点能严格保证各个自节点按照排序命名生成。</li>
<li><strong>临时节点：</strong> 客户端建立了一个临时节点，在客户端的会话结束或会话超时，Zookepper 会自动删除该节点 ID。</li>
<li><strong>事件监听：</strong> 在读取数据时，我们可以对节点设置监听，当节点的数据发生变化（1 节点创建 2 节点删除 3 节点数据变成 4 自节点变成）时，Zookeeper 会通知客户端。</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a51620561?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>结合这几个特点，来看下 zk 是怎么组合分布式锁。</p>
<ol>
<li>业务线程-1 业务线程-2 分别向 zk 的&#x2F;lock 目录下，申请创建有序的临时节点</li>
<li>业务线程-1 抢到&#x2F;lock0001 的文件，也就是在整个目录下最小序的节点，也就是线程-1 获取到了锁</li>
<li>业务线程-2 只能抢到&#x2F;lock0002 的文件，并不是最小序的节点，线程 2 未能获取锁</li>
<li>业务线程-1 与 lock0001 建立了连接，并维持了心跳，维持的心跳也就是这把锁的租期</li>
<li>当业务线程-1 完成了业务，将释放掉与 zk 的连接，也就是释放了这把锁</li>
</ol>
<h5 id="4-3-2-zk-分布式锁的代码实现"><a href="#4-3-2-zk-分布式锁的代码实现" class="headerlink" title="4.3.2 zk 分布式锁的代码实现"></a>4.3.2 zk 分布式锁的代码实现</h5><p>ZK 官方提供的客户端并不支持分布式锁的直接实现，我们需要自己写代码去利用 ZK 的这几个特性去进行实现。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a68844a5a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<h4 id="4-4-小结：究竟该用-CP-还是-AP-的分布式锁"><a href="#4-4-小结：究竟该用-CP-还是-AP-的分布式锁" class="headerlink" title="4.4 小结：究竟该用 CP 还是 AP 的分布式锁"></a>4.4 小结：究竟该用 CP 还是 AP 的分布式锁</h4><p>首先得了解清楚我们使用分布式锁的场景，为何使用分布式锁，用它来帮我们解决什么问题，先聊场景后聊分布式锁的技术选型。</p>
<p>无论是 Redis，ZK，例如 Redis 的 AP 模型会限制很多使用场景，但它却拥有了几者中最高的性能。</p>
<p>Zookeeper 的分布式锁要比 Redis 可靠很多，但他繁琐的实现机制导致了它的性能不如 Redis，而且 ZK 会随着集群的扩大而性能更加下降。</p>
<p>简单来说，先了解业务场景，后进行技术选型。</p>
<h3 id="5-分布式事务，是怎么从-ACID-解脱，投身-CAP-x2F-BASE"><a href="#5-分布式事务，是怎么从-ACID-解脱，投身-CAP-x2F-BASE" class="headerlink" title="5. 分布式事务，是怎么从 ACID 解脱，投身 CAP&#x2F;BASE"></a>5. 分布式事务，是怎么从 ACID 解脱，投身 CAP&#x2F;BASE</h3><p>如果说到事务，ACID 是传统数据库常用的设计理念，追求强一致性模型，关系数据库的 ACID 模型拥有高一致性+可用性，所以很难进行分区。</p>
<p>在微服务中 ACID 已经是无法支持，我们还是回到 CAP 去寻求解决方案，不过根据上面的讨论，CAP 定理中，要么只能 CP，要么只能 AP。</p>
<p>如果我们追求数据的一致性而忽略可用性这个在微服务中肯定是行不通的，如果我们追求可用性而忽略一致性，那么在一些重要的数据（例如支付，金额）肯定出现漏洞百出，这个也是无法接受。所以我们既要一致性，也要可用性。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a859246f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>都要是无法实现的，但我们能不能在一致性上作出一些妥协，不追求强一致性，转而追求最终一致性，所以引入 BASE 理论。</p>
<p>在分布式事务中，BASE 最重要是为 CAP 提出了最终一致性的解决方案，BASE 强调牺牲高一致性，从而获取可用性，数据允许在一段时间内不一致，只要保证最终一致性就可以了。</p>
<h4 id="5-1-实现最终一致性"><a href="#5-1-实现最终一致性" class="headerlink" title="5.1 实现最终一致性"></a>5.1 实现最终一致性</h4><p><strong>弱一致性</strong>：系统不能保证后续访问返回更新的值。需要在一些条件满足之后，更新的值才能返回。</p>
<p>从更新操作开始，到系统保证任何观察者总是看到更新的值的这期间被称为不一致窗口。</p>
<p><strong>最终一致性</strong>：这是弱一致性的特殊形式；存储系统保证如果没有对某个对象的新更新操作，最终所有的访问将返回这个对象的最后更新的值。</p>
<h4 id="5-2-BASE-模型"><a href="#5-2-BASE-模型" class="headerlink" title="5.2 BASE 模型"></a>5.2 BASE 模型</h4><p>BASE 模型是传统 ACID 模型的反面，不同于 ACID，BASE 强调牺牲高一致性，从而获得可用性，数据允许在一段时间内的不一致，只要保证最终一致就可以了。</p>
<p>BASE 模型反 ACID 模型，完全不同 ACID 模型，牺牲高一致性，获得可用性或可靠性：Basically Available 基本可用。</p>
<p>支持分区失败（e.g. sharding碎片划分数据库）Soft state 软状态，状态可以有一段时间不同步，异步。</p>
<p>Eventually consistent 最终一致，最终数据是一致的就可以了，而不是时时一致。</p>
<h4 id="5-3-分布式事务"><a href="#5-3-分布式事务" class="headerlink" title="5.3 分布式事务"></a>5.3 分布式事务</h4><p>在分布式系统中，要实现分布式事务，无外乎几种解决方案。方案各有不同，不过其实都是遵循 BASE 理论，是最终一致性模型。</p>
<ul>
<li><strong>两阶段提交（2PC）</strong></li>
<li><strong>补偿事务（TCC）</strong></li>
<li><strong>本地消息表</strong></li>
<li><strong>MQ 事务消息</strong></li>
</ul>
<h4 id="5-4-两阶段提交（2PC）"><a href="#5-4-两阶段提交（2PC）" class="headerlink" title="5.4 两阶段提交（2PC）"></a>5.4 两阶段提交（2PC）</h4><p>其实还有一个数据库的 XA 事务，不过目前在真正的互联网中实际的应用基本很少，两阶段提交就是使用 XA 原理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588a87ee0c96?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>在 XA 协议中分为两阶段：</p>
<ol>
<li>事务管理器要求每个涉及到事务的数据库预提交(precommit)此操作，并反映是否可以提交。</li>
<li>事务协调器要求每个数据库提交数据，或者回滚数据。</li>
</ol>
<p>说一下，为何在互联网的系统中没被改造过的两阶段提交基本很少被业界应用，最大的缺点就是同步阻塞问题。</p>
<p>在资源准备就绪之后，资源管理器中的资源就一直处于阻塞，直到提交完成之后，才进行资源释放。</p>
<p>这个在互联网高并发大数据的今天，两阶段的提交是不能满足现在互联网的发展。</p>
<p>还有就是两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能。</p>
<p>例如：在第二阶段中，假设协调者发出了事务 Commit 的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了 Commit 操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p>
<h4 id="5-5-补偿事务（TCC）"><a href="#5-5-补偿事务（TCC）" class="headerlink" title="5.5 补偿事务（TCC）"></a>5.5 补偿事务（TCC）</h4><p>TCC 是服务化的两阶段变成模型，每个业务服务都必须实现 try，confirm，calcel 三个方法，这三个方式可以对应到 SQL 事务中 Lock，Commit，Rollback。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aa354cd70?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p><strong>相比两阶段提交，TCC 解决了几个问题：</strong> 同步阻塞，引入了超时机制，超时后进行补偿，并不会像两阶段提交锁定了整个资源，将资源转换为业务逻辑形式，粒度变小。</p>
<p>因为有了补偿机制，可以由业务活动管理器进行控制，保证数据一致性。</p>
<p><strong>Try 阶段：</strong> Try 只是一个初步的操作，进行初步的确认，它的主要职责是完成所有业务的检查，预留业务资源。</p>
<p><strong>Confirm 阶段：</strong> Confirm 是在 Try 阶段检查执行完毕后，继续执行的确认操作，必须满足幂等性操作，如果 Confirm 中执行失败，会有事务协调器触发不断的执行，直到满足为止。</p>
<p><strong>Cancel 是取消执行：</strong> 在 Try 没通过并释放掉 Try 阶段预留的资源，也必须满足幂等性，跟 Confirm 一样有可能被不断执行。</p>
<p>一个下订单，生成订单扣库存的例子：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aa9cf1fed?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>接下来看看，我们的下单扣减库存的流程怎么加入 TCC</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ab8cd2a20?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>在 Try 的时候，会让库存服务预留 N 个库存给这个订单使用，让订单服务产生一个“未确认”订单，同时产生这两个预留的资源。</p>
<p>在 Confirm 的时候，会使用在 Try 预留的资源，在 TCC 事务机制中认为，如果在 Try 阶段能正常预留的资源，那么在 Confirm 一定能完整的提交。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ab8c51652?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>在 Try 的时候，有任务一方为执行失败，则会执行 Cancel 的接口操作，将在 Try 阶段预留的资源进行释放。</p>
<p>这个并不是重点要论 TCC 事务是怎么实现，重点还是讨论分布式事务在 CAP+BASE 理论的应用。实现可以参考：<a target="_blank" rel="noopener" href="https://github.com/changmingxie/tcc-transaction" title="github.com/changmingxi…">github.com&#x2F;changmingxi…</a></p>
<h4 id="5-6-本地消息表"><a href="#5-6-本地消息表" class="headerlink" title="5.6 本地消息表"></a>5.6 本地消息表</h4><p>本地消息表这个方案最初是 eBay 提出的，eBay 的完整方案 <a target="_blank" rel="noopener" href="https://queue.acm.org/detail.cfm?id=1394128%E3%80%82" title="queue.acm.org/detail.cfm?…">queue.acm.org&#x2F;detail.cfm?…</a></p>
<p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588acde414a6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>对于本地消息队列来说，核心就是将大事务转变为小事务，还是用上面下订单扣库存的例子说说明</p>
<ol>
<li>当我们去创建订单的时候，我们新增一个本地消息表，把创建订单和扣减库存写入到本地消息表，放在同一个事务（依靠数据库本地事务保证一致性）</li>
<li>配置一个定时任务去轮训这个本地事务表，扫描这个本地事务表，把没有发送出去的消息，发送给库存服务，当库存服务收到消息后，会进行减库存，并写入服务器的事务表，更新事务表的状态。</li>
<li>库存服务器通过定时任务或直接通知订单服务，订单服务在本地消息表更新状态。</li>
</ol>
<p>这里须注意的是，对于一些扫描发送未成功的任务，会进行重新发送，所以必须保证接口的幂等性。</p>
<p>本地消息队列是 BASE 理论，是最终一致性模型，适用对一致性要求不高的情况。</p>
<h4 id="5-7-MQ-事务"><a href="#5-7-MQ-事务" class="headerlink" title="5.7 MQ 事务"></a>5.7 MQ 事务</h4><p>RocketMq 在 4.3 版本已经正式宣布支持分布式事务，在选择 Rokcetmq 做分布式事务请务必选择 4.3 以上的版本。</p>
<p>RocketMQ 中实现了分布式事务，实际上是对本地消息表的一个封装，将本地消息表移动到了 MQ 内部。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588ae2844970?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>事务消息作为一种异步确保型事务， 将两个事务分支通过 MQ 进行异步解耦，RocketMQ 事务消息的设计流程同样借鉴了两阶段提交理论，整体交互流程如下图所示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588aeba679cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>MQ 事务是对本地消息表的一层封装，将本地消息表移动到了 MQ 内部，所以也是基于 BASE 理论，是最终一致性模式，对强一致性要求不那么高的事务适用，同时 MQ 事务将整个流程异步化了，也非常适合在高并发情况下使用。</p>
<h3 id="6-RocketMQ-选择异步-x2F-同步刷盘，异步-x2F-同步复制，背后的-CP-和-AP-思考"><a href="#6-RocketMQ-选择异步-x2F-同步刷盘，异步-x2F-同步复制，背后的-CP-和-AP-思考" class="headerlink" title="6. RocketMQ 选择异步&#x2F;同步刷盘，异步&#x2F;同步复制，背后的 CP 和 AP 思考"></a>6. RocketMQ 选择异步&#x2F;同步刷盘，异步&#x2F;同步复制，背后的 CP 和 AP 思考</h3><p>虽然同步刷盘&#x2F;异步刷盘，同步&#x2F;异步复制，并没有对 CAP 直接的应用，但在配置的过程中也一样涉及到可用性和一致性的考虑。</p>
<h4 id="6-1-同步刷盘-x2F-异步刷盘"><a href="#6-1-同步刷盘-x2F-异步刷盘" class="headerlink" title="6.1 同步刷盘&#x2F;异步刷盘"></a>6.1 同步刷盘&#x2F;异步刷盘</h4><p>RocketMQ 的消息是可以做到持久化的，数据会持久化到磁盘，RocketMQ 为了提高性能，尽可能保证磁盘的顺序写入，消息在 Producer 写入 RocketMq 的时候，有两种写入磁盘方式：</p>
<ol>
<li>异步刷盘：消息快速写入到内存的 Pagecache，就立马返回写成功状态，当内存的消息累计到一定程度的时候，会触发统一的写磁盘操作。这种方式可以保证大吞吐量，但也存在着消息可能未存入磁盘丢失的风险。</li>
<li>同步刷盘：消息快速写入内存的 Pagecahe，立刻通知刷盘线程进行刷盘，等待刷盘完成之后，唤醒等待的线程，返回消息写成功的状态。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588b056e080a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<h4 id="6-2-同步复制-x2F-异步复制"><a href="#6-2-同步复制-x2F-异步复制" class="headerlink" title="6.2 同步复制&#x2F;异步复制"></a>6.2 同步复制&#x2F;异步复制</h4><p>一个 Broker 组有 Master 和 Slave，消息需要从 Master 复制到 Slave 上，所以有同步和异步两种复制方式：</p>
<ol>
<li>同步复制：是等 Master 和 Slave 均写成功后才反馈给客户端写成功状态。</li>
<li>异步复制：是只要 Master 写成功即可反馈给客户端写成功状态。</li>
</ol>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588af130c763?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>异步复制的优点是可以提高响应速度，但牺牲了一致性 ，一般实现该类协议的算法需要增加额外的补偿机制。</p>
<p>同步复制的优点是可以保证一致性（一般通过两阶段提交协议），但是开销较大，可用性不好（参见 CAP 定理），带来了更多的冲突和死锁等问题。</p>
<p>值得一提的是 Lazy+Primary&#x2F;Copy 的复制协议在实际生产环境中是非常实用的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588b16477dcb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
<p>RocketMQ 的设置要结合业务场景，合理设置刷盘方式和主从复制方式，尤其是 SYNC_FLUSH 方式，由于频繁的触发写磁盘动作，会明显降低性能。</p>
<p>通常情况下，应该把 Master 和 Slave 设置成 ASYNC_FLUSH 的刷盘方式，主从之间配置成 SYNC_MASTER 的复制方式，这样即使有一台机器出故障，仍然可以保证数据不丢。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>在微服务的构建中，永远都逃离不了 CAP 理论，因为网络永远不稳定，硬件总会老化，软件可能出现 Bug，所以分区容错性在微服务中是躲不过的命题。</p>
<p>可以这么说，只要是分布式，只要是集群都面临着 AP 或者 CP 的选择，但你很贪心的时候，既要一致性又要可用性，那只能对一致性作出一点妥协，也就是引入了 BASE 理论，在业务允许的情况下实现最终一致性。</p>
<p>究竟是选 AP 还是选 CP，真的在于对业务的了解，例如金钱，库存相关会优先考虑 CP 模型，例如社区发帖相关可以优先选择 AP 模型，这个说白了其实基于对业务的了解是一个选择和妥协的过程。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/9/6/16d0588b1ea4e045?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-思考-9-没有所谓的一成不变 🤔"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/12/%E6%80%9D%E8%80%83-9-%E6%B2%A1%E6%9C%89%E6%89%80%E8%B0%93%E7%9A%84%E4%B8%80%E6%88%90%E4%B8%8D%E5%8F%98%20%F0%9F%A4%94/"
    >思考 9 没有所谓的一成不变 🤔</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/12/%E6%80%9D%E8%80%83-9-%E6%B2%A1%E6%9C%89%E6%89%80%E8%B0%93%E7%9A%84%E4%B8%80%E6%88%90%E4%B8%8D%E5%8F%98%20%F0%9F%A4%94/" class="article-date">
  <time datetime="2019-11-11T17:48:16.000Z" itemprop="datePublished">2019-11-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=5pfyccJgA3o">https://www.youtube.com/watch?v=5pfyccJgA3o</a></p>
<blockquote>
<p>看《欢乐谷》电影解说的思考 🤔</p>
<p>没有所谓的一成不变，也没有所谓的完美人生，改变其实并不可怕</p>
<p>世界上唯一不变的就是变化</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-CentOS-7-安装GUI界面及远程连接"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/06/CentOS-7-%E5%AE%89%E8%A3%85GUI%E7%95%8C%E9%9D%A2%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"
    >CentOS 7 安装GUI界面及远程连接</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/06/CentOS-7-%E5%AE%89%E8%A3%85GUI%E7%95%8C%E9%9D%A2%E5%8F%8A%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/" class="article-date">
  <time datetime="2019-11-05T16:04:29.000Z" itemprop="datePublished">2019-11-06</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="CentOS-7-安装GUI界面及远程连接"><a href="#CentOS-7-安装GUI界面及远程连接" class="headerlink" title="CentOS 7 安装GUI界面及远程连接"></a>CentOS 7 安装GUI界面及远程连接</h1><blockquote>
<p>参考文章：</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000019557600">https://segmentfault.com/a/1190000019557600</a></p>
</blockquote>
<h2 id="1-安装GUI界面"><a href="#1-安装GUI界面" class="headerlink" title="1. 安装GUI界面"></a>1. 安装GUI界面</h2><p>大多数云服务器厂商提供的镜像都无GUI界面，所以要先安装图形环境。本文使用GNOME桌面环境：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y groups install &quot;GNOME Desktop&quot;</span><br></pre></td></tr></table></figure>

<p>这条命令将安装GNOME桌面的必要软件包，执行完后配置X系统使用GNOME:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;exec gnome-session&quot; &gt;&gt; ~/.xinitrc</span><br></pre></td></tr></table></figure>

<h2 id="2-安装xrdp"><a href="#2-安装xrdp" class="headerlink" title="2. 安装xrdp"></a>2. 安装xrdp</h2><p><strong>安装源</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install  epel* -y</span><br></pre></td></tr></table></figure>

<p><strong>安装xrdp</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --enablerepo=epel -y install xrdp</span><br></pre></td></tr></table></figure>

<p><strong>启动xrdp</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl start xrdp</span><br><span class="line">systemctl enable xrdp</span><br></pre></td></tr></table></figure>

<p><strong>关闭防火墙</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-port=3389/tcp</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h2 id="3-连接效果"><a href="#3-连接效果" class="headerlink" title="3. 连接效果"></a>3. 连接效果</h2><blockquote>
<p>因为我使用的是mac笔记本，所以远程桌面的软件使用的是 Microsoft Remote Desktop </p>
</blockquote>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/576791/1572968622527-691107d9-ba99-4c31-913a-2888d37ec280.png"></p>
<p>输入 centos 用户名，密码</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/576791/1572854480147-f945623c-df74-4f5d-94bb-6276258742bb.png"></p>
<p>连接后的效果</p>
<p><img src="https://cdn.nlark.com/yuque/0/2019/png/576791/1572854436441-bb8e6d1d-6908-477e-b80b-26bcec2f055d.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-《阿里巴巴-Java-开发手册》第五章MySQL数据库解读"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/05/%E3%80%8A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E8%AF%BB/"
    >《阿里巴巴 Java 开发手册》第五章MySQL数据库解读</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/05/%E3%80%8A%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4-Java-%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%A3%E8%AF%BB/" class="article-date">
  <time datetime="2019-11-05T10:42:26.000Z" itemprop="datePublished">2019-11-05</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>基于手册最新版本《阿里巴巴 Java 开发手册（华山版）》</p>
<p>《阿里巴巴 Java 开发手册》下载地址: <a target="_blank" rel="noopener" href="https://github.com/alibaba/p3c">https://github.com/alibaba/p3c</a></p>
<p>参考文章: </p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dragonsuc/p/6938006.html">点评阿里JAVA手册之MySQL数据库</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/5c8bb168f265da2da23d73f0">详细解读阿里手册之MySQL</a></p>
<p>开发不规范，亲人两行泪 🤣</p>
</blockquote>
<h2 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h2><p><strong>1.<strong>【</strong>强制</strong>】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。 </p>
<p>​	<strong>说明</strong>：任何字段如果为非负数，必须是 unsigned。</p>
<p>​	<strong>注意</strong>：POJO 类中的任何布尔类型的变量，都不要加 is 前缀，所以，需要在 <resultMap> 设置从 is_xxx 的映射关系。数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的命名方式是为了明确其取值含义与取值范围。</p>
<p>​	<strong>正例</strong>：表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p>
<blockquote>
<p>unsigned 属性就是将数字类型无符号化</p>
<p>”POJO 类中的任何布尔类型的变量，都不要加 is 前缀“，这个可以参考 Hollis 大佬的这篇文章 <a target="_blank" rel="noopener" href="https://www.hollischuang.com/archives/3111">为什么阿里巴巴禁止开发人员使用isSuccess作为变量名</a></p>
</blockquote>
<p><strong>2.<strong>【</strong>强制</strong>】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。</p>
<p>​	<strong>说明</strong>：MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。</p>
<p>​	<strong>正例</strong>：aliyun_admin，rdc_config，level3_name</p>
<p>​	<strong>反例</strong>：AliyunAdmin，rdcConfig，level_3_name</p>
<blockquote>
<p>表名、字段名一定要规范，并且要见名知意。因为一旦使用之后，想要修改的话会比较麻烦。起一个好的名字真的很重要，能够在无形中减少沟通成本。</p>
</blockquote>
<p><strong>3.<strong>【</strong>强制</strong>】表名不使用复数名词。</p>
<p>​	<strong>说明</strong>：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p>
<blockquote>
<p>有些单词的复数形式可能是非常规的，或者就没有复数形式，因此单数形式更简单</p>
</blockquote>
<p><strong>4.<strong>【</strong>强制</strong>】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p>
<blockquote>
<p>文档地址: <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/keywords.html">https://dev.mysql.com/doc/refman/8.0/en/keywords.html</a></p>
</blockquote>
<p><strong>5.<strong>【</strong>强制</strong>】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。</p>
<p>​	<strong>说明</strong>：pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p>
<blockquote>
<p>这样见名知意，通过前缀就可以知道是什么类型的索引</p>
</blockquote>
<p><strong>6.<strong>【</strong>强制</strong>】小数类型为 decimal，禁止使用 float 和 double。 </p>
<p>​	<strong>说明</strong>：float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p>
<blockquote>
<p>对于和钱相关的系统，精度损失是会造成金钱损失的</p>
</blockquote>
<p><strong>7.<strong>【</strong>强制</strong>】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p>
<blockquote>
<p>CHAR(M)定义的列的长度为固定的，M取值可以为0～255之间，当保存CHAR值时，在它们的右边填充空格以达到指定的长度。当检索到CHAR值时，尾部的空格被删除掉。在存储或检索过程中不进行大小写转换。CHAR存储定长数据很方便，CHAR字段上的索引效率极高，比如定义char(10)，那么不论你存储的数据是否达到了10个字节，都要占去10个字节的空间,不足的自动用空格填充。</p>
<p>VARCHAR(M)定义的列的长度为可变长字符串，M取值可以为0~65535之间，(VARCHAR的最大有效长度由最大行大小和使用的字符集确定。整体最大长度是65,532字节）。VARCHAR值保存时只保存需要的字符数，另加一个字节来记录长度(如果列声明的长度超过255，则使用两个字节)。VARCHAR值保存时不进行填充。当值保存和检索时尾部的空格仍保留，符合标准SQL。varchar存储变长数据，但存储效率没有CHAR高。如果一个字段可能的值是不固定长度的，我们只知道它不可能超过10个字符，把它定义为 VARCHAR(10)是最合算的。VARCHAR类型的实际长度是它的值的实际长度+1。为什么”+1”呢？这一个字节用于保存实际使用了多大的长度。从空间上考虑，用varchar合适；从效率上考虑，用char合适，关键是根据实际情况找到权衡点。</p>
<p>来自： <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24549805/article/details/53426668">https://blog.csdn.net/qq_24549805/article/details/53426668</a></p>
</blockquote>
<p><strong>8.<strong>【</strong>强制</strong>】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于 5000，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p>
<blockquote>
<p> <strong>MySQL中char、varchar和text的区别</strong></p>
<p> 它们的存储方式和数据的检索方式都不一样。<br> 数据的检索效率是：char &gt; varchar &gt; text<br> 空间占用方面，就要具体情况具体分析了。</p>
<p> <strong>1.char：</strong> 存储定长数据很方便，CHAR字段上的索引效率极高，必须在括号里定义长度，可以有默认值，比如定义char(10)，那么不论你存储的数据是否达到了10个字符，都要占去10个字符的空间（自动用空格填充），且在检索的时候后面的空格会隐藏掉，所以检索出来的数据需要记得用什么trim之类的函数去过滤空格。</p>
<p> <strong>2.varchar：</strong> 存储变长数据，但存储效率没有CHAR高，必须在括号里定义长度，可以有默认值。保存数据的时候，不进行空格自动填充，而且如果数据存在空格时，当值保存和检索时尾部的空格仍会保留。另外，varchar类型的实际长度是它的值的实际长度+1，这一个字节用于保存实际使用了多大的长度。</p>
<p> <strong>3.text：</strong> 存储可变长度的非Unicode数据，最大长度为2^31-1个字符。text列不能有默认值，存储或检索过程中，不存在大小写转换，后面如果指定长度，不会报错误，但是这个长度是不起作用的，意思就是你插入数据的时候，超过你指定的长度还是可以正常插入。</p>
<p> 来自： <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/cc2d99559532">https://www.jianshu.com/p/cc2d99559532</a></p>
</blockquote>
<p><strong>9.<strong>【</strong>强制</strong>】表必备三字段：id, create_time, update_time。</p>
<p>​	<strong>说明</strong>：其中 id 必为主键，类型为 bigint unsigned、单表时自增、步长为 1。create_time, update_time 的类型均为 datetime 类型。</p>
<blockquote>
<p>create_time 为一行记录的创建时间，update_time 为一行记录的更新时间</p>
<p>datetime、timestamp精确度都是秒，datetime与时区无关，存储的范围广(1001-9999)，timestamp与时区有关，存储的范围小(1970-2038)。</p>
</blockquote>
<p><strong>10.<strong>【</strong>推荐</strong>】表的命名最好是遵循 “业务名称_表的作用”。</p>
<p>​	<strong>正例</strong>：alipay_task &#x2F; force_project &#x2F; trade_config</p>
<blockquote>
<p>方便区分和查找</p>
</blockquote>
<p><strong>11.<strong>【</strong>推荐</strong>】库名与应用名称尽量一致。</p>
<blockquote>
<p>比如你有个项目名称叫做 alipay-adapter ，那数据库名可以起名为 alipay_adapter</p>
</blockquote>
<p><strong>12.<strong>【</strong>推荐</strong>】如果修改字段含义或对字段表示的状态追加时,需要及时更新字段注释。</p>
<blockquote>
<p>字段注释要及时更新，降低沟通成本</p>
</blockquote>
<p><strong>13.<strong>【</strong>推荐</strong>】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p>
<p>​	1）不是频繁修改的字段。</p>
<p>​	2）不是 varchar 超长字段，更不能是 text 字段。</p>
<p>​	3） 不是唯一索引的字段。</p>
<p>​	<strong>正例</strong>：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p>
<blockquote>
<p>数据库三范式可以不用严格遵循，有时候适当的冗余能够提高查询效率</p>
</blockquote>
<p><strong>14.<strong>【</strong>推荐</strong>】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p>
<p>​	<strong>说明</strong>：如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
<p><strong>15.<strong>【</strong>参考</strong>】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p>
<p>​	<strong>正例</strong>：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p>
<table>
<thead>
<tr>
<th align="center">对象</th>
<th>年龄区间</th>
<th>类型</th>
<th align="center">字节</th>
<th>表示范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">人</td>
<td>150 岁之内</td>
<td>tinyint unsigned</td>
<td align="center">1</td>
<td>无符号值：0 到 255</td>
</tr>
<tr>
<td align="center">龟</td>
<td>数百岁</td>
<td>smallint unsigned</td>
<td align="center">2</td>
<td>无符号值：0 到 65535</td>
</tr>
<tr>
<td align="center">恐龙化石</td>
<td>数千万年</td>
<td>int unsigned</td>
<td align="center">4</td>
<td>无符号值：0 到约 42.9 亿</td>
</tr>
<tr>
<td align="center">太阳</td>
<td>约 50 亿年</td>
<td>bigint unsigned</td>
<td align="center">8</td>
<td>无符号值：0 到约 10 的 19 次方</td>
</tr>
</tbody></table>
<h2 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二) 索引规约"></a>(二) 索引规约</h2><ol>
<li><p>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p>
<p>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外， 即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p>
</li>
<li><p>【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。</p>
</li>
<li><p>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p>
<p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))&#x2F;count(*)的区分度来确定。</p>
</li>
<li><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。</p>
<p>说明：索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p>
</li>
<li><p>【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</p>
<p>正例：where a&#x3D;? and b&#x3D;? order by c; 索引：a_b_c</p>
<p>反例：索引如果存在范围查询，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p>
</li>
<li><p>【推荐】利用覆盖索引来进行查询操作，避免回表。</p>
<p>说明：如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这 个目录就是起到覆盖索引的作用。</p>
<p>正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效 果，用 explain 的结果，extra 列会出现：using index。</p>
</li>
<li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。</p>
<p>说明：MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。</p>
<p>正例：先快速定位需要获取的 id 段，然后再关联：</p>
<p>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id&#x3D;b.id</p>
</li>
<li><p>【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是</p>
</li>
</ol>
<p> consts 最好。</p>
<p>​	说明：</p>
<p>   1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。</p>
<p>   2） ref 指的是使用普通的索引（normal index）。</p>
<p>   3） range 对索引进行范围检索。</p>
<p>​	反例：explain 表的结果，type&#x3D;index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。</p>
<ol start="9">
<li><p>【推荐】建组合索引的时候，区分度最高的在最左边。</p>
<p>正例：如果 where a&#x3D;? and b&#x3D;? ，如果 a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。</p>
<p>说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d&#x3D;? 那么 即使 c 的区分度更高，也必须把 d 放在索引的最前列，即索引 idx_d_c。</p>
</li>
<li><p>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</p>
</li>
<li><p>【参考】创建索引时避免有如下极端误解：</p>
<p>1） 宁滥勿缺。认为一个查询就需要建一个索引。</p>
<p>2） 宁缺勿滥。认为索引会消耗空间、严重拖慢记录的更新以及行的新增速度。</p>
<p>3） 抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-RESTful-API规范（详细版）"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/04/RESTful-API%E8%A7%84%E8%8C%83%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89/"
    >RESTful API规范（详细版）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/04/RESTful-API%E8%A7%84%E8%8C%83%EF%BC%88%E8%AF%A6%E7%BB%86%E7%89%88%EF%BC%89/" class="article-date">
  <time datetime="2019-11-04T12:26:34.000Z" itemprop="datePublished">2019-11-04</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>作者: RyuGou</p>
<p>原文地址: <a target="_blank" rel="noopener" href="https://i6448038.github.io/2017/06/28/rest-%E6%8E%A5%E5%8F%A3%E8%A7%84%E8%8C%83/" title="RESTful API 规范（详细版）">RESTful API 规范（详细版）</a></p>
<p>作者公众号: 互联网技术窝</p>
<p>看的时候感觉写的非常不错 😆，看完自我介绍发现果然是个大佬</p>
</blockquote>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p><code>rest</code>是一种软件架构风格，如果你们的接口是<code>rest</code>接口，那么就可被认为你们的的接口是 restful 的，英文名词和形容词的区别。</p>
<p><code>rest</code>接口是围绕“资源”展开的，利用 HTTP 的协议，其实 rest 本也可以和 HTTP 无关，但是现在大家普遍的使用<code>rest</code>都是依托于 HTTP 协议。HTTP 的 url 即资源。</p>
<p><code>RFC 3986</code> 定义了通用的 URI 语法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URI = scheme “://” authority “/” path [ “?” query ][ “#” fragment ]</span><br></pre></td></tr></table></figure>

<ul>
<li>scheme: 指底层用的协议，如 http、https、ftp</li>
<li>host: 服务器的 IP 地址或者域名</li>
<li>port: 端口，http 中默认 80</li>
<li>path: 访问资源的路径，就是咱们各种 web 框架中定义的 route 路由</li>
<li>query: 为发送给服务器的参数</li>
<li>fragment: 锚点，定位到页面的资源，锚点为资源 id</li>
</ul>
<h2 id="2-RESTful-API-设计"><a href="#2-RESTful-API-设计" class="headerlink" title="2. RESTful API 设计"></a>2. RESTful API 设计</h2><h3 id="2-1-资源路径"><a href="#2-1-资源路径" class="headerlink" title="2.1 资源路径"></a>2.1 资源路径</h3><p>对于 rest 资源的定义，即 URL 的定义，是最重要的；想要设计出优雅的、易读的 rest 接口，其实还是挺不容易的。</p>
<h3 id="2-2-URL-中不能有动词"><a href="#2-2-URL-中不能有动词" class="headerlink" title="2.2 URL 中不能有动词"></a>2.2 URL 中不能有动词</h3><p>在 Restful 架构中，每个网址代表的是一种资源，所以网址中不能有动词，只能有名词，动词由 HTTP 的 get、post、put、delete 四种方法来表示。</p>
<h3 id="2-3-URL-结尾不应该包含斜杠“-x2F-”"><a href="#2-3-URL-结尾不应该包含斜杠“-x2F-”" class="headerlink" title="2.3 URL 结尾不应该包含斜杠“&#x2F;”"></a>2.3 URL 结尾不应该包含斜杠“&#x2F;”</h3><p>这是作为 URL 路径中处理中最重要的规则之一，正斜杠（&#x2F;）不会增加语义值，且可能导致混淆。REST API 不允许一个尾部的斜杠，不应该将它们包含在提供给客户端的链接的结尾处。</p>
<p>许多 Web 组件和框架将平等对待以下两个 URI：</p>
<p><a target="_blank" rel="noopener" href="http://api.canvas.com/shapes/">http://api.canvas.com/shapes/</a></p>
<p><a target="_blank" rel="noopener" href="http://api.canvas.com/shapes">http://api.canvas.com/shapes</a></p>
<p>但是，实际上 URI 中的每个字符都会计入资源的唯一身份的识别中。</p>
<p>两个不同的 URI 映射到两个不同的资源。如果 URI 不同，那么资源也是如此，反之亦然。因此，REST API 必须生成和传递精确的 URI，不能容忍任何的客户端尝试不精确的资源定位。</p>
<p>有些 API 碰到这种情况，可能设计为让客户端重定向到相应没有尾斜杠的 URI（也有可能会返回 301 - 用来资源重定向）。</p>
<h3 id="2-4-正斜杠分隔符”-x2F-“必须用来指示层级关系"><a href="#2-4-正斜杠分隔符”-x2F-“必须用来指示层级关系" class="headerlink" title="2.4 正斜杠分隔符”&#x2F;“必须用来指示层级关系"></a>2.4 正斜杠分隔符”&#x2F;“必须用来指示层级关系</h3><p>url 的路径中的正斜杠“&#x2F;“字符用于指示资源之间的层次关系。</p>
<p>例如：</p>
<p><a target="_blank" rel="noopener" href="http://api.user.com/schools/grades/classes/boys">http://api.user.com/schools/grades/classes/boys</a> - 学校中所有的男生</p>
<p><a target="_blank" rel="noopener" href="http://api.college.com/students/3248234/courses">http://api.college.com/students/3248234/courses</a> - 检索 id 为 3248234 的学生学习的所有课程的清单。</p>
<h3 id="2-5-应该使用连字符”-“来提高-URL-的可读性，而不是使用下划线”-”"><a href="#2-5-应该使用连字符”-“来提高-URL-的可读性，而不是使用下划线”-”" class="headerlink" title="2.5 应该使用连字符”-“来提高 URL 的可读性，而不是使用下划线”_”"></a>2.5 应该使用连字符”-“来提高 URL 的可读性，而不是使用下划线”_”</h3><p>为了使 URL 容易让人们理解，请使用连字符”-“字符来提高长路径中名称的可读性。</p>
<p>一些文本查看器为了区分强调 URI，常常会在 URI 下加上下划线。这样下划线”_”字符可能被文本查看器中默认的下划线部分地遮蔽或完全隐藏。</p>
<p>为避免这种混淆，请使用连字符”-“而不是下划线</p>
<h3 id="2-6-URL-路径中首选小写字母"><a href="#2-6-URL-路径中首选小写字母" class="headerlink" title="2.6 URL 路径中首选小写字母"></a>2.6 URL 路径中首选小写字母</h3><p>RFC 3986 将 URI 定义为区分大小写，但 scheme 和 host components 除外。</p>
<h3 id="2-7-URL-路径名词均为复数"><a href="#2-7-URL-路径名词均为复数" class="headerlink" title="2.7 URL 路径名词均为复数"></a>2.7 URL 路径名词均为复数</h3><p>为了保证 url 格式的一致性，建议使用复数形式。</p>
<h2 id="3-RESTful-API-对资源的操作"><a href="#3-RESTful-API-对资源的操作" class="headerlink" title="3. RESTful API 对资源的操作"></a>3. RESTful API 对资源的操作</h2><p>对于 rest api 资源的操作，由 HTTP 动词表示</p>
<h3 id="3-1-CURD-操作"><a href="#3-1-CURD-操作" class="headerlink" title="3.1 CURD 操作"></a>3.1 CURD 操作</h3><ul>
<li>GET：获取资源</li>
<li>POST：新建资源</li>
<li>PUT：在服务器更新资源（向客户端提供改变后的所有资源）</li>
<li>PATCH：在服务器更新资源（向客户端提供改变的属性）</li>
<li>DELETE：删除资源</li>
</ul>
<p><code>PATCH</code>一般不用，用<code>PUT</code></p>
<h3 id="3-2-资源过滤"><a href="#3-2-资源过滤" class="headerlink" title="3.2 资源过滤"></a>3.2 资源过滤</h3><p>在获取资源的时候，有可能需要获取某些“过滤”后的资源，例如指定前 10 行数据</p>
<p><a target="_blank" rel="noopener" href="http://api.user.com/schools/grades/classes/boys?page=1&page-size=10">http://api.user.com/schools/grades/classes/boys?page=1&amp;page-size=10</a></p>
<h3 id="3-3-返回状态码推荐标准-HTTP-状态码"><a href="#3-3-返回状态码推荐标准-HTTP-状态码" class="headerlink" title="3.3 返回状态码推荐标准 HTTP 状态码"></a>3.3 返回状态码推荐标准 HTTP 状态码</h3><p>有很多服务器将返回状态码一直设为 200，然后在返回 body 里面自定义一些状态码来表示服务器返回结果的状态码。由于 rest api 是直接使用的 HTTP 协议，所以它的状态码也要尽量使用 HTTP 协议的状态码。</p>
<ul>
<li>200 OK 服务器返回用户请求的数据，该操作是幂等的</li>
<li>201 CREATED 新建或者修改数据成功</li>
<li>204 NOT CONTENT 删除数据成功</li>
<li>400 BAD REQUEST 用户发出的请求有问题，该操作是幂等的</li>
<li>401 Unauthoried 表示用户没有认证，无法进行操作</li>
<li>403 Forbidden 用户访问是被禁止的</li>
<li>422 Unprocesable Entity 当创建一个对象时，发生一个验证错误</li>
<li>500 INTERNAL SERVER ERROR 服务器内部错误，用户将无法判断发出的请求是否成功</li>
<li>503 Service Unavailable 服务不可用状态，多半是因为服务器问题，例如 CPU 占用率大，等等</li>
</ul>
<h3 id="3-4-返回结果"><a href="#3-4-返回结果" class="headerlink" title="3.4 返回结果"></a>3.4 返回结果</h3><ul>
<li>GET &#x2F;collections 返回资源列表</li>
<li>GET &#x2F;collections&#x2F;:id 返回单独的资源</li>
<li>POST &#x2F;collections 返回新生成的资源对象</li>
<li>PUT &#x2F;collections&#x2F;:id 返回完整的资源对象</li>
<li>PATCH &#x2F;collections&#x2F;:id 返回被修改的属性</li>
<li>DELETE &#x2F;collections&#x2F;:id 返回一个空文档</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/restful/" rel="tag">restful</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-《刻意练习》高效学习的3F法则"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/03/%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%843F%E6%B3%95%E5%88%99/"
    >《刻意练习》高效学习的3F法则</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/03/%E3%80%8A%E5%88%BB%E6%84%8F%E7%BB%83%E4%B9%A0%E3%80%8B%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0%E7%9A%843F%E6%B3%95%E5%88%99/" class="article-date">
  <time datetime="2019-11-03T05:00:54.000Z" itemprop="datePublished">2019-11-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>视频地址: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av62616953">https://www.bilibili.com/video/av62616953</a></p>
</blockquote>
<h2 id="Part-1-刻意练习的黄金法则-3F法则"><a href="#Part-1-刻意练习的黄金法则-3F法则" class="headerlink" title="Part 1 刻意练习的黄金法则-3F法则"></a>Part 1 刻意练习的黄金法则-3F法则</h2><h3 id="1-专注"><a href="#1-专注" class="headerlink" title="1. 专注"></a>1. 专注</h3><ul>
<li><p>起步使用较短时段（交叉安排）</p>
<p>可以开始先学十分钟，接着休息五分钟，然后再学十分钟，不断重复。</p>
</li>
<li><p>缓慢延长学习时间（循序渐进）</p>
<p>坚持一段时间，再尝试二十分钟，三十分钟</p>
</li>
<li><p>若无法坚持则缩短（以退为进）</p>
<p>如果在提升过程中遇到了瓶颈，再把学习时间缩短一点，等适应了之后，再继续延长学习时间。</p>
</li>
</ul>
<h3 id="2-反馈"><a href="#2-反馈" class="headerlink" title="2. 反馈"></a>2. 反馈</h3><ul>
<li><p>来自内部，自己发现自己的不足。</p>
</li>
<li><p>来自外部，其他人指出自己的不足。</p>
<p>找个好导师，是各个领域学习的通用捷径，但外部反馈多了之后，也会引起内部反馈。</p>
</li>
</ul>
<h3 id="3-纠正"><a href="#3-纠正" class="headerlink" title="3. 纠正"></a>3. 纠正</h3><ul>
<li>给出反馈后的下一步，就是纠正不足。</li>
</ul>
<h2 id="Part-2-如何保持学习动力"><a href="#Part-2-如何保持学习动力" class="headerlink" title="Part 2 如何保持学习动力"></a>Part 2 如何保持学习动力</h2><h3 id="1-如何保持学习动力。"><a href="#1-如何保持学习动力。" class="headerlink" title="1. 如何保持学习动力。"></a>1. 如何保持学习动力。</h3><p>意志力不是天生，绝对的，我们可能在某件事上意志力充足，但在另一件事上毫无意志，这个差异的关键在于动机是不是足够。</p>
<h3 id="2-保持动机的做法有两种："><a href="#2-保持动机的做法有两种：" class="headerlink" title="2 保持动机的做法有两种："></a>2 保持动机的做法有两种：</h3><h4 id="正向：强化进步的理由"><a href="#正向：强化进步的理由" class="headerlink" title="正向：强化进步的理由"></a>正向：强化进步的理由</h4><ul>
<li><p>内部动机-Tips:</p>
<p>①真心的喜欢</p>
</li>
<li><p>外部动机-Tips:</p>
<p>①物质奖励<br>②团体约束感</p>
</li>
</ul>
<h4 id="反向：弱化退步的理由"><a href="#反向：弱化退步的理由" class="headerlink" title="反向：弱化退步的理由"></a>反向：弱化退步的理由</h4><p>①拒绝会使你失败外界诱因。不要被杂七杂八事情拖累你</p>
<blockquote>
<p>做你喜欢的事就没有这么难</p>
</blockquote>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-使用这些idea插件让开发效率提高5倍"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/02/%E4%BD%BF%E7%94%A8%E8%BF%99%E4%BA%9Bidea%E6%8F%92%E4%BB%B6%E8%AE%A9%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E6%8F%90%E9%AB%985%E5%80%8D/"
    >使用这些idea插件让开发效率提高5倍</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/02/%E4%BD%BF%E7%94%A8%E8%BF%99%E4%BA%9Bidea%E6%8F%92%E4%BB%B6%E8%AE%A9%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E6%8F%90%E9%AB%985%E5%80%8D/" class="article-date">
  <time datetime="2019-11-02T04:15:44.000Z" itemprop="datePublished">2019-11-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>idea 有很多非常好用的插件，用好了这些插件能够极大的提高开发效率</p>
<p>插件用的好，bug 就追不上了我 😆</p>
</blockquote>
<h2 id="0-idea-插件如何安装"><a href="#0-idea-插件如何安装" class="headerlink" title="0. idea 插件如何安装"></a>0. idea 插件如何安装</h2><p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191102123349.png"></p>
<p>打开 idea 的设置页面，选择 Plugins 选项即可搜索和安装插件</p>
<h2 id="1-JRebel-for-IntelliJ"><a href="#1-JRebel-for-IntelliJ" class="headerlink" title="1. JRebel for IntelliJ"></a>1. JRebel for IntelliJ</h2><p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191102123617.png"></p>
<blockquote>
<p>日常开发中，当你修改任意一个 java 文件时，tomcat 并不能将此文件的修改实时编译并反映到运行的项目中去，所以只能重启项目。这样做非常耗时和麻烦。使用 JRebel 之后只要选择 Bulid 中的 Build Project 选项即可热部署项目，用着非常爽，<strong>强烈推荐</strong>。</p>
</blockquote>
<p>具体安装和使用参考之前的文章:  <a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/3lihKvmSF79YqnvqOmAKZQ">idea 热部署插件 jrebel，开发必备</a></p>
<h2 id="2-Codota"><a href="#2-Codota" class="headerlink" title="2. Codota"></a>2. Codota</h2><blockquote>
<p>Codota 是一款智能 AI 代码补全插件，它从数百万 Java 程序中学习代码，最终能根据程序上下文提示并补全代码，帮助开发者减少失误，提升工作效率，并且它还是免费的。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191102130027.png"></p>
<h2 id="3-Translation"><a href="#3-Translation" class="headerlink" title="3. Translation"></a>3. Translation</h2><blockquote>
<p>翻译插件，有了它妈妈再也不用担心我的英语渣了</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191102130514.png"></p>
<p>我常用它两个功能:</p>
<ul>
<li>翻译, 就是中英翻译, 可以当词典用</li>
<li>翻译替换, 就是将原文直接翻译替换, 起变量名字时非常有用: 起个中文名, 然后翻译替换就好了.</li>
</ul>
<h2 id="4-RestfulToolkit"><a href="#4-RestfulToolkit" class="headerlink" title="4. RestfulToolkit"></a>4. RestfulToolkit</h2><blockquote>
<p>这款插件可以根据 URL 直接跳转到对应的方法。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191102133937.png"></p>
<p>快捷键</p>
<ul>
<li>windows：ctrl + \</li>
<li>mac：cmd + \</li>
</ul>
<h2 id="5-Lombok"><a href="#5-Lombok" class="headerlink" title="5. Lombok"></a>5. Lombok</h2><blockquote>
<p>在过往的 Java 项目中，充斥着太多不友好的代码：POJO 的 getter&#x2F;setter&#x2F;toString；异常处理；I&#x2F;O 流的关闭操作等等，这些样板代码既没有技术含量，又影响着代码的美观，Lombok 应运而生。它让代码变得非常简洁。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191102132048.png"></p>
<p>使用 @Data 注解可以自动生成以上的方法，再也不用手动生成烦人的 getter&#x2F;setter&#x2F;toString 方法了</p>
<p>具体 Lombok 使用方法可以参考这篇文章: <a target="_blank" rel="noopener" href="https://juejin.im/post/5b00517cf265da0ba0636d4b">https://juejin.im/post/5b00517cf265da0ba0636d4b</a></p>
<h2 id="6-GenerateAllSetter"><a href="#6-GenerateAllSetter" class="headerlink" title="6. GenerateAllSetter"></a>6. GenerateAllSetter</h2><blockquote>
<p>一键调用一个对象的所有 set 方法并且赋予默认值 在对象字段多的时候非常方便</p>
</blockquote>
<p><img src="https://plugins.jetbrains.com/files/9360/screenshot_16614.png" alt="Screenshot 2"></p>
<h2 id="7-Alibaba-Cloud-Toolkit"><a href="#7-Alibaba-Cloud-Toolkit" class="headerlink" title="7. Alibaba Cloud Toolkit"></a>7. Alibaba Cloud Toolkit</h2><blockquote>
<p>Cloud Toolkit 帮助开发者将本地应用程序一键部署到线下自有 VM，或阿里云 ECS、EDAS 和 Kubernetes 中去。内置终端 Terminal、文件上传、数据库 SQL Console 能功能。用它来部署项目非常方便。</p>
</blockquote>
<p><img src="https://gw.alicdn.com/tfs/TB1uh9xASrqK1RjSZK9XXXyypXa-1259-737.gif"></p>
<h2 id="8-Material-Theme-UI"><a href="#8-Material-Theme-UI" class="headerlink" title="8. Material Theme UI"></a>8. Material Theme UI</h2><blockquote>
<p>Material Theme UI 是 JetBrains IDE（IntelliJ IDEA，WebStorm，Android Studio 等）的插件，可将原始外观更改为 <a target="_blank" rel="noopener" href="https://material.io/">Material Design</a>外观。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191102132723.png"></p>
<p>使用之后的 idea 界面变得非常漂亮，心情好了，写代码的速度也变快了。</p>
<h2 id="9-Properties-to-YAML-Converter"><a href="#9-Properties-to-YAML-Converter" class="headerlink" title="9. Properties to YAML Converter"></a>9. Properties to YAML Converter</h2><blockquote>
<p>将 Properties 配置文件转换为 YAML 配置文件</p>
</blockquote>
<ul>
<li><p>首先选择属性文件。</p>
</li>
<li><p>在属性文件上单击鼠标右键后，在菜单中使用“转换”操作。</p>
</li>
</ul>
<h2 id="10-MyBatis-plugin"><a href="#10-MyBatis-plugin" class="headerlink" title="10. MyBatis plugin"></a>10. MyBatis plugin</h2><blockquote>
<p>mapper.java 和 mapper.xml 之间任性跳转。点击小箭头就能跳转。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191102133740.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8E%9F%E5%88%9B/" rel="tag">原创</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/8/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/10/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> 高行行
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="高行行的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://gaohanghang.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/twitter">Twitter</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://weibo.com/u/5125203090">微博</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>