<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="个人公众号《骇客与画家》" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 高行行的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">高行行的个人博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '科技需要人文的浇灌', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-MySQL：left-join-避坑指南"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/24/MySQL%EF%BC%9Aleft-join-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"
    >MySQL：left join 避坑指南</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/24/MySQL%EF%BC%9Aleft-join-%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/" class="article-date">
  <time datetime="2019-11-23T16:39:14.000Z" itemprop="datePublished">2019-11-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ktZpTSKqXjAtOAbXrSMMtg">https://mp.weixin.qq.com/s/ktZpTSKqXjAtOAbXrSMMtg</a></p>
</blockquote>
<blockquote>
<p>作者：MageekChiu</p>
<p>segmentfault.com&#x2F;a&#x2F;1190000020458807</p>
<p>总结：</p>
<p>在 left join 语句中，左表过滤必须放 where 条件中，右表过滤必须放 on 条件中，这样结果才能不多不少，刚刚好。</p>
<p>廖雪峰的在线 SQL：<a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611432985088">https://www.liaoxuefeng.com/wiki/1177760294764384/1179611432985088</a></p>
</blockquote>
<h2 id="1-现象"><a href="#1-现象" class="headerlink" title="1. 现象"></a>1. 现象</h2><p>left join 在我们使用 mysql 查询的过程中可谓非常常见，比如博客里一篇文章有多少条评论、商城里一个货物有多少评论、一条评论有多少个赞等等。但是由于对 join、on、where 等关键字的不熟悉，有时候会导致查询结果与预期不符，所以今天我就来总结一下，一起避坑。</p>
<p>这里我先给出一个场景，并抛出两个问题，如果你都能答对那这篇文章就不用看了。</p>
<p>假设有一个班级管理应用，有一个表 classes，存了所有的班级；有一个表 students，存了所有的学生，具体数据如下（感谢廖雪峰的在线 SQL）：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> classes;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191201173033.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM students;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191201173048.png"></p>
<p>那么现在有两个需求：</p>
<blockquote>
<ul>
<li>找出每个班级的名称及其对应的女同学数量</li>
<li>找出一班的同学总数</li>
</ul>
</blockquote>
<p>对于需求 1，大多数人不假思索就能想出如下两种 sql 写法，请问哪种是对的？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.name, <span class="built_in">count</span>(s.name) <span class="keyword">as</span> num</span><br><span class="line">    <span class="keyword">FROM</span> classes c <span class="keyword">left</span> <span class="keyword">join</span> students s</span><br><span class="line">    <span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id</span><br><span class="line">    <span class="keyword">and</span> s.gender <span class="operator">=</span> <span class="string">&#x27;F&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> c.name</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT c.name, count(s.name) as num</span><br><span class="line">    FROM classes c left join students s</span><br><span class="line">    on s.class_id = c.id</span><br><span class="line">    where s.gender = &#x27;F&#x27;</span><br><span class="line">    group by c.name</span><br></pre></td></tr></table></figure>

<p>对于需求 2，大多数人也可以不假思索的想出如下两种 sql 写法，请问哪种是对的？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.name, <span class="built_in">count</span>(s.name) <span class="keyword">as</span> num</span><br><span class="line">    <span class="keyword">FROM</span> classes c <span class="keyword">left</span> <span class="keyword">join</span> students s</span><br><span class="line">    <span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id</span><br><span class="line">    <span class="keyword">where</span> c.name <span class="operator">=</span> <span class="string">&#x27;一班&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> c.name</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> c.name, <span class="built_in">count</span>(s.name) <span class="keyword">as</span> num</span><br><span class="line">    <span class="keyword">FROM</span> classes c <span class="keyword">left</span> <span class="keyword">join</span> students s</span><br><span class="line">    <span class="keyword">on</span> s.class_id <span class="operator">=</span> c.id</span><br><span class="line">    <span class="keyword">and</span> c.name <span class="operator">=</span> <span class="string">&#x27;一班&#x27;</span></span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> c.name</span><br></pre></td></tr></table></figure>

<p>请不要继续往下翻 ！！先给出你自己的答案，正确答案就在下面。<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~<br>~</p>
<p>答案是<strong>两个需求都是第一条语句是正确的</strong>，要搞清楚这个问题，就得明白 mysql 对于 left join 的执行原理，下节进行展开。</p>
<h2 id="2-根源"><a href="#2-根源" class="headerlink" title="2. 根源"></a>2. 根源</h2><p>mysql 对于 left join 的采用类似嵌套循环的方式来进行从处理，以下面的语句为例：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> LT <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> RT <span class="keyword">ON</span> P1(LT,RT)) <span class="keyword">WHERE</span> P2(LT,RT)</span><br></pre></td></tr></table></figure>

<p>其中 P1 是 on 过滤条件，缺失则认为是 TRUE，P2 是 where 过滤条件，缺失也认为是 TRUE，该语句的执行逻辑可以描述为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FOR</span> <span class="keyword">each</span> <span class="type">row</span> lt <span class="keyword">in</span> LT &#123;<span class="operator">/</span><span class="operator">/</span> 遍历左表的每一行</span><br><span class="line">  BOOL b <span class="operator">=</span> <span class="literal">FALSE</span>;</span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">each</span> <span class="type">row</span> rt <span class="keyword">in</span> RT such that P1(lt, rt) &#123;<span class="operator">/</span><span class="operator">/</span> 遍历右表每一行，找到满足<span class="keyword">join</span>条件的行</span><br><span class="line">    IF P2(lt, rt) &#123;<span class="operator">/</span><span class="operator">/</span>满足 <span class="keyword">where</span> 过滤条件</span><br><span class="line">      t:<span class="operator">=</span>lt<span class="operator">||</span>rt;<span class="operator">/</span><span class="operator">/</span>合并行，输出该行</span><br><span class="line">    &#125;</span><br><span class="line">    b<span class="operator">=</span><span class="literal">TRUE</span>;<span class="operator">/</span><span class="operator">/</span> lt在RT中有对应的行</span><br><span class="line">  &#125;</span><br><span class="line">  IF (<span class="operator">!</span>b) &#123; <span class="operator">/</span><span class="operator">/</span> 遍历完RT，发现lt在RT中没有有对应的行，则尝试用<span class="keyword">null</span>补一行</span><br><span class="line">    IF P2(lt,<span class="keyword">NULL</span>) &#123;<span class="operator">/</span><span class="operator">/</span> 补上<span class="keyword">null</span>后满足 <span class="keyword">where</span> 过滤条件</span><br><span class="line">      t:<span class="operator">=</span>lt<span class="operator">||</span><span class="keyword">NULL</span>; <span class="operator">/</span><span class="operator">/</span> 输出lt和<span class="keyword">null</span>补上的行</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，实际情况中 MySQL 会使用 buffer 的方式进行优化，减少行比较次数，不过这不影响关键的执行流程，不在本文讨论范围之内。</p>
<p>从这个伪代码中，我们可以看出两点：</p>
<blockquote>
<ul>
<li>如果想对右表进行限制，则一定要在 on 条件中进行，若在 where 中进行则可能导致数据缺失，导致左表在右表中无匹配行的行在最终结果中不出现，违背了我们对 left join 的理解。因为对左表无右表匹配行的行而言，遍历右表后 b&#x3D;FALSE,所以会尝试用 NULL 补齐右表，但是此时我们的 P2 对右表行进行了限制，NULL 若不满足 P2(NULL 一般都不会满足限制条件，除非 IS NULL 这种)，则不会加入最终的结果中，导致结果缺失。</li>
<li>如果没有 where 条件，无论 on 条件对左表进行怎样的限制，左表的每一行都至少会有一行的合成结果，对左表行而言，若右表若没有对应的行，则右表遍历结束后 b&#x3D;FALSE，会用一行 NULL 来生成数据，而这个数据是多余的。所以对左表进行过滤必须用 where。</li>
</ul>
</blockquote>
<p>下面展开两个需求的错误语句的执行结果和错误原因：</p>
<p>需求 1</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191201173118.png"></p>
<p>需求 2</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191124233105.png"></p>
<p>需求 1 由于在 where 条件中对右表限制，导致数据缺失（四班应该有个为 0 的结果）</p>
<p>需求 2 由于在 on 条件中对左表限制，导致数据多余（其他班的结果也出来了，还是错的）</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>通过上面的问题现象和分析，可以得出了结论：在 left join 语句中，左表过滤必须放 where 条件中，右表过滤必须放 on 条件中，这样结果才能不多不少，刚刚好。</p>
<p>SQL 看似简单，其实也有很多细节原理在里面，一个小小的混淆就会造成结果与预期不符，所以平时要注意这些细节原理，避免关键时候出错。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-TED：如何打败拖延症并充分利用时间？"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/24/TED%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87%E5%B9%B6%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E6%97%B6%E9%97%B4%EF%BC%9F/"
    >TED：如何打败拖延症并充分利用时间？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/24/TED%EF%BC%9A%E5%A6%82%E4%BD%95%E6%89%93%E8%B4%A5%E6%8B%96%E5%BB%B6%E7%97%87%E5%B9%B6%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E6%97%B6%E9%97%B4%EF%BC%9F/" class="article-date">
  <time datetime="2019-11-23T16:33:49.000Z" itemprop="datePublished">2019-11-24</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av76592342">https://www.bilibili.com/video/av76592342</a></p>
</blockquote>
<ol>
<li><p>确定一件要做的、对你和周围的人都有益的事情</p>
</li>
<li><p>制定做成这件事的计划</p>
</li>
<li><p>把计划分解为可以着手的小计划</p>
</li>
<li><p>对自己有充分了解 （一次工作多次时间会感到疲惫，一天能做到几次这样的工作）</p>
</li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-算法必考题"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/21/%E7%AE%97%E6%B3%95%E5%BF%85%E8%80%83%E9%A2%98/"
    >算法必考题</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/21/%E7%AE%97%E6%B3%95%E5%BF%85%E8%80%83%E9%A2%98/" class="article-date">
  <time datetime="2019-11-21T11:43:26.000Z" itemprop="datePublished">2019-11-21</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h2 id="LeetCode-215-数组中的第-K-个最大元素"><a href="#LeetCode-215-数组中的第-K-个最大元素" class="headerlink" title="LeetCode 215 数组中的第 K 个最大元素"></a>LeetCode 215 数组中的第 K 个最大元素</h2><blockquote>
<p>题目地址：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p>
<p>题解地址：<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode/</a></p>
<p>总结：</p>
<ol>
<li>排序</li>
<li>堆<ul>
<li>时间复杂度 : <em>*<em>O</em>(<em>N</em>log*k</em>)**。</li>
<li>空间复杂度 : **<em>O</em>(<em>k</em>)**，用于存储堆元素</li>
</ul>
</li>
<li>快速选择<ul>
<li>时间复杂度 : 平均情况 *O(N)*，最坏情况 *O(N^2)*。</li>
<li>空间复杂度 : *O(1)*。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="方法零：排序"><a href="#方法零：排序" class="headerlink" title="方法零：排序"></a>方法零：排序</h3><p>最朴素的方法是先对数组进行排序，再返回倒数第 k 个元素，就像 Python 中 <code>sorted(nums)[-k]</code>。</p>
<p>算法的时间复杂度为 *O(NlogN)*，空间复杂度为 *O(1)*。这个时间复杂度并不令人满意，让我们试着用额外空间来优化时间复杂度。</p>
<h3 id="方法一：堆"><a href="#方法一：堆" class="headerlink" title="方法一：堆"></a>方法一：堆</h3><p>思路是创建一个小顶堆，将所有数组中的元素加入堆中，并保持堆的大小小于等于 k。这样，堆中就保留了前 k 个最大的元素。这样，堆顶的元素就是正确答案。</p>
<p>像大小为<code> k</code> 的堆中添加元素的时间复杂度为 *O(logk)*，我们将重复该操作 <code>N</code> 次，故总时间复杂度为 *O(Nlogk)*。</p>
<p>在 Python 的 <code>heapq</code> 库中有一个 <code>nlargest</code> 方法，具有同样的时间复杂度，能将代码简化到只有一行。</p>
<p>本方法优化了时间复杂度，但需要 <em>O(k)</em> 的空间复杂度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// init heap &#x27;the smallest element first&#x27;</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap =</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((n1, n2) -&gt; n1 - n2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// keep k largest elements in the heap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n: nums) &#123;</span><br><span class="line">          heap.add(n);</span><br><span class="line">          <span class="keyword">if</span> (heap.size() &gt; k)</span><br><span class="line">            heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// output</span></span><br><span class="line">        <span class="keyword">return</span> heap.poll();        </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 : *O(Nlogk)*。</li>
<li>空间复杂度 : *O(k)*，用于存储堆元素。</li>
</ul>
<h3 id="方法二：快速选择"><a href="#方法二：快速选择" class="headerlink" title="方法二：快速选择"></a>方法二：快速选择</h3><p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Quickselect">快速选择算法</a>  的平均时间复杂度为 O(N)。就像快速排序那样，本算法也是 Tony Hoare 发明的，因此也被称为 <em>Hoare选择算法</em>。</p>
<p>本方法大致上与快速排序相同。简便起见，注意到第 <code>k</code> 个最大元素也就是第 <code>N - k</code> 个最小元素，因此可以用第 <code>k</code> 小算法来解决本问题。</p>
<p>首先，我们选择一个枢轴，并在线性时间内定义其在排序数组中的位置。这可以通过 <em>划分算法</em> 的帮助来完成。</p>
<blockquote>
<p>为了实现划分，沿着数组移动，将每个元素与枢轴进行比较，并将小于枢轴的所有元素移动到枢轴的左侧。</p>
</blockquote>
<p>这样，在输出的数组中，枢轴达到其合适位置。所有小于枢轴的元素都在其左侧，所有大于或等于的元素都在其右侧。</p>
<p>这样，数组就被分成了两部分。如果是快速排序算法，会在这里递归地对两部分进行快速排序，时间复杂度为 *O(N logN)*。</p>
<p>而在这里，由于知道要找的第 <code>N - k</code> 小的元素在哪部分中，我们不需要对两部分都做处理，这样就将平均时间复杂度下降到 *O(N)*。</p>
<p>最终的算法十分直接了当 :</p>
<ul>
<li>随机选择一个枢轴。</li>
<li>使用划分算法将枢轴放在数组中的合适位置 <code>pos</code>。将小于枢轴的元素移到左边，大于等于枢轴的元素移到右边。</li>
<li>比较 <code>pos</code> 和 <code>N - k</code> 以决定在哪边继续递归处理。</li>
</ul>
<blockquote>
<p>! 注意，本算法也适用于有重复的数组</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191121203305.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">quickselect</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> k_smallest)</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Returns the k-th smallest element of list within left..right.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="comment">// If the list contains only one element,</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.nums[left];  <span class="comment">// return that element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// select a random pivot_index</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">random_num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot_index</span> <span class="operator">=</span> left + random_num.nextInt(right - left); </span><br><span class="line">    </span><br><span class="line">    pivot_index = partition(left, right, pivot_index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the pivot is on (N - k)th smallest position</span></span><br><span class="line">    <span class="keyword">if</span> (k_smallest == pivot_index)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.nums[k_smallest];</span><br><span class="line">    <span class="comment">// go left side</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k_smallest &lt; pivot_index)</span><br><span class="line">      <span class="keyword">return</span> quickselect(left, pivot_index - <span class="number">1</span>, k_smallest);</span><br><span class="line">    <span class="comment">// go right side</span></span><br><span class="line">    <span class="keyword">return</span> quickselect(pivot_index + <span class="number">1</span>, right, k_smallest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="comment">// kth largest is (N - k)th smallest</span></span><br><span class="line">    <span class="keyword">return</span> quickselect(<span class="number">0</span>, size - <span class="number">1</span>, size - k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度 : 平均情况 *O(N)*，最坏情况 *O(N^2)*。</li>
<li>空间复杂度 : *O(1)*。</li>
</ul>
<h2 id="反转单链表"><a href="#反转单链表" class="headerlink" title="反转单链表"></a>反转单链表</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-深入理解JVM垃圾收集机制-JDK1-8"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6-JDK1-8/"
    >深入理解JVM垃圾收集机制(JDK1.8)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/20/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6-JDK1-8/" class="article-date">
  <time datetime="2019-11-20T13:57:44.000Z" itemprop="datePublished">2019-11-20</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>本文作者：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/woshimrf" title="@Ryan Miao">@Ryan Miao</a></p>
<p>本文链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/woshimrf/p/jvm-garbage.html">https://www.cnblogs.com/woshimrf/p/jvm-garbage.html</a></p>
</blockquote>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/otvlpsgqly.svg" alt="思维导图"></p>
<h2 id="1-垃圾收集算法"><a href="#1-垃圾收集算法" class="headerlink" title="1. 垃圾收集算法"></a>1. 垃圾收集算法</h2><h3 id="1-1-标记-清除算法"><a href="#1-1-标记-清除算法" class="headerlink" title="1.1 标记-清除算法"></a>1.1 标记-清除算法</h3><p>最基础的收集算法是“标记-清除”(Mark-Sweep)算法，分两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p>
<p>不足：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一个的垃圾收集动作。</p>
<h3 id="1-2-复制算法"><a href="#1-2-复制算法" class="headerlink" title="1.2 复制算法"></a>1.2 复制算法</h3><p>为了解决效率问题，一种称为复制(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。代价是内存缩小为原来的一半。</p>
<p>商业虚拟机用这个回收算法来回收新生代。IBM 研究表明 98%的对象是“朝生夕死“，不需要按照 1-1 的比例来划分内存空间，而是将内存分为一块较大的”Eden“空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一个 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。Hotspot 虚拟机默认 Eden 和 Survivor 的比例是 8-1.即每次可用整个新生代的 90%, 只有一个 survivor，即 1&#x2F;10 被”浪费“。当然，98%的对象回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10%的对象存活，当 Survivor 空间不够时，需要依赖其他内存(老年代)进行分配担保(Handle Promotion).</p>
<p>如果另外一块 survivor 空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
<h3 id="1-3-eden-survivor-复制过程概述"><a href="#1-3-eden-survivor-复制过程概述" class="headerlink" title="1.3 eden survivor 复制过程概述"></a>1.3 eden survivor 复制过程概述</h3><p>Eden Space 字面意思是伊甸园，对象被创建的时候首先放到这个区域，进行垃圾回收后，不能被回收的对象被放入到空的 survivor 区域。</p>
<p>Survivor Space 幸存者区，用于保存在 eden space 内存区域中经过垃圾回收后没有被回收的对象。Survivor 有两个，分别为 To Survivor、 From Survivor，这个两个区域的空间大小是一样的。执行垃圾回收的时候 Eden 区域不能被回收的对象被放入到空的 survivor（也就是 To Survivor，同时 Eden 区域的内存会在垃圾回收的过程中全部释放），另一个 survivor（即 From Survivor）里不能被回收的对象也会被放入这个 survivor（即 To Survivor），然后 To Survivor 和 From Survivor 的标记会互换，始终保证一个 survivor 是空的。</p>
<p>为啥需要两个 survivor？因为需要一个完整的空间来复制过来。当满的时候晋升。每次都往标记为 to 的里面放，然后互换，这时 from 已经被清空，可以当作 to 了。</p>
<h3 id="1-4-标记-整理算法"><a href="#1-4-标记-整理算法" class="headerlink" title="1.4 标记-整理算法"></a>1.4 标记-整理算法</h3><p>复制收集算法在对象成活率较高时就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费 50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100%存活的极端情况，所以，老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出一种”标记-整理“Mark-Compact 算法，标记过程仍然和标记-清除一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理端边界以外的内存.</p>
<h3 id="1-5-分代收集算法"><a href="#1-5-分代收集算法" class="headerlink" title="1.5 分代收集算法"></a>1.5 分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用”分代收集“(Generational Collection)算法，这种算法根据对象存活周期的不同将内存划分为几块。一般把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代，每次垃圾收集时都发现大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率较高，没有额外的空间对它进行分配担保，就必须使用”标记-清理“和”标记-整理“算法来进行回收。</p>
<h2 id="2-HotSpot-算法实现"><a href="#2-HotSpot-算法实现" class="headerlink" title="2. HotSpot 算法实现"></a>2. HotSpot 算法实现</h2><p>在 Java 语言中，可作为 GC Roots 的对象包括下面几种：</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法去中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI(即一般说的 Native 方法)引用的对象</li>
</ul>
<p>从可达性分析中从 GC Roots 节点找引用链这个操作为例，可作为 GC Roots 的节点主要在全局性的引用(例如常量或类静态属性)与执行上下文(例如栈帧中的本地变量表)中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查里面的引用，必然消耗很多时间。</p>
<p>可达性分析对执行时间的敏感还体现在 GC 停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行–这里”一致性“的意思是指整个分析期间整个执行系统看起来就像被冻结在某个时间点，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致 GC 进行时必须停顿所有 Java 执行线程(Sun 公司将这件事情称为”Stop The World“)的一个重要原因，即使是在号称(几乎)不会发生停顿的 CMS 收集器中，枚举根节点时也必须停顿的。</p>
<p>安全点，Safepoint</p>
<h2 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3. 垃圾收集器"></a>3. 垃圾收集器</h2><h3 id="3-1-Serial-收集器"><a href="#3-1-Serial-收集器" class="headerlink" title="3.1 Serial 收集器"></a>3.1 Serial 收集器</h3><p>标记-复制。</p>
<p>单线程，一个 CPU 或一条收集线程去完成垃圾收集工作，收集时必须暂停其他所有的工作线程，直到它结束。</p>
<p>虽然如此，它依然是虚拟机运行在 Client 模式下的默认<strong>新生代</strong>收集器。简单而高效。</p>
<h3 id="3-2-ParNew-收集器"><a href="#3-2-ParNew-收集器" class="headerlink" title="3.2 ParNew 收集器"></a>3.2 ParNew 收集器</h3><p>ParNew 是 Serial 收集器的多线程版本。Server 模式下默认<strong>新生代</strong>收集器，除了 Serial 收集器之外，只有它能与 CMS 收集器配合工作。</p>
<h3 id="3-3-并行-Parallel"><a href="#3-3-并行-Parallel" class="headerlink" title="3.3 并行 Parallel"></a>3.3 并行 Parallel</h3><p>指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
<h3 id="3-4-并发-Concurrent"><a href="#3-4-并发-Concurrent" class="headerlink" title="3.4 并发 Concurrent"></a>3.4 并发 Concurrent</h3><p>指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序再继续运行，而垃圾收集程序运行于另一个 CPU 上。</p>
<h3 id="3-5-Parallel-Scavenge-收集器"><a href="#3-5-Parallel-Scavenge-收集器" class="headerlink" title="3.5 Parallel Scavenge 收集器"></a>3.5 Parallel Scavenge 收集器</h3><p>Parallel Scavenge 收集器是一个<strong>新生代</strong>收集器，它也是使用复制算法的收集器。看上去来 ParNew 一样，有什么特别？</p>
<p>Parallel Scavenge 收集器的特点是它的关注点与其他收集器不同，CMS 等收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间。而 Parallel Scavenge 收集器的目标则是达到一个可控制的吞吐量(Throughput)。所谓吞吐量就是 CPU 用于运行用户代码的时间和 CPU 总小号时间的比值，即吞吐量 &#x3D; 运行用户代码时间 &#x2F; (运行用户代码时间+垃圾收集时间)，虚拟机总共运行了 100min，其中垃圾收集花费了 1min，那吞吐量就是 99%.</p>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效地利用 CPU 时间，主要适合在后台运算而不需要太多交互的任务。</p>
<p>Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 <code>-XX:MaxGCPauseMillis</code>以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>。</p>
<h3 id="3-6-Serial-Old-收集器"><a href="#3-6-Serial-Old-收集器" class="headerlink" title="3.6 Serial Old 收集器"></a>3.6 Serial Old 收集器</h3><p>Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器。给 Client 模式下的虚拟机使用。</p>
<p>新生代采用复制算法，暂停所有用户线程；</p>
<p>老年代采用标记-整理算法，暂停所有用户线程；</p>
<h3 id="3-7-Parallel-Old-收集器"><a href="#3-7-Parallel-Old-收集器" class="headerlink" title="3.7 Parallel Old 收集器"></a>3.7 Parallel Old 收集器</h3><p>这里注意，Parallel Scavage 收集器架构中本身有 PS MarkSweep 收集器来收集老年代，并非直接使用了 Serial Old,但二者接近。本人 win10 64 位系统，jdk1.8.0_102，测试默认垃圾收集器为：<strong>PS MarkSweep</strong> 和 <strong>PS Scavenge</strong>。 也就是说 Java8 的默认并不是 G1。</p>
<p>这是”吞吐量优先“，注重吞吐量以及 CPU 资源敏感的场合都可以优先考虑 Parallel Scavenge 和 Parallel Old(PS Mark Sweep)。Java8 默认就是这个。</p>
<h3 id="3-8-CMS-收集器"><a href="#3-8-CMS-收集器" class="headerlink" title="3.8 CMS 收集器"></a>3.8 CMS 收集器</h3><p>CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的 Java 应用集中在互联网站或者 B&#x2F;S 系统的服务端上，这类尤其重视服务的响应速度，希望系统停顿时间最短。CMS 收集器就非常符合这类应用的需求。</p>
<p>CMS 基于 <code>标记-清除</code>算法实现。整个过程分为 4 个步骤：</p>
<ol>
<li>初始标记(CMS initial mark) -stop the world</li>
<li>并发标记(CMS concurrent mark)</li>
<li>重新标记(CMS remark) -stop the world</li>
<li>并发清除(CMS concurrent sweep)</li>
</ol>
<p>初始标记，重新标记这两个步骤仍然需要 Stop The World, 初始标记仅仅标记以下 GC Roots 能直接关联的对象，速度很快。</p>
<p>并发标记就是进行 GC Roots Tracing 的过程；</p>
<p>而重新标记阶段则是为了修正并发标记期间因为用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段停顿比初始标记稍微长，但远比并发标记的时间短。</p>
<p>整个过程耗时最长的并发标记和并发清除过程，收集器都可以与用户线程一起工作。总体上来说，CMS 收集器的内存回收过程与用户线程一起并发执行的。</p>
<p>CMS 特点：并发收集，低停顿。</p>
<p><strong>缺点</strong></p>
<ol>
<li><p>CMS 收集器对 CPU 资源非常敏感。默认启动的回收线程数是(CPU+3)&#x2F;4. 当 CPU 4 个以上时，并发回收垃圾收集线程不少于 25%的 CPU 资源。</p>
</li>
<li><p>CMS 收集器无法处理浮动垃圾(Floating Garbage), 可能出现”Concurrent Mode Failure“失败而导致另一次 Full GC 的产生。由于 CMS 并发清理时，用户线程还在运行，伴随产生新垃圾，而这一部分出现在标记之后，只能下次 GC 时再清理。这一部分垃圾就称为”浮动垃圾“。</p>
<p>由于 CMS 运行时还需要给用户空间继续运行，则不能等老年代几乎被填满再进行收集，需要预留一部分空间提供并发收集时，用户程序运行。JDK1.6 中，CMS 启动阈值为 92%. 若预留内存不够用户使用，则出现一次<code>Concurent Mode Failure</code>失败。这时虚拟机启动后备预案，临时启用 Serial Old 收集老年代，这样停顿时间很长。</p>
</li>
<li><p>CMS 基于”标记-清除“算法实现的，则会产生大量空间碎片，空间碎片过多时，没有连续空间分配给大对象，不得不提前触发一次 FUll GC。当然可以开启-XX:+UseCMSCompactAtFullCollection(默认开)，在 CMS 顶不住要 FullGC 时开启内存碎片合并整理过程。内存整理过程是无法并发的，空间碎片问题没了，但停顿时间变长。</p>
</li>
</ol>
<p><strong>面试题：CMS 一共会有几次 STW</strong></p>
<p>首先，回答两次，初始标记和重新标记需要。</p>
<p>然后，CMS 并发的代价是预留空间给用户，预留不足的时候触发 FUllGC，这时 Serail Old 会 STW.</p>
<p>然后，CMS 是标记-清除算法，导致空间碎片，则没有连续空间分配大对象时，FUllGC, 而 FUllGC 会开始碎片整理， STW.</p>
<p>即 2 次或多次。</p>
<h2 id="4-CMS-什么时候-FUll-GC"><a href="#4-CMS-什么时候-FUll-GC" class="headerlink" title="4. CMS 什么时候 FUll GC"></a>4. CMS 什么时候 FUll GC</h2><p>除直接调用 System.gc 外，触发 Full GC 执行的情况有如下四种。</p>
<h3 id="4-1-旧生代空间不足"><a href="#4-1-旧生代空间不足" class="headerlink" title="4.1 旧生代空间不足"></a>4.1 旧生代空间不足</h3><p>旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行 Full GC 后空间仍然不足，则抛出如下错误： java.lang.OutOfMemoryError: Java heap space 为避免以上两种状况引起的 FullGC，调优时应尽量做到让对象在 Minor GC 阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。</p>
<h3 id="4-2-Permanet-Generation-空间满"><a href="#4-2-Permanet-Generation-空间满" class="headerlink" title="4.2 Permanet Generation 空间满"></a>4.2 Permanet Generation 空间满</h3><p>PermanetGeneration 中存放的为一些 class 的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation 可能会被占满，在未配置为采用 CMS GC 的情况下会执行 Full GC。如果经过 Full GC 仍然回收不了，那么 JVM 会抛出如下错误信息： java.lang.OutOfMemoryError: PermGen space 为避免 Perm Gen 占满造成 Full GC 现象，可采用的方法为增大 Perm Gen 空间或转为使用 CMS GC。</p>
<h3 id="4-3-CMS-GC-时出现-promotion-failed-和-concurrent-mode-failure"><a href="#4-3-CMS-GC-时出现-promotion-failed-和-concurrent-mode-failure" class="headerlink" title="4.3 CMS GC 时出现 promotion failed 和 concurrent mode failure"></a>4.3 CMS GC 时出现 promotion failed 和 concurrent mode failure</h3><p>对于采用 CMS 进行旧生代 GC 的程序而言，尤其要注意 GC 日志中是否有 promotion failed 和 concurrent mode failure 两种状况，当这两种状况出现时可能会触发 Full GC。 promotionfailed 是在进行 Minor GC 时，survivor space 放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；concurrent mode failure 是在执行 CMS GC 的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。 应对措施为：增大 survivorspace、旧生代空间或调低触发并发 GC 的比率，但在 JDK 5.0+、6.0+的版本中有可能会由于 JDK 的 bug29 导致 CMS 在 remark 完毕后很久才触发 sweeping 动作。对于这种状况，可通过设置-XX:CMSMaxAbortablePrecleanTime&#x3D;5（单位为 ms）来避免。</p>
<h3 id="4-4-统计得到的-Minor-GC-晋升到旧生代的平均大小大于旧生代的剩余空间"><a href="#4-4-统计得到的-Minor-GC-晋升到旧生代的平均大小大于旧生代的剩余空间" class="headerlink" title="4.4 统计得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间"></a>4.4 统计得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间</h3><p>这是一个较为复杂的触发情况，Hotspot 为了避免由于新生代对象晋升到旧生代导致旧生代空间不足的现象，在进行 Minor GC 时，做了一个判断，如果之前统计所得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间，那么就直接触发 Full GC。 例如程序第一次触发 MinorGC 后，有 6MB 的对象晋升到旧生代，那么当下一次 Minor GC 发生时，首先检查旧生代的剩余空间是否大于 6MB，如果小于 6MB，则执行 Full GC。 当新生代采用 PSGC 时，方式稍有不同，PS GC 是在 Minor GC 后也会检查，例如上面的例子中第一次 Minor GC 后，PS GC 会检查此时旧生代的剩余空间是否大于 6MB，如小于，则触发对旧生代的回收。 除了以上 4 种状况外，对于使用 RMI 来进行 RPC 或管理的 Sun JDK 应用而言，默认情况下会一小时执行一次 Full GC。可通过在启动时通过- java-Dsun.rmi.dgc.client.gcInterval&#x3D;3600000 来设置 Full GC 执行的间隔时间或通过-XX:+ DisableExplicitGC 来禁止 RMI 调用 System.gc。</p>
<h2 id="5-G1"><a href="#5-G1" class="headerlink" title="5. G1"></a>5. G1</h2><h3 id="5-1-什么是垃圾回收"><a href="#5-1-什么是垃圾回收" class="headerlink" title="5.1 什么是垃圾回收"></a>5.1 什么是垃圾回收</h3><p>首先，在了解 G1 之前，我们需要清楚的知道，垃圾回收是什么？简单的说垃圾回收就是回收内存中不再使用的对象。</p>
<p>垃圾回收的基本步骤</p>
<p>回收的步骤有 2 步：</p>
<ol>
<li><p>查找内存中不再使用的对象</p>
</li>
<li><p>释放这些对象占用的内存</p>
</li>
</ol>
<h4 id="5-1-1-查找内存中不再使用的对象"><a href="#5-1-1-查找内存中不再使用的对象" class="headerlink" title="5.1.1 查找内存中不再使用的对象"></a>5.1.1 查找内存中不再使用的对象</h4><p>那么问题来了，如何判断哪些对象不再被使用呢？我们也有 2 个方法：</p>
<p><strong>1. 引用计数法</strong> 引用计数法就是如果一个对象没有被任何引用指向，则可视之为垃圾。这种方法的缺点就是不能检测到环的存在。</p>
<p><strong>2. 根搜索算法</strong></p>
<p>根搜索算法的基本思路就是通过一系列名为”GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。</p>
<p>现在我们已经知道如何找出垃圾对象了，如何把这些对象清理掉呢？</p>
<h4 id="5-1-2-释放这些对象占用的内存"><a href="#5-1-2-释放这些对象占用的内存" class="headerlink" title="5.1.2 释放这些对象占用的内存"></a>5.1.2 释放这些对象占用的内存</h4><p>常见的方式有复制或者直接清理，但是直接清理会存在内存碎片，于是就会产生了清理再压缩的方式。</p>
<p>总得来说就产生了三种类型的回收算法。</p>
<ol>
<li><p>标记-复制</p>
</li>
<li><p>标记-清理</p>
</li>
<li><p>标记-整理</p>
</li>
</ol>
<p>基于分代的假设</p>
<p>由于对象的存活时间有长有短，所以对于存活时间长的对象，减少被 gc 的次数可以避免不必要的开销。这样我们就把内存分成新生代和老年代，新生代存放刚创建的和存活时间比较短的对象，老年代存放存活时间比较长的对象。这样每次仅仅清理年轻代，老年代仅在必要时时再做清理可以极大的提高 GC 效率，节省 GC 时间。</p>
<h3 id="5-2-Java-垃圾收集器的历史"><a href="#5-2-Java-垃圾收集器的历史" class="headerlink" title="5.2 Java 垃圾收集器的历史"></a>5.2 Java 垃圾收集器的历史</h3><p>第一阶段，Serial（串行）收集器</p>
<p>在 jdk1.3.1 之前，java 虚拟机仅仅能使用 Serial 收集器。 Serial 收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p>
<p>PS：开启 Serial 收集器的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:+<span class="title class_">UseSerialGC</span></span><br></pre></td></tr></table></figure>

<p>第二阶段，Parallel（并行）收集器</p>
<p>Parallel 收集器也称吞吐量收集器，相比 Serial 收集器，Parallel 最主要的优势在于使用多线程去完成垃圾清理工作，这样可以充分利用多核的特性，大幅降低 gc 时间。</p>
<p>PS:开启 Parallel 收集器的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:+<span class="title class_">UseParallelGC</span> -<span class="attr">XX</span>:+<span class="title class_">UseParallelOldGC</span></span><br></pre></td></tr></table></figure>

<p>第三阶段，CMS（并发）收集器</p>
<p>CMS 收集器在 Minor GC 时会暂停所有的应用线程，并以多线程的方式进行垃圾回收。在 Full GC 时不再暂停应用线程，而是使用若干个后台线程定期的对老年代空间进行扫描，及时回收其中不再使用的对象。</p>
<p>PS:开启 CMS 收集器的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:+<span class="title class_">UseParNewGC</span> -<span class="attr">XX</span>:+<span class="title class_">UseConcMarkSweepGC</span></span><br></pre></td></tr></table></figure>

<p>第四阶段，G1（并发）收集器</p>
<p>G1 收集器（或者垃圾优先收集器）的设计初衷是为了尽量缩短处理超大堆（大于 4GB）时产生的停顿。相对于 CMS 的优势而言是内存碎片的产生率大大降低。</p>
<p>PS:开启 G1 收集器的方式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:+<span class="title class_">UseG1GC</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-了解-G1"><a href="#5-3-了解-G1" class="headerlink" title="5.3 了解 G1"></a>5.3 了解 G1</h3><p>G1 的第一篇 paper（附录 1）发表于 2004 年，在 2012 年才在 jdk1.7u4 中可用。oracle 官方计划在 jdk9 中将 G1 变成默认的垃圾收集器，以替代 CMS。为何 oracle 要极力推荐 G1 呢，G1 有哪些优点</p>
<blockquote>
<p><strong>首先，G1 的设计原则就是简单可行的性能调优</strong></p>
</blockquote>
<p>开发人员仅仅需要声明以下参数即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:+<span class="title class_">UseG1GC</span> -<span class="title class_">Xmx32</span>g -<span class="attr">XX</span>:<span class="title class_">MaxGCPauseMillis</span>=<span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>其中-XX:+UseG1GC 为开启 G1 垃圾收集器，-Xmx32g 设计堆内存的最大内存为 32G，-XX:MaxGCPauseMillis&#x3D;200 设置 GC 的最大暂停时间为 200ms。如果我们需要调优，在内存大小一定的情况下，我们只需要修改最大暂停时间即可。</p>
<blockquote>
<p><strong>其次，G1 将新生代，老年代的物理空间划分取消了。</strong></p>
</blockquote>
<p>这样我们再也不用单独的空间对每个代进行设置了，不用担心每个代内存是否足够。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/j35vt7qwgi.png?imageView2/2/w/1620"></p>
<p>取而代之的是，G1 算法将堆划分为若干个区域（Region），它仍然属于分代收集器。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者 Survivor 空间。老年代也分成很多区域，G1 收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1 完成了堆的压缩（至少是部分堆的压缩），这样也就不会有 cms 内存碎片问题的存在了。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/kzcansuji9.png?imageView2/2/w/1620"></p>
<p>在 G1 中，还有一种特殊的区域，叫 Humongous 区域。 如果一个对象占用的空间超过了分区容量 50%以上，G1 收集器就认为这是一个巨型对象。这些巨型对象，默认直接会被分配在年老代，但是如果它是一个短期存在的巨型对象，就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放巨型对象。如果一个 H 区装不下一个巨型对象，那么 G1 会寻找连续的 H 分区来存储。为了能找到连续的 H 区，有时候不得不启动 Full GC。</p>
<blockquote>
<p>PS：在 java 8 中，持久代也移动到了普通的堆内存空间中，改为元空间。</p>
</blockquote>
<h3 id="5-4-对象分配策略"><a href="#5-4-对象分配策略" class="headerlink" title="5.4 对象分配策略"></a>5.4 对象分配策略</h3><p>说起大对象的分配，我们不得不谈谈对象的分配策略。它分为 3 个阶段：</p>
<ol>
<li><p>TLAB(Thread Local Allocation Buffer)线程本地分配缓冲区 </p>
</li>
<li><p>Eden 区中分配 </p>
</li>
<li><p>Humongous 区分配</p>
</li>
</ol>
<p>TLAB 为线程本地分配缓冲区，它的目的为了使对象尽可能快的分配出来。如果对象在一个共享的空间中分配，我们需要采用一些同步机制来管理这些空间内的空闲空间指针。在 Eden 空间中，每一个线程都有一个固定的分区用于分配对象，即一个 TLAB。分配对象时，线程之间不再需要进行任何的同步。</p>
<p>对 TLAB 空间中无法分配的对象，JVM 会尝试在 Eden 空间中进行分配。如果 Eden 空间无法容纳该对象，就只能在老年代中进行分配空间。</p>
<p>最后，G1 提供了两种 GC 模式，Young GC 和 Mixed GC，两种都是 Stop The World(STW)的。下面我们将分别介绍一下这 2 种模式。</p>
<h3 id="5-5-G1-Young-GC"><a href="#5-5-G1-Young-GC" class="headerlink" title="5.5 G1 Young GC"></a>5.5 G1 Young GC</h3><p>Young GC 主要是对 Eden 区进行 GC，它在 Eden 空间耗尽时会被触发。在这种情况下，Eden 空间的数据移动到 Survivor 空间中，如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到年老代空间。Survivor 区的数据移动到新的 Survivor 区中，也有部分数据晋升到老年代空间中。最终 Eden 空间的数据为空，GC 停止工作，应用线程继续执行。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/najmvjs2bo.png?imageView2/2/w/1620"></p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/qiff8jpo4w.png?imageView2/2/w/1620"></p>
<p>这时，我们需要考虑一个问题，如果仅仅 GC 新生代对象，我们如何找到所有的根对象呢？ 老年代的所有对象都是根么？那这样扫描下来会耗费大量的时间。于是，G1 引进了 RSet 的概念。它的全称是 Remembered Set，作用是跟踪指向某个 heap 区内的对象引用。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/grtkxwlouw.png?imageView2/2/w/1620"></p>
<p>在 CMS 中，也有 RSet 的概念，在老年代中有一块区域用来记录指向新生代的引用。这是一种 point-out，在进行 Young GC 时，扫描根时，仅仅需要扫描这一块区域，而不需要扫描整个老年代。</p>
<p>但在 G1 中，并没有使用 point-out，这是由于一个分区太小，分区数量太多，如果使用 point-out 的话，会造成大量的扫描浪费，有些根本不需要 GC 的分区引用也扫描了。于是 G1 中使用 point-in 来解决。point-in 的意思是哪些分区引用了当前分区中的对象。这样，仅仅将这些对象当做根来扫描就避免了无效的扫描。由于新生代有多个，那么我们需要在新生代之间记录引用吗？这是不必要的，原因在于每次 GC 时，所有新生代都会被扫描，所以只需要记录老年代到新生代之间的引用即可。</p>
<p>需要注意的是，如果引用的对象很多，赋值器需要对每个引用做处理，赋值器开销会很大，为了解决赋值器开销这个问题，在 G1 中又引入了另外一个概念，卡表（Card Table）。一个 Card Table 将一个分区在逻辑上划分为固定大小的连续区域，每个区域称之为卡。卡通常较小，介于 128 到 512 字节之间。Card Table 通常为字节数组，由 Card 的索引（即数组下标）来标识每个分区的空间地址。默认情况下，每个卡都未被引用。当一个地址空间被引用时，这个地址空间对应的数组索引的值被标记为”0″，即被标记为脏引用，此外 RSet 也将这个数组下标记录下来。一般情况下，这个 RSet 其实是一个 Hash Table，Key 是别的 Region 的起始地址，Value 是一个集合，里面的元素是 Card Table 的 Index。</p>
<p><strong>Young GC 阶段</strong>：</p>
<p><strong>阶段 1：根扫描</strong></p>
<p>静态和本地对象被扫描</p>
<p><strong>阶段 2：更新 RS</strong></p>
<p>处理 dirty card 队列更新 RS</p>
<p><strong>阶段 3：处理 RS</strong></p>
<p>检测从年轻代指向年老代的对象</p>
<p><strong>阶段 4：对象拷贝</strong></p>
<p>拷贝存活的对象到 survivor&#x2F;old 区域</p>
<p><strong>阶段 5：处理引用队列</strong></p>
<p>软引用，弱引用，虚引用处理</p>
<h3 id="5-6-G1-Mix-GC"><a href="#5-6-G1-Mix-GC" class="headerlink" title="5.6 G1 Mix GC"></a>5.6 G1 Mix GC</h3><p>Mix GC 不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。</p>
<p>它的 GC 步骤分 2 步：</p>
<ol>
<li>全局并发标记（global concurrent marking） </li>
<li>拷贝存活对象（evacuation）</li>
</ol>
<p>在进行 Mix GC 之前，会先进行 global concurrent marking（全局并发标记）。 global concurrent marking 的执行过程是怎样的呢？</p>
<p>在 G1 GC 中，它主要是为 Mixed GC 提供标记服务的，并不是一次 GC 过程的一个必须环节。global concurrent marking 的执行过程分为五个步骤：</p>
<p><strong>初始标记（initial mark，STW）</strong></p>
<p>在此阶段，G1 GC 对根进行标记。该阶段与常规的 (STW) 年轻代垃圾回收密切相关。</p>
<p><strong>根区域扫描（root region scan</strong></p>
<p>G1 GC 在初始标记的存活区扫描对老年代的引用，并标记被引用的对象。该阶段与应用程序（非 STW）同时运行，并且只有完成该阶段后，才能开始下一次 STW 年轻代垃圾回收。</p>
<p><strong>并发标记（Concurrent Marking）</strong></p>
<p>G1 GC 在整个堆中查找可访问的（存活的）对象。该阶段与应用程序同时运行，可以被 STW 年轻代垃圾回收中断</p>
<p><strong>最终标记（Remark，STW）</strong></p>
<p>该阶段是 STW 回收，帮助完成标记周期。G1 GC 清空 SATB 缓冲区，跟踪未被访问的存活对象，并执行引用处理。</p>
<p><strong>清除垃圾（Cleanup，STW）</strong></p>
<p>在这个最后阶段，G1 GC 执行统计和 RSet 净化的 STW 操作。在统计期间，G1 GC 会识别完全空闲的区域和可供进行混合垃圾回收的区域。清理阶段在将空白区域重置并返回到空闲列表时为部分并发。</p>
<h3 id="5-7-三色标记算法"><a href="#5-7-三色标记算法" class="headerlink" title="5.7 三色标记算法"></a>5.7 三色标记算法</h3><p>提到并发标记，我们不得不了解并发标记的三色标记算法。它是描述追踪式回收器的一种有用的方法，利用它可以推演回收器的正确性。 首先，我们将对象分成三种类型的。</p>
<p><strong>黑色</strong>:根对象，或者该对象与它的子对象都被扫描</p>
<p><strong>灰色</strong>:对象本身被扫描,但还没扫描完该对象中的子对象</p>
<p><strong>白色</strong>:未被扫描对象，扫描完成所有对象之后，最终为白色的为不可达对象，即垃圾对象</p>
<p>当 GC 开始扫描对象时，按照如下图步骤进行对象的扫描：</p>
<p>根对象被置为黑色，子对象被置为灰色。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/qvszq1nzz5.png?imageView2/2/w/1620"></p>
<p>继续由灰色遍历,将已扫描了子对象的对象置为黑色。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/lznf6mnuwq.png?imageView2/2/w/1620"></p>
<p>遍历了所有可达的对象后，所有可达的对象都变成了黑色。不可达的对象即为白色，需要被清理。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/xcpdde793f.png?imageView2/2/w/1620"></p>
<p>这看起来很美好，但是如果在标记过程中，应用程序也在运行，那么对象的指针就有可能改变。这样的话，我们就会遇到一个问题：对象丢失问题</p>
<p>我们看下面一种情况，当垃圾收集器扫描到下面情况时:</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/tl5fv2etzj.png?imageView2/2/w/1620"></p>
<p>这时候应用程序执行了以下操作：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A.<span class="property">c</span>=C</span><br><span class="line">B.<span class="property">c</span>=<span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>这样，对象的状态图变成如下情形：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/lr6rhgj9mb.png?imageView2/2/w/1620"></p>
<p>这时候垃圾收集器再标记扫描的时候就会下图成这样：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/zg5z5sqq3u.png?imageView2/2/w/1620"></p>
<p>很显然，此时 C 是白色，被认为是垃圾需要清理掉，显然这是不合理的。那么我们如何保证应用程序在运行的时候，GC 标记的对象不丢失呢？有如下 2 种可行的方式：</p>
<ol>
<li><p>在插入的时候记录对象 </p>
</li>
<li><p>在删除的时候记录对象</p>
</li>
</ol>
<p>刚好这对应 CMS 和 G1 的 2 种不同实现方式：</p>
<p>在 CMS 采用的是增量更新（Incremental update），只要在写屏障（write barrier）里发现要有一个白对象的引用被赋值到一个黑对象 的字段里，那就把这个白对象变成灰色的。即插入的时候记录下来。</p>
<p>在 G1 中，使用的是 STAB（snapshot-at-the-beginning）的方式，删除的时候记录所有的对象，它有 3 个步骤：</p>
<ol>
<li><p>在开始标记的时候生成一个快照图标记存活对象</p>
</li>
<li><p>在并发标记的时候所有被改变的对象入队（在 write barrier 里把所有旧的引用所指向的对象都变成非白的）</p>
</li>
<li><p>可能存在游离的垃圾，将在下次被收集</p>
</li>
</ol>
<p>这样，G1 到现在可以知道哪些老的分区可回收垃圾最多。 当全局并发标记完成后，在某个时刻，就开始了 Mix GC。这些垃圾回收被称作“混合式”是因为他们不仅仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的分区。混合式垃圾收集如下图：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/9w87xbwbzh.png?imageView2/2/w/1620"></p>
<p>混合式 GC 也是采用的复制的清理策略，当 GC 完成后，会重新释放空间。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-1158094/5bg5mjl9ku.png?imageView2/2/w/1620"></p>
<h3 id="5-8-调优实践"><a href="#5-8-调优实践" class="headerlink" title="5.8 调优实践"></a>5.8 调优实践</h3><p><strong>MaxGCPauseMillis</strong>调优</p>
<p>前面介绍过使用 GC 的最基本的参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:+<span class="title class_">UseG1GC</span> -<span class="title class_">Xmx32</span>g -<span class="attr">XX</span>:<span class="title class_">MaxGCPauseMillis</span>=<span class="number">200</span></span><br></pre></td></tr></table></figure>

<p>前面 2 个参数都好理解，后面这个 MaxGCPauseMillis 参数该怎么配置呢？这个参数从字面的意思上看，就是允许的 GC 最大的暂停时间。G1 尽量确保每次 GC 暂停的时间都在设置的 MaxGCPauseMillis 范围内。 那 G1 是如何做到最大暂停时间的呢？这涉及到另一个概念，CSet(collection set)。它的意思是在一次垃圾收集器中被收集的区域集合。</p>
<p>Young GC：选定所有新生代里的 region。通过控制新生代的 region 个数来控制 young GC 的开销。</p>
<p>Mixed GC：选定所有新生代里的 region，外加根据 global concurrent marking 统计得出收集收益高的若干老年代 region。在用户指定的开销目标范围内尽可能选择收益高的老年代 region。</p>
<p>在理解了这些后，我们再设置最大暂停时间就好办了。 首先，我们能容忍的最大暂停时间是有一个限度的，我们需要在这个限度范围内设置。但是应该设置的值是多少呢？我们需要在吞吐量跟 MaxGCPauseMillis 之间做一个平衡。如果 MaxGCPauseMillis 设置的过小，那么 GC 就会频繁，吞吐量就会下降。如果 MaxGCPauseMillis 设置的过大，应用程序暂停时间就会变长。G1 的默认暂停时间是 200 毫秒，我们可以从这里入手，调整合适的时间。</p>
<p><strong>其他调优参数</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:G1HeapRegionSize=n</span><br></pre></td></tr></table></figure>

<p>设置的 G1 区域的大小。值是 2 的幂，范围是 1 MB 到 32 MB 之间。目标是根据最小的 Java 堆大小划分出约 2048 个区域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:<span class="title class_">ParallelGCThreads</span>=n</span><br></pre></td></tr></table></figure>

<p>设置 STW 工作线程数的值。将 n 的值设置为逻辑处理器的数量。n 的值与逻辑处理器的数量相同，最多为 8。</p>
<p>如果逻辑处理器不止八个，则将 n 的值设置为逻辑处理器数的 5&#x2F;8 左右。这适用于大多数情况，除非是较大的 SPARC 系统，其中 n 的值可以是逻辑处理器数的 5&#x2F;16 左右。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:<span class="title class_">ConcGCThreads</span>=n</span><br></pre></td></tr></table></figure>

<p>设置并行标记的线程数。将 n 设置为并行垃圾回收线程数 (ParallelGCThreads) 的 1&#x2F;4 左右。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-<span class="attr">XX</span>:<span class="title class_">InitiatingHeapOccupancyPercent</span>=<span class="number">45</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置触发标记周期的 Java 堆占用率阈值。默认占用率是整个 Java 堆的 45%。</p>
<p>避免使用以下参数：</p>
<p>避免使用 -Xmn 选项或 -XX:NewRatio 等其他相关选项显式设置年轻代大小。固定年轻代的大小会覆盖暂停时间目标。</p>
<h3 id="5-9-触发-Full-GC"><a href="#5-9-触发-Full-GC" class="headerlink" title="5.9 触发 Full GC"></a>5.9 触发 Full GC</h3><p>在某些情况下，G1 触发了 Full GC，这时 G1 会退化使用 Serial 收集器来完成垃圾的清理工作，它仅仅使用单线程来完成 GC 工作，GC 暂停时间将达到秒级别的。整个应用处于假死状态，不能处理任何请求，我们的程序当然不希望看到这些。那么发生 Full GC 的情况有哪些呢？</p>
<h4 id="5-9-1-并发模式失败"><a href="#5-9-1-并发模式失败" class="headerlink" title="5.9.1 并发模式失败"></a>5.9.1 并发模式失败</h4><p>G1 启动标记周期，但在 Mix GC 之前，老年代就被填满，这时候 G1 会放弃标记周期。这种情形下，需要增加堆大小，或者调整周期（例如增加线程数-XX:ConcGCThreads 等）。</p>
<h4 id="5-9-2-晋升失败或者疏散失败"><a href="#5-9-2-晋升失败或者疏散失败" class="headerlink" title="5.9.2 晋升失败或者疏散失败"></a>5.9.2 晋升失败或者疏散失败</h4><p>G1 在进行 GC 的时候没有足够的内存供存活对象或晋升对象使用，由此触发了 Full GC。可以在日志中看到(to-space exhausted)或者（to-space overflow）。解决这种问题的方式是：</p>
<p>a. 增加 <code>-XX:G1ReservePercent</code> 选项的值（并相应增加总的堆大小），为“目标空间”增加预留内存量。</p>
<p>b. 通过减少<code>-XX:InitiatingHeapOccupancyPercent</code> 提前启动标记周期。</p>
<p>c. 也可以通过增加 <code>-XX:ConcGCThreads</code> 选项的值来增加并行标记线程的数目。</p>
<h4 id="5-9-3-巨型对象分配失败"><a href="#5-9-3-巨型对象分配失败" class="headerlink" title="5.9.3 巨型对象分配失败"></a>5.9.3 巨型对象分配失败</h4><p>当巨型对象找不到合适的空间进行分配时，就会启动 Full GC，来释放空间。这种情况下，应该避免分配大量的巨型对象，增加内存或者增大-XX:G1HeapRegionSize，使巨型对象不再是巨型对象。</p>
<h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6. 参考"></a>6. 参考</h2><ul>
<li>转载 深入理解 JVM 虚拟机 第三章</li>
<li>转载 <a target="_blank" rel="noopener" href="http://blog.jobbole.com/109170/">《深入理解 Java G1 垃圾收集器》</a></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/jvm/" rel="tag">jvm</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-浅谈CLOSE-WAIT"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/19/%E6%B5%85%E8%B0%88CLOSE-WAIT/"
    >浅谈CLOSE_WAIT</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/19/%E6%B5%85%E8%B0%88CLOSE-WAIT/" class="article-date">
  <time datetime="2019-11-19T14:57:53.000Z" itemprop="datePublished">2019-11-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.huoding.com/" title="火丁笔记">火丁笔记</a></p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://blog.huoding.com/2016/01/19/488">https://blog.huoding.com/2016/01/19/488</a></p>
<p>总结：</p>
<ol>
<li><p>CLOSE_WAIT：被动关闭的一方响应 ACK 包后进入的等待关闭状态，直到被动关闭的一方发出 FIN 包后结束。</p>
</li>
<li><p>出现大量的 CLOSE_WAIT 状态的原因：</p>
<ul>
<li><p>程序问题</p>
</li>
<li><p>响应太慢或者超时设置过小</p>
</li>
<li><p>BACKLOG 太大</p>
</li>
</ul>
</li>
</ol>
</blockquote>
<p>TCP 有很多连接状态，每一个都够聊十块钱儿的，比如我们以前讨论过 <a target="_blank" rel="noopener" href="https://blog.huoding.com/2013/12/31/316" title="TIME_WAIT">TIME_WAIT</a> 和 <a target="_blank" rel="noopener" href="https://blog.huoding.com/2014/11/06/383" title="FIN_WAIT1">FIN_WAIT1</a>，最近时不时听人提起 CLOSE_WAIT，感觉有必要梳理一下。</p>
<p>所谓 CLOSE_WAIT，借用某位大牛的话来说应该倒过来叫做 WAIT_CLOSE，也就是说「等待关闭」，如果你还不理解其含义，可以看看 TCP 关闭连接时的图例：</p>
<p><img src="https://blog.huoding.com/wp-content/uploads/2013/12/tcp_close.png" alt="TCP Close" title="![TCP Close"></p>
<p>不要被图中的 client 和 server 所迷惑，你只要记住：主动关闭的一方发出 FIN 包，被动关闭的一方响应 ACK 包，此时，被动关闭的一方就进入了 CLOSE_WAIT 状态。如果一切正常，稍后被动关闭的一方也会发出 FIN 包，然后迁移到 LAST_ACK 状态。</p>
<p>通常，CLOSE_WAIT 状态在服务器停留时间很短，如果你发现大量的 CLOSE_WAIT 状态，那么就意味着被动关闭的一方没有及时发出 FIN 包，一般有如下几种可能：</p>
<ul>
<li>程序问题：如果代码层面忘记了 close 相应的 socket 连接，那么自然不会发出 FIN 包，从而导致 CLOSE_WAIT 累积；或者代码不严谨，出现死循环之类的问题，导致即便后面写了 close 也永远执行不到。</li>
<li>响应太慢或者超时设置过小：如果连接双方不和谐，一方不耐烦直接 timeout，另一方却还在忙于耗时逻辑，就会导致 close 被延后。响应太慢是首要问题，不过换个角度看，也可能是 timeout 设置过小。</li>
<li>BACKLOG 太大：此处的 backlog 不是 syn backlog，而是 accept 的 backlog，如果 backlog 太大的话，设想突然遭遇大访问量的话，即便响应速度不慢，也可能出现来不及消费的情况，导致多余的请求还在<a target="_blank" rel="noopener" href="http://jaseywang.me/2014/07/20/tcp-queue-%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/" title="队列">队列</a>里就被对方关闭了。</li>
</ul>
<p>如果你通过「netstat -ant」或者「ss -ant」命令发现了很多 CLOSE_WAIT 连接，请注意结果中的「Recv-Q」和「Local Address」字段，通常「Recv-Q」会不为空，它表示应用还没来得及接收数据，而「Local Address」表示哪个地址和端口有问题，我们可以通过「lsof -i:<PORT>」来确认端口对应运行的是什么程序以及它的进程号是多少。</p>
<p>如果是我们自己写的一些程序，比如用 HttpClient 自定义的蜘蛛，那么八九不离十是程序问题，如果是一些使用广泛的程序，比如 Tomcat 之类的，那么更可能是响应速度太慢或者 timeout 设置太小或者 BACKLOG 设置过大导致的故障。</p>
<p>此外还有一点需要说明：按照前面图例所示，当被动关闭的一方处于 CLOSE_WAIT 状态时，主动关闭的一方处于 FIN_WAIT2 状态。 那么为什么我们总听说 CLOSE_WAIT 状态过多的故障，但是却相对少听说 FIN_WAIT2 状态过多的故障呢？这是因为 Linux 有一个「tcp_fin_timeout」设置，控制了 FIN_WAIT2 的最大生命周期。坏消息是 CLOSE_WAIT 没有类似的设置，如果不重启进程，那么 CLOSE_WAIT 状态很可能会永远持续下去；好消息是如果 socket 开启了 <a target="_blank" rel="noopener" href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" title="keepalive">keepalive</a> 机制，那么可以通过相应的设置来清理无效连接，不过 keepalive 是治标不治本的方法，还是应该找到问题的症结才对。</p>
<p>本来想多写点的，但是着急回家，就写到这吧，推荐两个案例：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5NzUwNDA5MA==&mid=200667929&idx=1&sn=67cada895ac100115fded319b6b23a21&3rd=MzA3MDU4NTYzMw==&scene=6#rd">PHP 升级导致系统负载过高问题分析</a></li>
<li><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402163560&idx=1&sn=5269044286ce1d142cca1b5fed3efab1&3rd=MzA3MDU4NTYzMw==&scene=6#rd">又见 CLOSE_WAIT</a></li>
</ul>
<p>写得都比我好，建议大家仔细阅读。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-再叙TIME-WAIT"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/19/%E5%86%8D%E5%8F%99TIME-WAIT/"
    >再叙TIME_WAIT</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/19/%E5%86%8D%E5%8F%99TIME-WAIT/" class="article-date">
  <time datetime="2019-11-19T05:01:32.000Z" itemprop="datePublished">2019-11-19</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>作者：<a target="_blank" rel="noopener" href="https://blog.huoding.com/" title="火丁笔记">火丁笔记</a></p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://blog.huoding.com/2013/12/31/316">https://blog.huoding.com/2013/12/31/316</a></p>
<p>总结：</p>
<ol>
<li><p>为什么会存在 TIME_WAIT？</p>
<p>主动关闭的一方收到被动关闭的一方发出的 FIN 包后，回应 ACK 包，同时进入 TIME_WAIT 状态，但是因为网络原因，主动关闭的一方发送的这个 ACK 包很可能延迟，从而触发被动连接一方重传 FIN 包。极端情况下，这一去一回，就是两倍的 MSL 时长。如果主动关闭的一方跳过 TIME_WAIT 直接进入 CLOSED，或者在 TIME_WAIT 停留的时长不足两倍的 MSL，那么当被动关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：</p>
<ul>
<li><p>旧的 TCP 连接已经不存在了，系统此时只能返回 RST 包</p>
</li>
<li><p>新的 TCP 连接被建立起来了，延迟包可能干扰新的连接</p>
</li>
</ul>
</li>
<li><p>如何控制 TIME_WAIT 的数量？</p>
<ul>
<li><strong>ip_conntrack</strong>：顾名思义就是跟踪连接，不建议使用。</li>
<li><strong>tcp_tw_recycle</strong>：回收 TIME_WAIT 连接</li>
<li><strong>tcp_tw_reuse</strong>：顾名思义就是复用 TIME_WAIT 连接。既然我们要复用连接，那么当然应该在连接的发起方使用，而不能在被连接方使用。</li>
<li><strong>tcp_max_tw_buckets</strong>：顾名思义就是控制 TIME_WAIT 总数。</li>
<li>如果客户端可控的话，那么在服务端打开 <a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/HTTP_persistent_connection" title="KeepAlive">KeepAlive</a>，尽可能不让服务端主动关闭连接，而让客户端主动关闭连接，如此一来问题便迎刃而解了。</li>
</ul>
</li>
</ol>
</blockquote>
<p>之所以起这样一个题目是因为很久以前我曾经写过一篇介绍 TIME_WAIT 的<a target="_blank" rel="noopener" href="https://blog.huoding.com/2012/01/19/142" title="文章">文章</a>，不过当时基本属于浅尝辄止，并没深入说明问题的来龙去脉，碰巧这段时间反复被别人问到相关的问题，让我觉得有必要全面总结一下，以备不时之需。</p>
<p>讨论前大家可以拿手头的服务器摸摸底，记住「ss」比「netstat」快：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; ss -ant | awk <span class="string">&#x27;</span></span><br><span class="line"><span class="string">    NR&gt;1 &#123;++s[$1]&#125; END &#123;for(k in s) print k,s[k]&#125;</span></span><br><span class="line"><span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>如果你只是想单独查询一下 TIME_WAIT 的数量，那么还可以更简单一些：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; <span class="built_in">cat</span> /proc/net/sockstat</span><br></pre></td></tr></table></figure>

<p>我猜你一定被巨大无比的 TIME_WAIT 网络连接总数吓到了！以我个人的经验，对于一台繁忙的 Web 服务器来说，如果主要以短连接为主，那么其 TIME_WAIT 网络连接总数很可能会达到几万，甚至十几万。虽然一个 TIME_WAIT 网络连接耗费的资源无非就是一个端口、一点内存，但是架不住基数大，所以这始终是一个需要面对的问题。</p>
<h2 id="1-为什么会存在-TIME-WAIT？"><a href="#1-为什么会存在-TIME-WAIT？" class="headerlink" title="1. 为什么会存在 TIME_WAIT？"></a>1. 为什么会存在 TIME_WAIT？</h2><p>TCP 在建立连接的时候需要握手，同理，在关闭连接的时候也需要握手。为了更直观的说明关闭连接时握手的过程，我们引用「<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/index.htm" title="The TCP/IP Guide">The TCP&#x2F;IP Guide</a>」中的<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPConnectionTermination.htm" title="例子">例子</a>：</p>
<p>[<img src="https://blog.huoding.com/wp-content/uploads/2013/12/tcp_close.png" alt="TCP Close" title="![TCP Close">](<a target="_blank" rel="noopener" href="https://blog.huoding.com/wp-content/uploads/2013/12/tcp_close.png">https://blog.huoding.com/wp-content/uploads/2013/12/tcp_close.png</a>)</p>
<p>TCP Close</p>
<p>因为 TCP 连接是双向的，所以在关闭连接的时候，两个方向各自都需要关闭。先发 FIN 包的一方执行的是主动关闭；后发 FIN 包的一方执行的是被动关闭。主动关闭的一方会进入 TIME_WAIT 状态，并且在此状态停留两倍的<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Maximum_Segment_Lifetime" title="MSL">MSL</a>时长。</p>
<p>穿插一点 MSL 的知识：MSL 指的是报文段的最大生存时间，如果报文段在网络活动了 MSL 时间，还没有被接收，那么会被丢弃。关于 MSL 的大小，<a target="_blank" rel="noopener" href="http://tools.ietf.org/search/rfc793" title="RFC 793">RFC 793</a>协议中给出的建议是两分钟，不过实际上不同的操作系统可能有不同的设置，以 Linux 为例，通常是半分钟，两倍的 MSL 就是一分钟，也就是 60 秒，并且这个数值是硬编码在<a target="_blank" rel="noopener" href="https://github.com/torvalds/linux/blob/master/include/net/tcp.h" title="内核">内核</a>中的，也就是说除非你重新编译内核，否则没法修改它：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define TCP_TIMEWAIT_LEN (60*HZ)</span></span><br></pre></td></tr></table></figure>

<p>如果每秒的连接数是一千的话，那么一分钟就可能会产生六万个 TIME_WAIT。</p>
<p>为什么主动关闭的一方不直接进入 CLOSED 状态，而是进入 TIME_WAIT 状态，并且停留两倍的 MSL 时长呢？这是因为 TCP 是建立在不可靠网络上的可靠的协议。例子：主动关闭的一方收到被动关闭的一方发出的 FIN 包后，回应 ACK 包，同时进入 TIME_WAIT 状态，但是因为网络原因，主动关闭的一方发送的这个 ACK 包很可能延迟，从而触发被动连接一方重传 FIN 包。极端情况下，这一去一回，就是两倍的 MSL 时长。如果主动关闭的一方跳过 TIME_WAIT 直接进入 CLOSED，或者在 TIME_WAIT 停留的时长不足两倍的 MSL，那么当被动关闭的一方早先发出的延迟包到达后，就可能出现类似下面的问题：</p>
<ul>
<li>旧的 TCP 连接已经不存在了，系统此时只能返回 RST 包</li>
<li>新的 TCP 连接被建立起来了，延迟包可能干扰新的连接</li>
</ul>
<p>不管是哪种情况都会让 TCP 不再可靠，所以 TIME_WAIT 状态有存在的必要性。</p>
<h2 id="2-如何控制-TIME-WAIT-的数量？"><a href="#2-如何控制-TIME-WAIT-的数量？" class="headerlink" title="2. 如何控制 TIME_WAIT 的数量？"></a>2. 如何控制 TIME_WAIT 的数量？</h2><p>从前面的描述我们可以得出这样的结论：TIME_WAIT 这东西没有的话不行，不过太多可能也是个麻烦事。下面让我们看看有哪些方法可以控制 TIME_WAIT 数量，这里只说一些常规方法，另外一些诸如 SO_LINGER 之类的方法太过偏门，略过不谈。</p>
<p><strong>ip_conntrack</strong>：顾名思义就是跟踪连接。一旦激活了此模块，就能在系统参数里发现很多用来控制网络连接状态超时的设置，其中自然也包括 TIME_WAIT：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shell&gt; modprobe ip_conntrack</span><br><span class="line">shell&gt; sysctl net.ipv4.netfilter.ip_conntrack_tcp_timeout_time_wait</span><br></pre></td></tr></table></figure>

<p>我们可以尝试缩小它的设置，比如十秒，甚至一秒，具体设置成多少合适取决于网络情况而定，当然也可以参考相关的<a target="_blank" rel="noopener" href="http://blog.engineyard.com/2012/linux-scalability" title="案例">案例</a>。不过就我的个人意见来说，ip_conntrack 引入的问题比解决的还多，比如性能会大幅下降，所以不建议使用。</p>
<p><strong>tcp_tw_recycle</strong>：顾名思义就是回收 TIME_WAIT 连接。可以说这个内核参数已经变成了大众处理 TIME_WAIT 的万金油，如果你在网络上搜索 TIME_WAIT 的解决方案，十有八九会推荐设置它，不过这里隐藏着一个不易察觉的<a target="_blank" rel="noopener" href="http://www.litrin.net/2013/03/01/android%E4%B9%8B%E7%BD%91%E7%BB%9C%E4%B8%A2%E5%8C%85%E4%BA%8B%E4%BB%B6/" title="陷阱">陷阱</a>：</p>
<p>当多个客户端通过 NAT 方式联网并与服务端交互时，服务端看到的是同一个 IP，也就是说对服务端而言这些客户端实际上等同于一个，可惜由于这些客户端的时间戳可能存在差异，于是乎从服务端的视角看，便可能出现时间戳错乱的现象，进而直接导致时间戳小的数据包被丢弃。参考：<a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_781b0c850100znjd.html" title="tcp_tw_recycle和tcp_timestamps导致connect失败问题">tcp_tw_recycle 和 tcp_timestamps 导致 connect 失败问题</a>。</p>
<p><strong>tcp_tw_reuse</strong>：顾名思义就是复用 TIME_WAIT 连接。当创建新连接的时候，如果可能的话会考虑复用相应的 TIME_WAIT 连接。通常认为「tcp_tw_reuse」比「tcp_tw_recycle」安全一些，这是因为一来 TIME_WAIT 创建时间必须超过一秒才可能会被复用；二来只有连接的时间戳是递增的时候才会被复用。<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" title="官方文档">官方文档</a>里是这样说的：如果从协议视角看它是安全的，那么就可以使用。这简直就是外交辞令啊！按我的看法，如果网络比较稳定，比如都是内网连接，那么就可以尝试使用。</p>
<p>不过需要注意的是在哪里使用，既然我们要复用连接，那么当然应该在连接的发起方使用，而不能在被连接方使用。举例来说：客户端向服务端发起 HTTP 请求，服务端响应后主动关闭连接，于是 TIME_WAIT 便留在了服务端，此类情况使用「tcp_tw_reuse」是无效的，因为服务端是被连接方，所以不存在复用连接一说。让我们延伸一点来看，比如说服务端是 PHP，它查询另一个 MySQL 服务端，然后主动断开连接，于是 TIME_WAIT 就落在了 PHP 一侧，此类情况下使用「tcp_tw_reuse」是有效的，因为此时 PHP 相对于 MySQL 而言是客户端，它是连接的发起方，所以可以复用连接。</p>
<p>说明：如果使用 tcp_tw_reuse，请激活 tcp_timestamps，否则无效。</p>
<p><strong>tcp_max_tw_buckets</strong>：顾名思义就是控制 TIME_WAIT 总数。<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt" title="官网文档">官网文档</a>说这个选项只是为了阻止一些简单的 DoS 攻击，平常不要人为的降低它。如果缩小了它，那么系统会将多余的 TIME_WAIT 删除掉，日志里会显示：「TCP: time wait bucket table overflow」。</p>
<p>需要提醒大家的是物极必反，曾经看到有人把「tcp_max_tw_buckets」设置成 0，也就是说完全抛弃 TIME_WAIT，这就有些冒险了，用一句围棋谚语来说：入界宜缓。</p>
<p>…</p>
<p>有时候，如果我们换个角度去看问题，往往能得到四两拨千斤的效果。前面提到的例子：客户端向服务端发起 HTTP 请求，服务端响应后主动关闭连接，于是 TIME_WAIT 便留在了服务端。这里的关键在于主动关闭连接的是服务端！在关闭 TCP 连接的时候，先出手的一方注定逃不开 TIME_WAIT 的宿命，套用一句歌词：把我的悲伤留给自己，你的美丽让你带走。如果客户端可控的话，那么在服务端打开<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/HTTP_persistent_connection" title="KeepAlive">KeepAlive</a>，尽可能不让服务端主动关闭连接，而让客户端主动关闭连接，如此一来问题便迎刃而解了。</p>
<p>参考文档：</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/yunhua_lee/article/details/8146830" title="tcp短连接TIME_WAIT问题解决方法大全（1）——高屋建瓴">tcp 短连接 TIME_WAIT 问题解决方法大全（1）——高屋建瓴</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/yunhua_lee/article/details/8146837" title="tcp短连接TIME_WAIT问题解决方法大全（2）——SO_LINGER">tcp 短连接 TIME_WAIT 问题解决方法大全（2）——SO_LINGER</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/yunhua_lee/article/details/8146845" title="tcp短连接TIME_WAIT问题解决方法大全（3）——tcp_tw_recycle">tcp 短连接 TIME_WAIT 问题解决方法大全（3）——tcp_tw_recycle</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/yunhua_lee/article/details/8146856" title="tcp短连接TIME_WAIT问题解决方法大全（4）——tcp_tw_reuse">tcp 短连接 TIME_WAIT 问题解决方法大全（4）——tcp_tw_reuse</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/yunhua_lee/article/details/8146862" title="tcp短连接TIME_WAIT问题解决方法大全（5）——tcp_max_tw_buckets">tcp 短连接 TIME_WAIT 问题解决方法大全（5）——tcp_max_tw_buckets</a></li>
</ol>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-ARTS-9"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/17/ARTS-9/"
    >ARTS-9</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/17/ARTS-9/" class="article-date">
  <time datetime="2019-11-16T17:43:09.000Z" itemprop="datePublished">2019-11-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>ARTS是由左耳朵耗子陈皓在极客时间专栏《左耳听风》中发起的一个每周学习打卡计划。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Algorithm：至少做一个 LeetCode 的算法题。主要为了编程训练和学习。</span><br><span class="line"></span><br><span class="line">Review：阅读并点评至少一篇英文技术文章。主要为了学习英文，如果你英文不行，很难成为技术高手。</span><br><span class="line"></span><br><span class="line">Tip：学习至少一个技术技巧。主要是为了总结和归纳你日常工作中所遇到的知识点。</span><br><span class="line"></span><br><span class="line">Share：分享一篇有观点和思考的技术文章。主要为了输出你的影响力，能够输出你的价值观。</span><br></pre></td></tr></table></figure>

<h2 id="Algorithm-算法"><a href="#Algorithm-算法" class="headerlink" title="Algorithm(算法)"></a>Algorithm(算法)</h2><h3 id="Leetcode-26-将数组中的重复元素删除"><a href="#Leetcode-26-将数组中的重复元素删除" class="headerlink" title="Leetcode 26 将数组中的重复元素删除"></a>Leetcode 26 将数组中的重复元素删除</h3><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p>
<p><strong>思路</strong></p>
<p>使用快慢指针</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> a26_删除排序数组中的重复项;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> Gao Hang Hang</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2019-11-17 19:54</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeDuplicates</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                当我们遇到 nums[j] != nums[i] 时，跳过重复项的运行已经结束，</span></span><br><span class="line"><span class="comment">                因此我们必须把它（nums[j]）的值复制到 nums[i+1]。然后递增 i</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Review-点评"><a href="#Review-点评" class="headerlink" title="Review(点评)"></a>Review(点评)</h2><h2 id="Tip-技巧"><a href="#Tip-技巧" class="headerlink" title="Tip(技巧)"></a>Tip(技巧)</h2><blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32917699/article/details/81486060">https://blog.csdn.net/qq_32917699/article/details/81486060</a></p>
</blockquote>
<p>今天做了一天@ApiModel希望Swagger生成的文档出现返回的内容注释，发现需要用到@ApiModel注解到你需要返回的类上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@ApiModelProperty作为字段的描述</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191118205248.png"></p>
<p>之后文档还是不显示返回内容的注释，</p>
<p>原来是因为封装的返回类没做泛型 需要加入泛型</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191118205420.png"></p>
<p>封装的返回类加入泛型之后，还需要在你Controller返回的数据也加上泛型，不然还是展示不出来的</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191118205440.png"></p>
<p>这样，返回的数据就带上注释了</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img/20191118205456.png"></p>
<p>完美解决了返回内容不带注释的问题</p>
<h2 id="Share-分享"><a href="#Share-分享" class="headerlink" title="Share(分享)"></a>Share(分享)</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gaohanghang/p/12189004.html">Arrays.sort() VS Arrays.parallelSort()</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ARTS/" rel="tag">ARTS</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-TED-最强大的思考方式-第一性原则"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/17/TED-%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F-%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E5%88%99/"
    >TED 最强大的思考方式-第一性原则</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/17/TED-%E6%9C%80%E5%BC%BA%E5%A4%A7%E7%9A%84%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F-%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E5%88%99/" class="article-date">
  <time datetime="2019-11-16T16:27:16.000Z" itemprop="datePublished">2019-11-17</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>视频地址：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av75537322">https://www.bilibili.com/video/av75537322</a></p>
</blockquote>
<h2 id="1-什么是第一原理"><a href="#1-什么是第一原理" class="headerlink" title="1. 什么是第一原理"></a>1. 什么是第一原理</h2><blockquote>
<p>第一性原理，又称“第一原理”，是古希腊哲学家亚里士多德提出的一个哲学术语：每个系统中存在一个最基本的命题，它不能被违背或删除。亚里士多德认为，我们要掌握第一原理才能拥有正确知识。从第一原理思考的人，会从果实到树根，由表及里来理解知识，他们会把那些零散的知识，全都形成一个有条理的整体。</p>
</blockquote>
<p>亚里士多德认为所有事物都能分为类别和子类别，每个领域最小的子类别就是我们所说的第一原理</p>
<h2 id="2-第一原理的益处"><a href="#2-第一原理的益处" class="headerlink" title="2. 第一原理的益处"></a>2. 第一原理的益处</h2><ul>
<li>创新：改造它或以不同方式把它们结合形成新的知识</li>
<li>优化：思考或实体能通过改造以获得优化</li>
<li>融合：当你理解了知识的根本之后，把新知识融入你的知识系统，就简单多了</li>
<li>传播：有益于把复杂知识传递给别人</li>
</ul>
<h2 id="3-如何成为从第一原理思考的人呢？"><a href="#3-如何成为从第一原理思考的人呢？" class="headerlink" title="3. 如何成为从第一原理思考的人呢？"></a>3. 如何成为从第一原理思考的人呢？</h2><p>构建层次，了解零散的知识是如何相互联系的，Why 和 How，把你感兴趣的学科知识搜集起来，并像写文章那样，将各部分等级化，从而使知识具有系统性</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/TED/" rel="tag">TED</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Spring-Boot-中实现定时任务的两种方式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/16/Spring-Boot-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"
    >Spring Boot 中实现定时任务的两种方式</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/16/Spring-Boot-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2019-11-16T11:02:59.000Z" itemprop="datePublished">2019-11-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://www.javaboy.org/2019/0418/springboot-schedule-task.html">https://www.javaboy.org/2019/0418/springboot-schedule-task.html</a></p>
</blockquote>
<p>在 Spring + SpringMVC 环境中，一般来说，要实现定时任务，我们有两种方案，一种是使用 Spring 自带的定时任务处理器 @Scheduled 注解，另一种就是使用第三方框架 Quartz ，Spring Boot 源自 Spring+SpringMVC ，因此天然具备这两个 Spring 中的定时任务实现策略，当然也支持 Quartz，本文我们就来看下 Spring Boot 中两种定时任务的实现方式。</p>
<h2 id="1-Scheduled"><a href="#1-Scheduled" class="headerlink" title="1. @Scheduled"></a>1. @Scheduled</h2><p>使用 @Scheduled 非常容易，直接创建一个 Spring Boot 项目，并且添加 web 依赖 <code>spring-boot-starter-web</code>，项目创建成功后，添加 <code>@EnableScheduling</code> 注解，开启定时任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScheduledApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ScheduledApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来配置定时任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(fixedRate = 2000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedRate</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fixedRate&gt;&gt;&gt;&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scheduled(fixedDelay = 2000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fixedDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;fixedDelay&gt;&gt;&gt;&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Scheduled(initialDelay = 2000,fixedDelay = 2000)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initialDelay</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;initialDelay&gt;&gt;&gt;&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先使用 @Scheduled 注解开启一个定时任务。</li>
<li>fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。</li>
<li>fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。</li>
<li>initialDelay 表示首次任务启动的延迟时间。</li>
<li>所有时间的单位都是毫秒。</li>
</ol>
<p>上面这是一个基本用法，除了这几个基本属性之外，@Scheduled 注解也支持 cron 表达式，使用 cron 表达式，可以非常丰富的描述定时任务的时间。cron 表达式格式如下：</p>
<blockquote>
<p>[秒] [分] [小时] [日] [月] [周] [年]</p>
</blockquote>
<p>具体取值如下：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">说明</th>
<th align="left">是否必填</th>
<th align="left">允许填写的值</th>
<th align="left">允许的通配符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">秒</td>
<td align="left">是</td>
<td align="left">0-59</td>
<td align="left">- * &#x2F;</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">分</td>
<td align="left">是</td>
<td align="left">0-59</td>
<td align="left">- * &#x2F;</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">时</td>
<td align="left">是</td>
<td align="left">0-23</td>
<td align="left">- * &#x2F;</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">日</td>
<td align="left">是</td>
<td align="left">1-31</td>
<td align="left">- * ? &#x2F; L W</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">月</td>
<td align="left">是</td>
<td align="left">1-12 or JAN-DEC</td>
<td align="left">- * &#x2F;</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">周</td>
<td align="left">是</td>
<td align="left">1-7 or SUN-SAT</td>
<td align="left">- * ? &#x2F; L #</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">年</td>
<td align="left">否</td>
<td align="left">1970-2099</td>
<td align="left">- * &#x2F;</td>
</tr>
</tbody></table>
<p><strong>这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></strong></p>
<p><strong>通配符含义：</strong></p>
<ul>
<li><code>?</code> 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 <code>?</code></li>
<li><code>*</code> 表示所有值，例如:在秒的字段上设置 <code>*</code>,表示每一秒都会触发</li>
<li><code>,</code> 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发</li>
<li><code>-</code> 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发</li>
<li><code>/</code> 用于递增触发，如在秒上面设置”5&#x2F;15” 表示从5秒开始，每增15秒触发(5,20,35,50)</li>
<li><code>#</code> 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了)</li>
<li>周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同</li>
<li><code>L</code> 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五”</li>
<li><code>W</code> 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“)</li>
<li><code>L</code> 和 <code>W</code> 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )</li>
</ul>
<p>例如，在 @Scheduled 注解中来一个简单的 cron 表达式，每隔5秒触发一次，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled(cron = &quot;0/5 * * * * *&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cron</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面介绍的是使用 @Scheduled 注解的方式来实现定时任务，接下来我们再来看看如何使用 Quartz 实现定时任务。</p>
<h2 id="2-Quartz"><a href="#2-Quartz" class="headerlink" title="2. Quartz"></a>2. Quartz</h2><p>一般在项目中，除非定时任务涉及到的业务实在是太简单，使用 @Scheduled 注解来解决定时任务，否则大部分情况可能都是使用 Quartz 来做定时任务。在 Spring Boot 中使用 Quartz ，只需要在创建项目时，添加 Quartz 依赖即可：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/GvtDGKK4uYn4fichjPO6vdG7bdPv1m66BsxlrVP5ibahjnP7CBgmB7U7f63uKAoMbUOXba3hyw4JE4VsK0HNQcDQ/640?wx_fmt=png"></p>
<p>项目创建完成后，也需要添加开启定时任务的注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(QuartzApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Quartz 在使用过程中，有两个关键概念，一个是JobDetail（要做的事情），另一个是触发器（什么时候做），要定义 JobDetail，需要先定义 Job，Job 的定义有两种方式：</p>
<p>第一种方式，直接定义一个Bean：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MyJob1&gt;&gt;&gt;&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这种定义方式说两点：</p>
<ol>
<li>首先将这个 Job 注册到 Spring 容器中。</li>
<li>这种定义方式有一个缺陷，就是无法传参。</li>
</ol>
<p>第二种定义方式，则是继承 QuartzJobBean 并实现默认的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJob2</span> <span class="keyword">extends</span> <span class="title class_">QuartzJobBean</span> &#123;</span><br><span class="line">    HelloService helloService;</span><br><span class="line">    <span class="keyword">public</span> HelloService <span class="title function_">getHelloService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> helloService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHelloService</span><span class="params">(HelloService helloService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.helloService = helloService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException &#123;</span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello service &gt;&gt;&gt;&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和第1种方式相比，这种方式支持传参，任务启动时，executeInternal 方法将会被执行。</p>
<p>Job 有了之后，接下来创建类，配置 JobDetail 和 Trigger 触发器，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    MethodInvokingJobDetailFactoryBean <span class="title function_">methodInvokingJobDetailFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MethodInvokingJobDetailFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MethodInvokingJobDetailFactoryBean</span>();</span><br><span class="line">        bean.setTargetBeanName(<span class="string">&quot;myJob1&quot;</span>);</span><br><span class="line">        bean.setTargetMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    JobDetailFactoryBean <span class="title function_">jobDetailFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JobDetailFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobDetailFactoryBean</span>();</span><br><span class="line">        bean.setJobClass(MyJob2.class);</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JobDataMap</span>();</span><br><span class="line">        map.put(<span class="string">&quot;helloService&quot;</span>, helloService());</span><br><span class="line">        bean.setJobDataMap(map);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    SimpleTriggerFactoryBean <span class="title function_">simpleTriggerFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleTriggerFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleTriggerFactoryBean</span>();</span><br><span class="line">        bean.setStartTime(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        bean.setRepeatCount(<span class="number">5</span>);</span><br><span class="line">        bean.setJobDetail(methodInvokingJobDetailFactoryBean().getObject());</span><br><span class="line">        bean.setRepeatInterval(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    CronTriggerFactoryBean <span class="title function_">cronTrigger</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">CronTriggerFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CronTriggerFactoryBean</span>();</span><br><span class="line">        bean.setCronExpression(<span class="string">&quot;0/10 * * * * ?&quot;</span>);</span><br><span class="line">        bean.setJobDetail(jobDetailFactoryBean().getObject());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    SchedulerFactoryBean <span class="title function_">schedulerFactoryBean</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SchedulerFactoryBean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SchedulerFactoryBean</span>();</span><br><span class="line">        bean.setTriggers(cronTrigger().getObject(), simpleTriggerFactoryBean().getObject());</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    HelloService <span class="title function_">helloService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HelloService</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于这个配置说如下几点：</p>
<ol>
<li>JobDetail 的配置有两种方式：MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean 。</li>
<li>使用 MethodInvokingJobDetailFactoryBean 可以配置目标 Bean 的名字和目标方法的名字，这种方式不支持传参。</li>
<li>使用 JobDetailFactoryBean 可以配置 JobDetail ，任务类继承自 QuartzJobBean ，这种方式支持传参，将参数封装在 JobDataMap 中进行传递。</li>
<li>Trigger 是指触发器，Quartz 中定义了多个触发器，这里向大家展示其中两种的用法，SimpleTrigger 和 CronTrigger 。</li>
<li>SimpleTrigger 有点类似于前面说的 @Scheduled 的基本用法。</li>
<li>CronTrigger 则有点类似于 @Scheduled 中 cron 表达式的用法。</li>
</ol>
<p><img src="https://www.javaboy.org/images/boot/6-2.png"></p>
<p>全部定义完成后，启动 Spring Boot 项目就可以看到定时任务的执行了。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这里主要向大家展示了 Spring Boot 中整合两种定时任务的方法，整合成功之后，剩下的用法基本上就和在 SSM 中使用一致了，不再赘述。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-如何避免回表查询？什么是索引覆盖？"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/11/16/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%EF%BC%9F/"
    >如何避免回表查询？什么是索引覆盖？</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/11/16/%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E5%9B%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%EF%BC%9F/" class="article-date">
  <time datetime="2019-11-16T09:27:12.000Z" itemprop="datePublished">2019-11-16</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/y0pjtNUZhOW2ZBOy4m-xsA">https://mp.weixin.qq.com/s/y0pjtNUZhOW2ZBOy4m-xsA</a></p>
<p>参考文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/csdn_kou/article/details/87622921">mysql索引回表</a></p>
<p>真实面试题：<a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/342185?type=2&order=3&pos=2&page=1">https://www.nowcoder.com/discuss/342185?type=2&amp;order=3&amp;pos=2&amp;page=1</a></p>
<p>所谓的<strong>回表查询</strong>，就是先通过普通索引定位到主键值，再通过聚集索引定位到行记录，需要扫码两遍索引树，因此它的性能较扫一遍索引树更低。</p>
</blockquote>
<p>《<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962587&idx=1&sn=d197aea0090ce93b156e0774c6dc3019&chksm=bd2d09078a5a801138922fb5f2b9bb7fdaace7e594d55f45ce4b3fc25cbb973bbc9b2deb2c31&scene=21#wechat_redirect">迅猛定位低效 SQL？</a>》留了一个尾巴：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;shenjian&#x27;</span></span><br><span class="line"><span class="keyword">select</span> id,name,sex <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;shenjian&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>多查询了一个属性，为何检索过程完全不同？</strong></p>
<ul>
<li><p><strong>什么是回表查询？</strong></p>
</li>
<li><p><strong>什么是索引覆盖？</strong></p>
</li>
<li><p><strong>如何实现索引覆盖？</strong></p>
</li>
<li><p><strong>哪些场景，可以利用索引覆盖来优化 SQL？</strong></p>
</li>
</ul>
<p>这些，这是今天要分享的内容。</p>
<blockquote>
<p><em>画外音：本文试验基于 MySQL5.6-InnoDB。</em></p>
</blockquote>
<h2 id="一、什么是回表查询？"><a href="#一、什么是回表查询？" class="headerlink" title="一、什么是回表查询？"></a><strong>一、什么是回表查询？</strong></h2><p>这先要从 InnoDB 的索引实现说起，InnoDB 有两大类索引：</p>
<ul>
<li>聚集索引(clustered index)</li>
<li>普通索引(secondary index)</li>
</ul>
<p><strong>InnoDB 聚集索引和普通索引有什么差异？</strong></p>
<p>InnoDB<strong>聚集索引</strong>的叶子节点存储行记录，因此， InnoDB 必须要有，且只有一个聚集索引：</p>
<p>（1）如果表定义了 PK，则 PK 就是聚集索引；</p>
<p>（2）如果表没有定义 PK，则第一个 not NULL unique 列是聚集索引；</p>
<p>（3）否则，InnoDB 会创建一个隐藏的 row-id 作为聚集索引；</p>
<blockquote>
<p><em>画外音：所以 PK 查询非常快，直接定位行记录。</em></p>
</blockquote>
<p>InnoDB<strong>普通索引</strong>的叶子节点存储主键值。</p>
<blockquote>
<p><em>画外音：注意，不是存储行记录头指针，MyISAM 的索引叶子节点存储记录指针。</em></p>
</blockquote>
<p>举个栗子，不妨设有表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t(id PK, name KEY, sex, flag);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><em>画外音：id 是聚集索引，name 是普通索引。</em></p>
</blockquote>
<p>表中有四条记录：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, shenjian, m, A</span><br><span class="line"><span class="number">3</span>, zhangsan, m, A</span><br><span class="line"><span class="number">5</span>, lisi, m, A</span><br><span class="line"><span class="number">9</span>, wangwu, f, B</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65fmXwWV74giaiaVZBY9THnUP62l9XVyFGmn5LUg0jlGsxQjTR2ZtlxLUA/640?wx_fmt=png"></p>
<p>两个 B+树索引分别如上图：</p>
<p>（1）id 为 PK，聚集索引，叶子节点存储行记录；</p>
<p>（2）name 为 KEY，普通索引，叶子节点存储 PK 值，即 id；</p>
<p>既然从普通索引无法直接定位行记录，那<strong>普通索引的查询过程是怎么样的呢？</strong></p>
<p>通常情况下，需要扫码两遍索引树。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;lisi&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>是如何执行的呢？</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65ibf3L5PzLaut1zvV9G4rPr48iaOgONxm2bc1FI6AF8388xyfFTvtVbFQ/640?wx_fmt=png"></p>
<p>如<strong>粉红色</strong>路径，需要扫码两遍索引树：</p>
<p>（1）先通过普通索引定位到主键值 id&#x3D;5；</p>
<p>（2）再通过聚集索引定位到行记录；</p>
<p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p>
<h2 id="二、什么是索引覆盖-Covering-index-？"><a href="#二、什么是索引覆盖-Covering-index-？" class="headerlink" title="二、什么是索引覆盖(Covering index)？"></a>二、什么是索引覆盖(Covering index)？</h2><p>额，楼主并没有在 MySQL 的官网找到这个概念。</p>
<blockquote>
<p><em>画外音：治学严谨吧？</em></p>
</blockquote>
<p>借用一下 SQL-Server 官网的说法。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65C3V0ibOS4dgPzwJas0cic0pPx4rd8Yia0kXs4tyFR0EFqZ7wOSZWwh9og/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>MySQL 官网，类似的说法出现在 explain 查询计划优化章节，即 explain 的输出结果 Extra 字段为 Using index 时，能够触发索引覆盖。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65SflW8bYddCuYm8Khse589drcPzv12DpFuExXEt74icfCFicRCSTUicYgQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>不管是 SQL-Server 官网，还是 MySQL 官网，都表达了：只需要在一棵索引树上就能获取 SQL 所需的所有列数据，无需回表，速度更快。</p>
<h2 id="三、如何实现索引覆盖？"><a href="#三、如何实现索引覆盖？" class="headerlink" title="三、如何实现索引覆盖？"></a><strong>三、如何实现索引覆盖？</strong></h2><p>常见的方法是：将被查询的字段，建立到联合索引里去。</p>
<p>仍是《<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962587&idx=1&sn=d197aea0090ce93b156e0774c6dc3019&chksm=bd2d09078a5a801138922fb5f2b9bb7fdaace7e594d55f45ce4b3fc25cbb973bbc9b2deb2c31&scene=21#wechat_redirect">迅猛定位低效 SQL？</a>》中的例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">index(name)</span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure>

<p>第一个 SQL 语句：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65ZJib9mkHOSJf9l0GGZrIsSWrBzpO6YxSyictVRb7Zp0BRZvoF98jdgiaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;shenjian&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>能够命中 name 索引，索引叶子节点存储了主键 id，通过 name 的索引树即可获取 id 和 name，无需回表，符合索引覆盖，效率较高。</p>
<blockquote>
<p>画外音，Extra：<strong>Using index</strong>。</p>
</blockquote>
<p>第二个 SQL 语句：</p>
<p><em><img src="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65WEPlsUZmicxkpO09eMACwcIxLqHphsZJYBYibcE0qIwVya97pyyEw5Mw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></em></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,sex <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;shenjian&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>能够命中 name 索引，索引叶子节点存储了主键 id，但 sex 字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过 id 值扫码聚集索引获取 sex 字段，效率会降低。</p>
<blockquote>
<p>画外音，Extra：<strong>Using index condition</strong>。</p>
</blockquote>
<p>如果把(name)单列索引升级为联合索引(name, sex)就不同了。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">user</span> (</span><br><span class="line">id <span class="type">int</span> <span class="keyword">primary</span> key,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">sex <span class="type">varchar</span>(<span class="number">5</span>),</span><br><span class="line">index(name, sex)</span><br><span class="line">)engine<span class="operator">=</span>innodb;</span><br></pre></td></tr></table></figure>

<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65vZFPB2wYyia8zEOfpayx0n7iaTAOMgN6CcPJzO32WQ5cwn2jBAkayv2Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1"></p>
<p>可以看到：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name ... <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;shenjian&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> id,name,sex ... <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;shenjian&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>都能够命中索引覆盖，无需回表。</p>
<blockquote>
<p>画外音，Extra：<strong>Using index</strong>。</p>
</blockquote>
<h2 id="四、哪些场景可以利用索引覆盖来优化-SQL？"><a href="#四、哪些场景可以利用索引覆盖来优化-SQL？" class="headerlink" title="四、哪些场景可以利用索引覆盖来优化 SQL？"></a><strong>四、哪些场景可以利用索引覆盖来优化 SQL？</strong></h2><p><strong>场景 1：全表 count 查询优化</strong></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/YrezxckhYOzNBNFMUPN4LxzHibQqicac65oBp7Bs5CmfibaDLwVo81ucSMaGNVodCQ78PniatZvg08riamgaYNepibLQ/640?wx_fmt=png"></p>
<p>原表为：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">user</span>(PK id, name, sex);</span><br></pre></td></tr></table></figure>

<p>直接：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(name) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>

<p>不能利用索引覆盖。</p>
<p>添加索引：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="keyword">user</span> <span class="keyword">add</span> key(name);</span><br></pre></td></tr></table></figure>

<p>就能够利用索引覆盖提效。</p>
<p><strong>场景 2：列查询回表优化</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,sex ... <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;shenjian&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>这个例子不再赘述，将单列索引(name)升级为联合索引(name, sex)，即可避免回表。</p>
<p><strong>场景 3：分页查询</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id,name,sex ... <span class="keyword">order</span> <span class="keyword">by</span> name limit <span class="number">500</span>,<span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>将单列索引(name)升级为联合索引(name, sex)，也可以避免回表。</p>
<p><strong>InnoDB 聚集索引普通索引</strong>，<strong>回表</strong>，<strong>索引覆盖</strong>，希望这 1 分钟大家有收获。</p>
<p>提示，如果你不清楚 explain 结果 Extra 字段为 Using index 的含义，请阅读前序文章：《<a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962587&idx=1&sn=d197aea0090ce93b156e0774c6dc3019&chksm=bd2d09078a5a801138922fb5f2b9bb7fdaace7e594d55f45ce4b3fc25cbb973bbc9b2deb2c31&scene=21#wechat_redirect">如何利用工具，迅猛定位低效 SQL？</a>》</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/mysql/" rel="tag">mysql</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/7/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/9/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> 高行行
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="高行行的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://gaohanghang.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/twitter">Twitter</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://weibo.com/u/5125203090">微博</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>