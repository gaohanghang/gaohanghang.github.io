<!DOCTYPE html>


<html lang="zh-CN">
  

    <head>
      <meta charset="utf-8" />
        
      <meta name="description" content="个人公众号《骇客与画家》" />
      
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> 高行行的个人博客</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      
<link rel="stylesheet" href="/css/fonts/remixicon.css">

      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.staticfile.org/pace/1.2.4/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/Shen-Yu/hexo-theme-ayer"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">高行行的个人博客</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.staticfile.org/typed.js/2.0.12/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['面朝大海，春暖花开', '科技需要人文的浇灌', '想要的都拥有，得不到的都释怀'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a target="_blank" rel="noopener" href="https://curl.qcloud.com/kvO7hb43">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5ccc.jpg" width="300" alt="云服务器限时秒杀">
            </a>
        </li>
    
        <li>
            <a target="_blank" rel="noopener" href="https://www.vultr.com/?ref=8630075">
                <img src="https://pic.imgdb.cn/item/62174b452ab3f51d912a5cd7.png" width="300" alt="vultr优惠vps">
            </a>
        </li>
    
</ul>
  
  
  

<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content" id="broad"></div>
</div>
<script type="text/javascript">
    fetch('https://v1.hitokoto.cn')
        .then(response => response.json())
        .then(data => {
            document.getElementById("broad").innerHTML = data.hitokoto;
        })
        .catch(console.error)
</script>

<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-面向面试题学习-2-2019-6-3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/06/03/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E4%B9%A0-2-2019-6-3/"
    >面向面试题学习(2) 2019-6-3</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/06/03/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E4%B9%A0-2-2019-6-3/" class="article-date">
  <time datetime="2019-06-03T13:51:10.000Z" itemprop="datePublished">2019-06-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190603215304.png"></p>
<ol>
<li>大数相加</li>
<li>反转链表</li>
<li>生产者消费者模式</li>
<li>阻塞队列</li>
<li>死锁的SQL</li>
<li>group by having</li>
<li>网络tcp https</li>
<li>数据库索引优化</li>
<li>设计模式</li>
</ol>
<h2 id="1-大数相加"><a href="#1-大数相加" class="headerlink" title="1. 大数相加"></a>1. 大数相加</h2><h3 id="方法一：模拟进位"><a href="#方法一：模拟进位" class="headerlink" title="方法一：模拟进位"></a>方法一：模拟进位</h3><p><strong>算法</strong></p>
<p>每次处理最后两个字符数字，进行模拟进位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">addStrings</span><span class="params">(String num1, String num2)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num1.length() - <span class="number">1</span>, j = num2.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span> || j &gt;= <span class="number">0</span> || carry == <span class="number">1</span>; i--, j--)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> i &lt; <span class="number">0</span> ? <span class="number">0</span> : num1.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> j &lt; <span class="number">0</span> ? <span class="number">0</span> : num2.charAt(j) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            sb.append((x + y + carry) % <span class="number">10</span>);</span><br><span class="line">            carry = (x + y + carry) / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-反转链表"><a href="#2-反转链表" class="headerlink" title="2. 反转链表"></a>2. 反转链表</h2><blockquote>
<p>leetcode官方题解 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/">https://leetcode-cn.com/problems/reverse-linked-list/solution/fan-zhuan-lian-biao-by-leetcode/</a></p>
</blockquote>
<h4 id="方法一：迭代"><a href="#方法一：迭代" class="headerlink" title="方法一：迭代"></a>方法一：迭代</h4><p>假设存在链表 <code>1 → 2 → 3 → Ø</code>，我们想要把它改成 <code>Ø ← 1 ← 2 ← 3</code>。</p>
<p>在遍历列表时，将当前节点的 <code>next</code> 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nextTemp</span> <span class="operator">=</span> curr.next;</span><br><span class="line">        curr.next = prev;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = nextTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。</li>
<li>空间复杂度：O(1)。</li>
</ul> 
      <a class="article-more-link" href="/2019/06/03/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E4%B9%A0-2-2019-6-3/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E4%B9%A0/" rel="tag">面向面试题学习</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Spring-Boot应用程序五种部署方式"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/06/03/Spring-Boot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BA%94%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/"
    >Spring Boot应用程序五种部署方式（翻译）</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/06/03/Spring-Boot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%BA%94%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/" class="article-date">
  <time datetime="2019-06-03T10:08:19.000Z" itemprop="datePublished">2019-06-03</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>翻译自 <a target="_blank" rel="noopener" href="https://medium.com/swlh/deploying-spring-boot-applications-15e14db25ff0">Deploying Spring Boot Applications</a></p>
<p>原作者 <a target="_blank" rel="noopener" href="https://medium.com/@muratartim_5366">Murat Artim</a></p>
</blockquote>
<p>可以使用各种方法将Spring Boot应用程序部署到生产系统中。在本文中，我们将通过以下5种方法来部署Spring Boot应用程序：</p>
<ul>
<li>使用 Java Archive (JAR) 作为独立应用程序进行部署</li>
<li>将 Web Application Archive (WAR) 部署到servlet容器中</li>
<li>在Docker容器中部署</li>
<li>部署在NGINX Web服务器后面 - 直接设置</li>
<li>部署在NGINX Web服务器后面 - 容器化设置</li>
</ul>
<h2 id="1-使用-Java-Archive-JAR-作为独立应用程序进行部署"><a href="#1-使用-Java-Archive-JAR-作为独立应用程序进行部署" class="headerlink" title="1. 使用 Java Archive (JAR) 作为独立应用程序进行部署"></a>1. 使用 Java Archive (JAR) 作为独立应用程序进行部署</h2><p>Spring Boot 应用程序可以轻松打包到 JAR 文件中，并作为独立应用程序进行部署。这是通过 spring-boot-maven-plugin 这个插件完成的。一旦Spring项目通过 <a target="_blank" rel="noopener" href="https://start.spring.io/">Spring Initializr</a> 创建为Maven项目，插件就会自动添加到pom.xml中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>要将应用程序打包在单个 jar 文件中，需要在项目目录下运行maven命令 <code>mvn package</code>。这将把应用程序打包到一个可执行的jar文件中，该文件包含所有依赖项（包括嵌入式servlet容器 ，如果它是一个Web应用程序）。要运行 jar 文件，请使用以下标准JVM命令 <code>java -jar &lt;jar-file-name&gt;.jar </code>。</p>
<h2 id="2-将-Web-Application-Archive-WAR-部署到servlet容器中"><a href="#2-将-Web-Application-Archive-WAR-部署到servlet容器中" class="headerlink" title="2. 将 Web Application Archive (WAR) 部署到servlet容器中"></a>2. 将 Web Application Archive (WAR) 部署到servlet容器中</h2><p>可以将Spring Boot应用程序打包到WAR文件中，以部署到现有的servlet容器（例如Tomcat，Jetty等）中。可以按如下方式完成：</p>
<p>在pom.xml文件中，通过 <code>&lt;packaging&gt; war &lt;/ packaging&gt;</code> 指定为WAR包。这会将应用程序打包成WAR文件（而不是JAR）。在第二步，将Tomcat（servlet容器）依赖关系的范围设置为provided（以便它不会部署到WAR文件中）：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat&lt;/artifactId</span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过继承 SpringBootServletInitializer 并重写 configure 方法来初始化 Tomcat 所需的 Servlet 上下文，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApp</span> <span class="keyword">extends</span> <span class="title class_">SpringBootServletInitializer</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> SpringApplicationBuilder <span class="title function_">configure</span><span class="params">(SpringApplicationBuilder builder)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> builder.sources(DemoApp.class);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    SpringApplication.run(DemoApp.class, args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要将应用程序打包到 war 文件中，请在项目目录下运行标准maven命令<code>mvn clean package</code>。这将生成可以部署到 servlet 容器中的 WAR 包。要在现有 Tomcat 容器中运行应用程序，请将生成的 WAR 文件复制到<code> tomcat/webapps/</code>目录。</p>
<h2 id="3-在Docker容器中部署"><a href="#3-在Docker容器中部署" class="headerlink" title="3. 在Docker容器中部署"></a>3. 在Docker容器中部署</h2><p>在将应用程序部署到Docker容器之前，我们首先要将应用程序打包在 JAR 文件中。之前已经解释了这个过程，因此我假设我们有一个jar文件。</p>
<p>在第一步，我们需要构建一个容器镜像。为此，我们首先在项目根目录中创建一个Dockerfile文件，如下所示：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># latest oracle openjdk is the basis 将最新的oracle openjdk作为基础</span></span><br><span class="line"><span class="keyword">FROM</span> openjdk:oracle</span><br><span class="line"><span class="comment"># copy jar file into container image under app directory   将jar文件复制到容器镜像的app目录</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> target/demoApp.jar app/demoApp.jar</span></span><br><span class="line"><span class="comment"># expose server port accept connections  暴露服务端口接收连接</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="comment"># start application 运行应用程序</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>, <span class="string">&quot;-jar&quot;</span>, <span class="string">&quot;app/demoApp.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>请注意，在上面的代码片段中，我们假设应用程序 JAR 文件“demoApp.jar”位于项目的 target 目录下。我们还假设嵌入式 servlet 端口是8080（这是 Tomcat 的默认情况）。</p>
<p>我们现在可以使用以下命令构建Docker镜像（Dockerfile所在的位置）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t demo-app:latest .</span><br></pre></td></tr></table></figure>

<p>其中 -t 是要构建的镜像的名称和标记。构建镜像后，我们可以通过以下方式创建和运行容器：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container run -p 8080:8080 -d --name app-container demo-app</span><br></pre></td></tr></table></figure>

<p>其中<code>-p</code>将主机端口(映射)到容器端口(在这种情况下，两者都是8080)。选项<code>-d</code>（detach）是指在后台运行容器，<code> - name</code>指定容器的名称。</p>
<h2 id="4-部署在NGINX-Web服务器后面-直接设置"><a href="#4-部署在NGINX-Web服务器后面-直接设置" class="headerlink" title="4. 部署在NGINX Web服务器后面 - 直接设置"></a>4. 部署在NGINX Web服务器后面 - 直接设置</h2><p>为实际生产配置 servlet 容器（例如 Tomcat 或 Jetty ）（即在端口80上运行，没有root用户和使用SSL）可能不是直接的（但可行）。因此，建议在 Spring Boot 应用程序前使用Web服务器（如Nginx）。这可以通过两种方式完成: 直接设置或容器设置。在本节中，我们将演示直接设置。</p>
<p>在直接设置中，我们直接在 localhost 上运行 Nginx Web 服务器和 Spring Boot 应用程序（当然在不同的端口上）。我们让 Ngnix 代理 REST 请求到 Spring Boot 应用程序。为了这：</p>
<p>1.通过 <code>sudo apt-get install nginx</code> 在 Linux 上安装 Nginx Web 服务器</p>
<p>2.使用文本编辑器打开文件&#x2F;etc&#x2F;ngnix&#x2F;sites-available&#x2F;default</p>
<p>3.比如说，我们有两个 Spring Boot 应用程序需要代理。可以用以下内容替换文件中的 location 块。请注意，可以在<a target="_blank" rel="noopener" href="https://www.nginx.com/resources/wiki/start/topics/examples/javaservers/">此处</a>找到所有Nginx-Java配置</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /app1 &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://localhost:8080;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">location</span> /app2 &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://localhost:9000;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于此，来自 <code>http://localhost/app1/</code>的请求将被定向到 <code>/http://localhost:8080/</code>，来自 <code>http://localhost/app2/ </code>的请求将被定向到 <code>/http://localhost:9000/</code>。</p>
<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>如果您正在运行 Spring Boot 应用程序的多个实例，则可以启用 Nginx 以应用负载均衡。例如，如果我们在端口8080,8081和8082上运行3个 app1 实例。我们可以在这些服务器之间进行负载均衡，如下所示：</p>
<p>打开文件 <code>/etc/ngnix/sites-available/default</code> 并在文件顶部添加以下内容（在服务器内容之前）：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># configure load-balancing 配置负载均衡</span></span><br><span class="line"><span class="section">upstream</span> backend &#123;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8080</span>;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8081</span>;</span><br><span class="line">  <span class="attribute">server</span> localhost:<span class="number">8082</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 app1 的 proxy_pass 参数，如下所示：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">location</span> /app1 &#123;</span><br><span class="line">  <span class="attribute">proxy_pass</span> http://backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基于此，来自 <code>http://localhost/app1/</code> 的请求将被定向到 <code>/http://localhost:8080/</code>，<code>/http://localhost:8081/</code>或 <code>/http://localhost:8082/</code>的其中之一。</p>
<h2 id="5-部署在NGINX-Web服务器后面-容器化设置"><a href="#5-部署在NGINX-Web服务器后面-容器化设置" class="headerlink" title="5. 部署在NGINX Web服务器后面 - 容器化设置"></a>5. 部署在NGINX Web服务器后面 - 容器化设置</h2><p>在容器化设置中，我们将 Nginx Web 服务器和所有 Spring Boot 应用程序部署在单独的 Docker 容器上。我们让Nginx（在自己的容器中运行）向Spring Boot应用程序容器代理REST请求。</p>
<p>我们首先将所有 Spring Boot 应用程序打包在 jar 文件中（之前已经解释过）。此时，请注意通过向application.properties（或application.yml）文件添加以下代码来为每个Spring Boot应用程序设置单个服务器端口和根上下文路径：</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8082</span></span><br><span class="line"><span class="attr">server.servlet.context-path</span>=<span class="string">/search-service</span></span><br></pre></td></tr></table></figure>

<p>然后我们将生成的 jar 包部署在单独的 Docker 容器中（之前也有解释）。</p>
<p>例如，我们部署了四个 Spring Boot 应用程序; 一个“分析服务”实例和三个“搜索服务”实例。搜索服务的三个实例将由Nginx负载均衡。我们的基本架构如下所示：</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190603191203.png"></p>
<p>我们基于默认配置创建 Nginx 配置文件 nginx.conf 。我们为每个服务添加负载均衡和代理信息，如下所示：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">http</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="section">upstream</span> backend &#123;</span><br><span class="line">    <span class="attribute">server</span> search-service-<span class="number">1</span>:<span class="number">8080</span>;</span><br><span class="line">    <span class="attribute">server</span> search-service-<span class="number">2</span>:<span class="number">8081</span>;</span><br><span class="line">    <span class="attribute">server</span> search-service-<span class="number">3</span>:<span class="number">8082</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">80</span> default_server;</span><br><span class="line">    <span class="attribute">root</span> /var/www/html;</span><br><span class="line">    <span class="attribute">server_name</span> _;</span><br><span class="line">    <span class="section">location</span> /search-service &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://backend/search-service;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="section">location</span> /analysis-service &#123;</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://analysis-service:8083/analysis-service;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="section">events</span> &#123; <span class="attribute">worker_connections</span> <span class="number">1024</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>基于此，来自<code>http://localhost/search-service/</code>的请求将被定向到 <code>/http://search-service-1:8080/search-service/</code>, <code>/http://search-service-2:8081/search-service/ </code>和  <code>/http://search-service-3:8082/search-service/</code>，来自 <code>http://localhost/analysis-service/</code> 的请求将被定向到 <code>/http://analysis-service:8083/analysis-service/</code>。</p>
<p>创建配置文件（nginx.conf）后，我们将在Docker容器中部署 Nginx Web 服务器。为此，我们创建一个Dockerfile ，如下所示：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># latest nginx 最新的nginx</span></span><br><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="comment"># copy custom configuration file  复制自定义配置文件</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> nginx.conf /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="comment"># expose server port 暴露服务端口</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br><span class="line"><span class="comment"># start server 开启服务</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;nginx&quot;</span>, <span class="string">&quot;-g&quot;</span>, <span class="string">&quot;daemon off;&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<p>我们为 Nginx Web 服务器构建一个Docker镜像，如下所示：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image build -t custom-nginx:latest .</span><br></pre></td></tr></table></figure>

<p>构建所有Docker镜像后，可以通过在以下 docker-compose.yml 文件上运行<code>docker-compose up</code>命令来部署所有系统：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3.7&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  nginx_server:</span><br><span class="line">    image: custom-nginx</span><br><span class="line">    ports:</span><br><span class="line">      - <span class="string">&#x27;80:80&#x27;</span></span><br><span class="line">    networks:</span><br><span class="line">      - demo-network</span><br><span class="line">    depends_on:</span><br><span class="line">      - <span class="string">&quot;search-service-1&quot;</span></span><br><span class="line">      - <span class="string">&quot;search-service-2&quot;</span></span><br><span class="line">      - <span class="string">&quot;search-service-3&quot;</span></span><br><span class="line">      - <span class="string">&quot;analysis-service&quot;</span></span><br><span class="line">search-service-<span class="number">1</span>:</span><br><span class="line">  image: search-service-<span class="number">1</span></span><br><span class="line">  ports:</span><br><span class="line">    - <span class="string">&#x27;8080:8080&#x27;</span></span><br><span class="line">  networks:</span><br><span class="line">    - demo-network</span><br><span class="line">search-service-<span class="number">2</span>:</span><br><span class="line">  image: search-service-<span class="number">2</span></span><br><span class="line">  ports:</span><br><span class="line">    - <span class="string">&#x27;8081:8081&#x27;</span></span><br><span class="line">  networks:</span><br><span class="line">    - demo-network</span><br><span class="line">search-service-<span class="number">3</span>:</span><br><span class="line">  image: search-service-<span class="number">3</span></span><br><span class="line">  ports:</span><br><span class="line">    - <span class="string">&#x27;8082:8082&#x27;</span></span><br><span class="line">  networks:</span><br><span class="line">    - demo-network</span><br><span class="line">analysis-service:</span><br><span class="line">  image: analysis-service</span><br><span class="line">  ports:</span><br><span class="line">    - <span class="string">&#x27;8083:8083&#x27;</span></span><br><span class="line">  networks:</span><br><span class="line">    - demo-network</span><br><span class="line">networks:</span><br><span class="line">  demo-network:</span><br><span class="line">    name: demo-network</span><br></pre></td></tr></table></figure>

<p>以上，我们演示了部署 Spring Boot 应用程序的五种方法。选择哪种部署方式要基于整体架构以及目标平台的要求，例如安全性和可用资源。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-面向面试题学习-1-2019-6-2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/06/02/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E4%B9%A0-1-2019-6-2/"
    >面向面试题学习(1) 2019-6-2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/06/02/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E4%B9%A0-1-2019-6-2/" class="article-date">
  <time datetime="2019-06-02T13:02:27.000Z" itemprop="datePublished">2019-06-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190602210342.png"></p>
<ol>
<li>500和505的WEB错误码</li>
<li>二叉树的翻转算法</li>
</ol>
<h2 id="1-500和505的WEB错误码"><a href="#1-500和505的WEB错误码" class="headerlink" title="1. 500和505的WEB错误码"></a>1. 500和505的WEB错误码</h2><h3 id="500"><a href="#500" class="headerlink" title="500"></a>500</h3><p>服务器500错误。500错误的出现原因是很多的，但是你要知道，500错误是服务器内部错误，而且一般程序上是ASP错误为多的，可能是你的用户权限的问题导致，或者是数据库连接出现了错误，那么要好好检查下服务器语句错误问题。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190603123740.png"></p>
<h3 id="501"><a href="#501" class="headerlink" title="501"></a>501</h3><p><strong>服务器501错误。</strong>服务器501错误是服务器还是不具有请求功能的，而且501错误原因是没有实施的，可以用来HttpWebRequest指定一个UserAgent来试试的，有时候你可以换电脑来测试一下的。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190603124004.png"></p>
<h3 id="502"><a href="#502" class="headerlink" title="502"></a>502</h3><p><strong>服务器502错误。</strong>这是服务器上的一个错误网关 ，因此说它是无效的，我们在出现了服务器502错误问题的时候，最好是先清除下缓存或者是在服务器上进行刷新试试的，因为502错误牵扯的问题也是很多的，最好是让程序们来去在服务器上下文章。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190603124144.png"></p>
<h3 id="503"><a href="#503" class="headerlink" title="503"></a>503</h3><p><strong>服务器503错误</strong>。服务不可用是的一种状态，那么在服务器503错误出现了之后，大家不必担心的， 服务器或许就是正在维护或者暂停了，你可以联系一下服务器空间商。还有的时候cpu占用的频率大导致的。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190603124233.png"></p>
<h3 id="504"><a href="#504" class="headerlink" title="504"></a>504</h3><p><strong>服务器504错误。</strong>这是代表着网关超时是现象出现了。504错误问题是一个不好办的问题，当然你必须尝试着和网站官方获得联系，认真的去检查不同的电脑简的ip传输的状况。而且这个504错误要专业的负责人才能去解决。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190603124307.png"></p>
<h3 id="505"><a href="#505" class="headerlink" title="505"></a>505</h3><p><strong>服务器505错误</strong>。http的版本是不受支持的，一般的请款下浏览器的默认都是1.x 的版本的， 如果出现了HTTP 1.1版本的，那么你需要在Internet 选项的高级下进行设置的。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190603124355.png"></p>
<h2 id="2-二叉树的翻转算法"><a href="#2-二叉树的翻转算法" class="headerlink" title="2. 二叉树的翻转算法"></a>2. 二叉树的翻转算法</h2><blockquote>
<p>英文题解地址 <a target="_blank" rel="noopener" href="https://leetcode.com/problems/invert-binary-tree/solution/">invert-binary-tree</a></p>
</blockquote>
<h4 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h4><p>这是一个经典的树问题，最适合递归方法。</p>
<p><strong>算法</strong></p>
<p>空树翻转之后还是空树。根节点（root）的左子节点及其所有的子孙节点构成根节点的左子树（left subtree），同样的，根节点（root）的右子节点及其所有的子孙节点构成根节点的右子树（right subtree）。因此翻转一个二叉树，就是把根节点的左子树翻转一下，同样的把右子树翻转一下，在交换左右子树就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">    root.left = right;</span><br><span class="line">    root.right = left;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<code>O(n)</code>，由于树中的每个节点仅被访问一次，因此时间复杂度为<code>O(n)</code>，其中<code>n</code>是树中的节点数。我们不能做得更好，因为我们必须访问每个节点来反转它。。</li>
<li>空间复杂度：<code>O(n)</code>，由于递归，在最坏的情况下，<code>O(h)</code>函数调用将被放置在堆上，其中h是树的高度。因为在 <code>h ∈ O(n)</code>，所以空间复杂度是<code>O(n)</code>。</li>
</ul>
<h4 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h4><p>或者，我们可以以类似于广度优先搜索的方式迭代地解决问题</p>
<p><strong>算法</strong></p>
<p>我们的想法是，我们需要交换树中所有节点的左右子节点。因此，我们创建一个队列来存储其左右孩子尚未交换的节点。最初，只有根位于队列中。只要队列不为空，就从队列中取出下一个节点，交换其子节点，然后将子节点添加到队列中。空节点不添加到队列中。最终，队列将为空并且所有子项都交换，我们返回原始根。</p>
<ul>
<li>使用队列</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// LinkedList实现了集合框架的Queue接口</span></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.add(root); <span class="comment">// 加入元素</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">      <span class="comment">// 获取并移出元素</span></span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">current</span> <span class="operator">=</span> queue.poll();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//交换左右子树</span></span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> current.left;</span><br><span class="line">      current.left = current.right;</span><br><span class="line">      current.right = temp;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//左子树不为空，将左子树入栈</span></span><br><span class="line">      <span class="keyword">if</span> (current.left != <span class="literal">null</span>) queue.add(current.left);</span><br><span class="line">      <span class="comment">//右子树不为空，将右子树入栈</span></span><br><span class="line">      <span class="keyword">if</span> (current.right != <span class="literal">null</span>) queue.add(current.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>使用栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);<span class="comment">//先将根节点压入堆栈</span></span><br><span class="line">    <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//根据栈的先进后出操作，获取栈中最后一个元素，即最先入栈的元素</span></span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> stack.lastElement();</span><br><span class="line">      stack.pop();<span class="comment">//弹出栈顶元素</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//交换左右子树</span></span><br><span class="line">      <span class="type">TreeNode</span> <span class="variable">tempLeft</span> <span class="operator">=</span> temp.left;</span><br><span class="line">      temp.left = temp.right;</span><br><span class="line">      temp.right = tempLeft;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//左子树不为空，将左子树入栈</span></span><br><span class="line">      <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(temp.left);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//右子树不为空，将右子树入栈</span></span><br><span class="line">      <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack.push(temp.right);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(n)，由于树中的每个节点仅被访问 &#x2F; 添加到队列一次，因此时间复杂度为O(n)，其中n是树中的节点数。</li>
<li>空间复杂度：O(n)，因为在最坏的情况下，队列将包含二叉树的一个级别中的所有节点。对于完整的二叉树，叶级别为⌈<em>n</em>&#x2F;2⌉&#x3D;<em>O</em>(<em>n</em>) 。</li>
</ul>
<p>Analysis written by: @noran</p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>翻译的可能不够准确，请在下面的评论中批评指正。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-sjjaskjk-u.html">http://www.voidcn.com/article/p-sjjaskjk-u.html</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AD%A6%E4%B9%A0/" rel="tag">面向面试题学习</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Spring-Autowired和构造函数的顺序"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/06/02/Spring-Autowired%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%A1%BA%E5%BA%8F/"
    >Spring @Autowired和构造函数的顺序 </a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/06/02/Spring-Autowired%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E9%A1%BA%E5%BA%8F/" class="article-date">
  <time datetime="2019-06-02T05:17:52.000Z" itemprop="datePublished">2019-06-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>最近写代码需要在构造函数中调用一个本class的函数，而这个函数中用到了本class的@Autowired的变量。</p>
<p>于是觉得可能会出错。因为@Autowired一定要等本类构造完成后，才能从外部引用设置进来。所以@Autowired的注入时间一定会晚于构造函数的执行时间。</p>
<p>那，这个局怎么破？</p>
<p>原始代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IPluginService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统加载的所有插件的接入接口列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;IPluginAccess&gt; plugins;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统加载的所有插件的信息列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, PluginInfo&gt; pluginInfoMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PluginServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        pluginInfoMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, PluginInfo&gt;();</span><br><span class="line">        <span class="comment">// 初始化所有插件</span></span><br><span class="line">        initial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 用到了plugins变量</span></span><br><span class="line">        plugins.xxxxxxxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后来查到Spring的建议： 总是在您的bean中使用构造函数建立依赖注入。</p>
<p>所以，代码改成如下，问题解决。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PluginServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">IPluginService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统加载的所有插件的接入接口列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;IPluginAccess&gt; plugins;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统加载的所有插件的信息列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, PluginInfo&gt; pluginInfoMap;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PluginServiceImpl</span><span class="params">(List&lt;IPluginAccess&gt; plugins)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.plugins = plugins;</span><br><span class="line">        pluginInfoMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, PluginInfo&gt;();</span><br><span class="line">        <span class="comment">// 初始化所有插件</span></span><br><span class="line">        initial();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initial</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 用到了plugins变量</span></span><br><span class="line">        plugins.xxxxxxxx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关文章</p>
<ul>
<li><ol>
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-wtjvgeys-no.html">构造函数的顺序</a></li>
</ol>
</li>
<li><ol start="2">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-buuzpxnx-os.html">构造函数的构造顺序</a></li>
</ol>
</li>
<li><ol start="3">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-qfjbseof-bhd.html">构造函数顺序</a></li>
</ol>
</li>
<li><ol start="4">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-vaiytonw-ov.html">Spring-Bean的构造函数和Setter执行顺序以及InitializingBean</a></li>
</ol>
</li>
<li><ol start="5">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-pundccfc-nz.html">构造函数和析构函数的执行顺序相反</a></li>
</ol>
</li>
<li><ol start="6">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-nmjiaxgk-bka.html">构造函数和析构函数的调用顺序</a></li>
</ol>
</li>
<li><ol start="7">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-sfinabkp-ts.html">C++构造函数和析构函数的调用顺序</a></li>
</ol>
</li>
<li><ol start="8">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-kbfzgltt-yp.html">C++中构造函数和析构函数的执行顺序</a></li>
</ol>
</li>
<li><ol start="9">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-zbfvnfso-bdn.html">关于构造函数和析构函数的调用顺序</a></li>
</ol>
</li>
<li><ol start="10">
<li><a target="_blank" rel="noopener" href="http://www.voidcn.com/article/p-svcrbndw-bdy.html">c++中， 构造函数和析构函数的执行顺序</a></li>
</ol>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Autowired的使用：推荐对构造函数进行注释"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/06/02/Autowired%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A%E6%8E%A8%E8%8D%90%E5%AF%B9%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%B3%A8%E9%87%8A/"
    >@Autowired的使用：推荐对构造函数进行注释</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/06/02/Autowired%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%9A%E6%8E%A8%E8%8D%90%E5%AF%B9%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E6%B3%A8%E9%87%8A/" class="article-date">
  <time datetime="2019-06-02T05:04:12.000Z" itemprop="datePublished">2019-06-02</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>作者：阿丙</p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/acm-bingzi">www.cnblogs.com/acm-bingzi</a></p>
</blockquote>
<p>在编写代码的时候，使用@Autowired注解是，发现IDE报的一个警告，如下：</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190602130450.png"></p>
<p>Spring Team recommends “Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies”.</p>
<p>翻译：</p>
<blockquote>
<p>Spring建议”总是在您的bean中使用构造函数建立依赖注入。总是使用断言强制依赖”。</p>
</blockquote>
<p>这段代码警告原来的写法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private EnterpriseDbService service;</span><br></pre></td></tr></table></figure>

<p>建议后写成下面的样子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private final EnterpriseDbService service;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">public EnterpriseDbController(EnterpriseDbService service) &#123;</span><br><span class="line">   this.service = service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>奇怪，为何会有这样的建议。</p>
<p>我们知道：**@Autowired 可以对成员变量、方法以及构造函数进行注释。**那么对成员变量和构造函数进行注释又有什么区别呢？</p>
<p>@Autowired注入bean，相当于在配置文件中配置bean，并且使用setter注入。而对构造函数进行注释，就相当于是使用构造函数进行依赖注入了吧。莫非是这两种注入方法的不同。</p>
<p><strong>以下是：@Autowired和构造方法执行的顺序解析</strong></p>
<p>先看一段代码，下面的代码能运行成功吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"><span class="keyword">private</span> String school;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UserAccountServiceImpl</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.school = user.getSchool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>答案是不能。</strong></p>
<p><strong>因为Java类会先执行构造方法，然后再给注解了@Autowired 的user注入值</strong>，所以在执行构造方法的时候，就会报错。</p>
<p>报错信息可能会像下面：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; </span><br><span class="line">org.springframework.beans.factory.BeanCreationException: Error creating </span><br><span class="line">bean with name &#x27;...&#x27; defined in file [....class]: Instantiation of bean </span><br><span class="line">failed; nested exception is </span><br><span class="line">org.springframework.beans.BeanInstantiationException: Failed to </span><br><span class="line">instantiate [...]: Constructor threw exception; nested exception is </span><br><span class="line">java.lang.NullPointerException</span><br></pre></td></tr></table></figure>

<p>报错信息说：创建Bean时出错，出错原因是实例化bean失败，因为bean时构造方法出错，在构造方法里抛出了空指针异常。</p>
<p>解决办法是，使用构造器注入，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private User user;</span><br><span class="line">private String school;</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">public UserAccountServiceImpl(User user)&#123;</span><br><span class="line">    this.user = user;</span><br><span class="line">    this.school = user.getSchool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，使用构造器注入的方法，可以明确成员变量的加载顺序。</p>
<blockquote>
<p>PS：Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法–&gt;@Autowired</p>
<p>参考：<a target="_blank" rel="noopener" href="http://blog.csdn.net/ruangong1203/article/details/50992147">http://blog.csdn.net/ruangong1203/article/details/50992147</a></p>
</blockquote>
<p><strong>那么最开始Spring建议，为何要将成员变量加上final类型呢？</strong></p>
<p>网上有解释如下：spring配置默认的bean的scope是singleton，也就是启动后一直有。通过设置bean的scope属性为prototype来声明该对象为动态创建。但是，如果你的service本身是singleton，注入只执行一次。</p>
<p>@Autowired本身就是单例模式，只会在程序启动时执行一次，即使不定义final也不会初始化第二次，所以这个final是没有意义的吧。</p>
<p>可能是为了防止，在程序运行的时候，又执行了一遍构造函数；</p>
<p>或者是更容易让人理解的意思，加上final只会在程序启动的时候初始化一次，并且在程序运行的时候不会再改变。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring/" rel="tag">spring</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-vultr安装ssr"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/06/01/vultr%E5%AE%89%E8%A3%85ssr/"
    >vultr安装ssr</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/06/01/vultr%E5%AE%89%E8%A3%85ssr/" class="article-date">
  <time datetime="2019-06-01T04:58:50.000Z" itemprop="datePublished">2019-06-01</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>ssh连接服务器</p>
<p>运行脚本</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks-libev_CN.sh https://raw.githubusercontent.com/uxh/shadowsocks_bash/master/shadowsocks-libev_CN.sh &amp;&amp; bash shadowsocks-libev_CN.sh</span><br></pre></td></tr></table></figure>

 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/ssr/" rel="tag">ssr</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-我对-RESTful-API、GraphQL、RPC-API-的思考"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/05/31/%E6%88%91%E5%AF%B9-RESTful-API%E3%80%81GraphQL%E3%80%81RPC-API-%E7%9A%84%E6%80%9D%E8%80%83/"
    >我对 RESTful API、GraphQL、RPC API 的思考</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/05/31/%E6%88%91%E5%AF%B9-RESTful-API%E3%80%81GraphQL%E3%80%81RPC-API-%E7%9A%84%E6%80%9D%E8%80%83/" class="article-date">
  <time datetime="2019-05-31T12:40:05.000Z" itemprop="datePublished">2019-05-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文作者：梁桂钊</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://www.infoq.cn/article/ZgAAVBZZaoo4I0-pkgV8">人人都是 API 设计师：我对 RESTful API、GraphQL、RPC API 的思考</a></p>
</blockquote>
<h2 id="一、定义好的规范，已经成功了一大半"><a href="#一、定义好的规范，已经成功了一大半" class="headerlink" title="一、定义好的规范，已经成功了一大半"></a>一、定义好的规范，已经成功了一大半</h2><p>通常情况下，规范就是大家约定俗成的标准，如果大家都遵守这套标准，那么自然沟通成本大大降低。例如，大家都希望从阿里的规范上面学习，在自己的业务中也定义几个领域模型：VO、BO、DO、DTO。其中，DO（Data Object）与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 而 DTO（Data Transfer Object）是远程调用对象，它是 RPC 服务提供的领域模型。对于 BO（Business Object），它是业务逻辑层封装业务逻辑的对象，一般情况下，它是聚合了多个数据源的复合对象。那么，VO（View Object） 通常是请求处理层传输的对象，它通过 Spring 框架的转换后，往往是一个 JSON 对象。</p>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190531211947.png"></p>
<p>事实上，阿里这种复杂的业务中如果不划分清楚 DO、BO、DTO、VO 的领域模型，其内部代码很容易就混乱了，内部的 RPC 在 service 层的基础上又增加了 manager 层，从而实现内部的规范统一化。但是，如果只是单独的域又没有太多外部依赖，那么，完全不要设计这么复杂，除非预期到可能会变得庞大和复杂化。对此，设计过程中因地制宜就显得特别重要了。</p>
<p>另外一个规范的例子是 RESTful API。在 REST 架构风格中，每一个 URI 代表一种资源。因此，URI 是每一个资源的地址的唯一资源定位符。所谓资源，实际上就是一个信息实体，它可以是服务器上的一段文本、一个文件、一张图片、一首歌曲，或者是一种服务。RESTful API 规定了通过 GET、 POST、 PUT、 PATCH、 DELETE 等方式对服务端的资源进行操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">【GET】          /users                 # 查询用户信息列表</span><br><span class="line">【GET】          /users/1001            # 查看某个用户信息</span><br><span class="line">【POST】         /users                 # 新建用户信息</span><br><span class="line">【PUT】          /users/1001            # 更新用户信息 (全部字段)</span><br><span class="line">【PATCH】        /users/1001            # 更新用户信息 (部分字段)</span><br><span class="line">【DELETE】       /users/1001            # 删除用户信息</span><br></pre></td></tr></table></figure>

<p>事实上，RESTful API 的实现分了四个层级。第一层次（Level 0）的 Web API 服务只是使用 HTTP 作为传输方式。第二层次（Level 1）的 Web API 服务引入了资源的概念。每个资源有对应的标识符和表达。第三层次（Level 2）的 Web API 服务使用不同的 HTTP 方法来进行不同的操作，并且使用 HTTP 状态码来表示不同的结果。第四层次（Level 3）的 Web API 服务使用 HATEOAS。在资源的表达中包含了链接信息。客户端可以根据链接来发现可以执行的动作。通常情况下，伪 RESTful API 都是基于第一层次与第二层次设计的。例如，我们的 Web API 中使用各种动词，例如 get_menu 和 save_menu ，而真正意义上的 RESTful API 需要满足第三层级以上。如果我们遵守了这套规范，我们就很可能就设计出通俗易懂的 API。</p>
<p>注意的是，定义好的规范，我们已经成功了一大半。如果这套规范是业内标准，那么我们可以大胆实践，不要担心别人不会用，只要把业界标准丢给他好好学习一下就可以啦。例如，Spring 已经在 Java 的生态中举足轻重，如果一个新人不懂 Spring 就有点说不过去了。但是，很多时候因为业务的限制和公司的技术，我们可能使用基于第一层次与第二层次设计的伪 RESTful API，但是它不一定就是落后的，不好的，只要团队内部形成规范，降低大家的学习成本即可。很多时候，我们试图改变团队的习惯去学习一个新的规范，所带来的收益（投入产出比）甚微，那就得不偿失了。</p>
<p>总结一下，定义好的规范的目的在于，降低学习成本，使得 API 尽可能通俗易懂。当然，设计的 API 通俗易懂还有其他方式，例如我们定义的 API 的名字易于理解，API 的实现尽可能通用等。</p>
<h2 id="二、探讨-API-接口的兼容性"><a href="#二、探讨-API-接口的兼容性" class="headerlink" title="二、探讨 API 接口的兼容性"></a>二、探讨 API 接口的兼容性</h2><p>API 接口都是不断演进的。因此，我们需要在一定程度上适应变化。在 RESTful API 中，API 接口应该尽量兼容之前的版本。但是，在实际业务开发场景中，可能随着业务需求的不断迭代，现有的 API 接口无法支持旧版本的适配，此时如果强制升级服务端的 API 接口将导致客户端旧有功能出现故障。实际上，Web 端是部署在服务器，因此它可以很容易为了适配服务端的新的 API 接口进行版本升级，然而像 Android 端、IOS 端、PC 端等其他客户端是运行在用户的机器上，因此当前产品很难做到适配新的服务端的 API 接口，从而出现功能故障，这种情况下，用户必须升级产品到最新的版本才能正常使用。为了解决这个版本不兼容问题，在设计 RESTful API 的一种实用的做法是使用版本号。一般情况下，我们会在 url 中保留版本号，并同时兼容多个版本。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">【GET】  /v1/users/&#123;user_id&#125;  // 版本 v1 的查询用户列表的 API 接口</span><br><span class="line">【GET】  /v2/users/&#123;user_id&#125;  // 版本 v2 的查询用户列表的 API 接口</span><br></pre></td></tr></table></figure> 
      <a class="article-more-link" href="/2019/05/31/%E6%88%91%E5%AF%B9-RESTful-API%E3%80%81GraphQL%E3%80%81RPC-API-%E7%9A%84%E6%80%9D%E8%80%83/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/restful/" rel="tag">restful</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-纯干货，Spring-data-jpa详解，全方位介绍。"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/05/30/%E7%BA%AF%E5%B9%B2%E8%B4%A7%EF%BC%8CSpring-data-jpa%E8%AF%A6%E8%A7%A3%EF%BC%8C%E5%85%A8%E6%96%B9%E4%BD%8D%E4%BB%8B%E7%BB%8D%E3%80%82/"
    >纯干货，Spring data jpa详解，全方位介绍。</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/05/30/%E7%BA%AF%E5%B9%B2%E8%B4%A7%EF%BC%8CSpring-data-jpa%E8%AF%A6%E8%A7%A3%EF%BC%8C%E5%85%A8%E6%96%B9%E4%BD%8D%E4%BB%8B%E7%BB%8D%E3%80%82/" class="article-date">
  <time datetime="2019-05-30T08:49:32.000Z" itemprop="datePublished">2019-05-30</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dreamroute/p/5173896.html">纯干货，Spring-data-jpa详解，全方位介绍</a></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/gaohanghang/images/master/img20190530165146.png"></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/spring-data-jpa/" rel="tag">spring data jpa</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Gradle、Maven项目相互转换"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/05/30/Gradle%E3%80%81Maven%E9%A1%B9%E7%9B%AE%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/"
    >Gradle、Maven项目相互转换</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/05/30/Gradle%E3%80%81Maven%E9%A1%B9%E7%9B%AE%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2/" class="article-date">
  <time datetime="2019-05-30T05:19:42.000Z" itemprop="datePublished">2019-05-30</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p><strong>原文作者：</strong> 夏末</p>
<p><strong>原文链接：</strong> <a target="_blank" rel="noopener" href="https://notes.wanghao.work/2017-08-21-Gradle%E3%80%81Maven%E9%A1%B9%E7%9B%AE%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2.html">https://notes.wanghao.work/2017-08-21-Gradle、Maven项目相互转换.html</a></p>
</blockquote>
<p>在开发Android项目的时候，使用的是<code>Gradle</code>构建工具，喜欢它的灵活和方便，在转向Java后端开发的时候更多时候使用的是<code>Maven</code>构建工具，然而看着漫天的尖括号，心里实在是难受。虽然只是一个构建工具，本着折腾的心，我还是更认可和看好<code>Gradle</code>。然而很多时候你的队友并没有习惯去使用或者快速熟悉<code>Gradle</code>构建工具，那么这个时候就需要将<code>Gradle</code>项目转换为Maven项目了，或者将Maven项目转换为<code>Gradle</code>项目了。</p>
<h3 id="安装Gradle／Maven"><a href="#安装Gradle／Maven" class="headerlink" title="安装Gradle／Maven"></a>安装Gradle／Maven</h3><p>首先是安装构建工具，这个没啥好说的。</p>
<h5 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h5><p>打开Powershell或者Cmder执行以下命令完成安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">choco install gradle</span><br><span class="line">choco install maven</span><br></pre></td></tr></table></figure>

<p><code>choco</code>为windows下的一款包管理工具，可以方便安装管理配置一些常见的软件包，如果你没有安装<code>choco</code>的话，请移步：<a target="_blank" rel="noopener" href="https://chocolatey.org/">https://chocolatey.org/</a></p>
<h5 id="Mac"><a href="#Mac" class="headerlink" title="Mac"></a>Mac</h5><p>打开Terminal，执行以下命令安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install gradle</span><br><span class="line">brew install maven</span><br></pre></td></tr></table></figure>

<h3 id="Maven-to-Gradle"><a href="#Maven-to-Gradle" class="headerlink" title="Maven to Gradle"></a>Maven to Gradle</h3><p>需要特别说明的是，<code>Gradle</code>对<code>Maven</code>的支持是比较完善的，因此，转换也是非常的简单，在<code>pom.xml</code>文件所在的目录下执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gradle init     # 根据pom.xml内容生成对应的gradle配置</span><br><span class="line">gradle build    # 开启gradle构建</span><br></pre></td></tr></table></figure>

<h3 id="Gradle-to-Maven"><a href="#Gradle-to-Maven" class="headerlink" title="Gradle to Maven"></a>Gradle to Maven</h3><p><code>Gradle</code>项目转<code>Maven</code>项目需要借助一个Gradle插件，在项目的<code>module</code>的<code>build.gradle</code>文件中加入以下配置即可：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: &#x27;maven&#x27;</span><br></pre></td></tr></table></figure>

<p>通过双击<code>Idea</code>的Gradle Tasks GUI:</p>
<p>或者执行命令来完成转换:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gradle install</span><br></pre></td></tr></table></figure>

<p>完成之后，将会在当前Module项目的<code>build</code>目录下的<code>poms</code>文件夹下生成<code>pom-default.xml</code>，将其拷贝到项目的根目录下即可。</p>
<ul>
<li>参考文档：<a target="_blank" rel="noopener" href="https://guides.gradle.org/migrating-from-maven/">https://guides.gradle.org/migrating-from-maven/</a></li>
</ul>
<hr>
<p>通过实际测试，这样的生成的<code>pom-default.xml</code>文件是不能用于直接<code>maven</code>构建的，因为生成的<code>pom-default.xml</code>文件中的<code>groupId</code>还需要我们手动指定下。这样显然是不清真的，于是我们可以在<code>build.gradle</code>文件中将其事先定义好，这样生成的pom文件就不用我们再手动更改了：</p>
<p>然而这样我们还是觉得麻烦，毕竟需要手动复制到项目根目录，再重新命名。我们还可以通过Hook Gradle中Maven插件的<code>install</code>Task来完成自动的复制和命名,编辑<code>build.gradle</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">task convert2Maven &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        file(&quot;$buildDir/poms/pom-default.xml&quot;).renameTo(file(&quot;$rootDir/pom.xml&quot;))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">install.dependsOn(convert2Maven)</span><br></pre></td></tr></table></figure>

<p>此时，再执行<code>gradle install</code>这个task就可以看到gradle已经自动为我们在项目的根目录下生成好了<code>pom.xml</code>文件啦。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Gradle/" rel="tag">Gradle</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-五种Sublime-text-3同时快速编辑多行内容"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2019/05/28/%E4%BA%94%E7%A7%8DSublime-text-3%E5%90%8C%E6%97%B6%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91%E5%A4%9A%E8%A1%8C%E5%86%85%E5%AE%B9/"
    >五种Sublime text 3同时快速编辑多行内容</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2019/05/28/%E4%BA%94%E7%A7%8DSublime-text-3%E5%90%8C%E6%97%B6%E5%BF%AB%E9%80%9F%E7%BC%96%E8%BE%91%E5%A4%9A%E8%A1%8C%E5%86%85%E5%AE%B9/" class="article-date">
  <time datetime="2019-05-28T09:04:35.000Z" itemprop="datePublished">2019-05-28</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <blockquote>
<p>原文地址 <a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_34719507/article/details/53891927">五种Sublime text 3同时快速编辑多行内容</a></p>
</blockquote>
<p>Sublime text 3是一个非常强大的网站编辑工具。 </p>
<p>其中快速编辑多行内容功能最为强大。 </p>
<p>先说下，使用下面的功能要安装一个叫emmet的插件。</p>
<p>下面就来看下具体的五种方式吧：</p>
<p>1，鼠标选中多行，按下 Ctrl Shift L (Command Shift L) 即可同时编辑这些行； </p>
<p>2，鼠标选中文本，反复按 CTRL D (Command D) 即可继续向下同时选中下一个相同的文本进行同时编辑； </p>
<p>3，鼠标选中文本，按下 Alt F3 (Win) 或 Ctrl Command G(Mac) 即可一次性选择全部的相同文本进行同时编辑； </p>
<p>4，Shift 鼠标右键 (Win) 或 Option 鼠标左键 (Mac) 或使用鼠标中键可以用鼠标进行竖向多行选择； </p>
<p>5，Ctrl 鼠标左键(Win) 或 Command 鼠标左键(Mac) 可以手动选择同时要编辑。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sublime-text-3/" rel="tag">Sublime text 3</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/29/">上一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="page-number" href="/page/29/">29</a><span class="page-number current">30</span><a class="page-number" href="/page/31/">31</a><a class="page-number" href="/page/32/">32</a><span class="space">&hellip;</span><a class="page-number" href="/page/44/">44</a><a class="extend next" rel="next" href="/page/31/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2015-2023
        <i class="ri-heart-fill heart_icon"></i> 高行行
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>访问人数:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>浏览次数:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="高行行的个人博客"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="http://gaohanghang.lofter.com">摄影</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/twitter">Twitter</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" target="_blank" rel="noopener" href="https://weibo.com/u/5125203090">微博</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="搜索">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.staticfile.org/jquery-modal/0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.staticfile.org/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.staticfile.org/photoswipe/4.1.3/default-skin/default-skin.min.css">
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="https://cdn.staticfile.org/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.staticfile.org/clipboard.js/2.0.10/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>